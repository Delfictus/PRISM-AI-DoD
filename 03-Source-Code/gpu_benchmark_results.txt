warning: patch for `cudarc` uses the features mechanism. default-features and features will not take effect because the patch dependency does not support this mechanism
   Compiling either v1.15.0
warning: prism-ai@0.1.0: Compiling CUBLAS interposer library for CUDA 12.8 compatibility
warning: prism-ai@0.1.0: Successfully compiled CUBLAS interposer library
warning: prism-ai@0.1.0: Interposer library at: /home/diddy/Desktop/PRISM-AI-DoD/03-Source-Code/target/release/build/prism-ai-0a2a4a3f381a983c/out/libcublas_interposer.so
warning: prism-ai@0.1.0: Compiling CUDA kernels with nvcc: /usr/local/cuda/bin/nvcc
warning: prism-ai@0.1.0: Detected Compute 12.0, using sm_90
warning: prism-ai@0.1.0: Compiling for GPU architecture: sm_90
warning: prism-ai@0.1.0: Compiling cuda_kernels/tensor_core_matmul.cu
warning: prism-ai@0.1.0: Successfully compiled cuda_kernels/tensor_core_matmul.cu to PTX
warning: prism-ai@0.1.0: Compiling neuromorphic kernels to shared library
warning: prism-ai@0.1.0: Successfully compiled neuromorphic kernels to shared library
warning: prism-ai@0.1.0: Library: /home/diddy/Desktop/PRISM-AI-DoD/03-Source-Code/target/release/build/prism-ai-0a2a4a3f381a983c/out/libneuromorphic_kernels.so
   Compiling plotters-backend v0.3.7
   Compiling ciborium-io v0.2.2
   Compiling clap_lex v0.7.5
   Compiling same-file v1.0.6
   Compiling cast v0.3.0
   Compiling tinytemplate v1.2.1
   Compiling is-terminal v0.4.16
   Compiling oorandom v11.1.5
   Compiling anes v0.1.6
   Compiling ciborium-ll v0.2.2
   Compiling walkdir v2.5.0
   Compiling clap_builder v4.5.48
   Compiling rayon v1.11.0
   Compiling itertools v0.10.5
   Compiling plotters-svg v0.3.7
   Compiling ciborium v0.2.2
   Compiling plotters v0.3.7
   Compiling criterion-plot v0.5.0
   Compiling clap v4.5.48
   Compiling gemm-common v0.18.2
   Compiling gemm-common v0.17.1
   Compiling neuromorphic-engine v0.1.0 (/home/diddy/Desktop/PRISM-AI-DoD/03-Source-Code/src/neuromorphic)
   Compiling prct-core v0.1.0 (/home/diddy/Desktop/PRISM-AI-DoD/03-Source-Code/src/prct-core)
   Compiling criterion v0.5.1
warning: unused import: `HashMap`
  --> src/prct-core/src/coloring.rs:10:24
   |
10 | use std::collections::{HashMap, HashSet};
   |                        ^^^^^^^
   |
   = note: `#[warn(unused_imports)]` on by default

warning: unused import: `rayon::prelude`
 --> src/prct-core/src/coloring.rs:9:5
  |
9 | use rayon::prelude::*;
  |     ^^^^^^^^^^^^^^

warning: unused variable: `neuro_state`
   --> src/prct-core/src/drpp_algorithm.rs:194:9
    |
194 |         neuro_state: &NeuroState,
    |         ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_neuro_state`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `quantum_state`
   --> src/prct-core/src/drpp_algorithm.rs:195:9
    |
195 |         quantum_state: &QuantumState,
    |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_quantum_state`

warning: unused variable: `phase_field`
   --> src/prct-core/src/drpp_algorithm.rs:196:9
    |
196 |         phase_field: &mut PhaseField,
    |         ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_phase_field`

warning: unused variable: `n`
  --> src/prct-core/src/simulated_annealing.rs:31:9
   |
31 |     let n = graph.num_vertices;
   |         ^ help: if this is intentional, prefix it with an underscore: `_n`

   Compiling gemm-f32 v0.17.1
   Compiling gemm-c64 v0.17.1
   Compiling gemm-c32 v0.17.1
   Compiling gemm-f64 v0.17.1
warning: use of deprecated associated function `gpu_reservoir::GpuReservoirComputer::new`: Use new_shared() with shared CUDA context
   --> src/neuromorphic/src/gpu_reservoir.rs:662:27
    |
662 |     GpuReservoirComputer::new(config, gpu_config)
    |                           ^^^
    |
    = note: `#[warn(deprecated)]` on by default

   Compiling gemm-f32 v0.18.2
   Compiling gemm-f64 v0.18.2
   Compiling gemm-c64 v0.18.2
   Compiling gemm-c32 v0.18.2
warning: unused import: `rayon::prelude`
  --> src/neuromorphic/src/gpu_reservoir.rs:15:5
   |
15 | use rayon::prelude::*;
   |     ^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` on by default

warning: unused variable: `reason`
   --> src/neuromorphic/src/pattern_detector.rs:357:30
    |
357 |     fn record_failure(&self, reason: &str) {
    |                              ^^^^^^ help: if this is intentional, prefix it with an underscore: `_reason`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `bin_source_past`
   --> src/neuromorphic/src/transfer_entropy.rs:109:17
    |
109 |             let bin_source_past = self.discretize_vector(&source_past);
    |                 ^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_bin_source_past`

warning: `prct-core` (lib) generated 6 warnings (run `cargo fix --lib -p prct-core` to apply 1 suggestion)
   Compiling gemm-f16 v0.17.1
warning: type `ReservoirStatistics` is more private than the item `ReservoirComputer::get_statistics`
   --> src/neuromorphic/src/reservoir.rs:224:5
    |
224 |     pub fn get_statistics(&self) -> &ReservoirStatistics {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method `ReservoirComputer::get_statistics` is reachable at visibility `pub`
    |
note: but type `ReservoirStatistics` is only usable at visibility `pub(self)`
   --> src/neuromorphic/src/reservoir.rs:108:1
    |
108 | struct ReservoirStatistics {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: `#[warn(private_interfaces)]` on by default

warning: fields `max_pool_size` and `total_allocated_bytes` are never read
  --> src/neuromorphic/src/gpu_memory.rs:17:5
   |
13 | pub struct GpuMemoryPool {
   |            ------------- fields in this struct
...
17 |     max_pool_size: usize,
   |     ^^^^^^^^^^^^^
18 |     total_allocated_bytes: Arc<Mutex<usize>>,
   |     ^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(dead_code)]` on by default

warning: hiding a lifetime that's elided elsewhere is confusing
   --> src/neuromorphic/src/gpu_memory.rs:302:29
    |
302 |     pub fn borrow_zero_copy(&mut self) -> Result<GpuBufferBorrow> {
    |                             ^^^^^^^^^            --------------- the same lifetime is hidden here
    |                             |
    |                             the lifetime is elided here
    |
    = help: the same lifetime is referred to in inconsistent ways, making the signature confusing
    = note: `#[warn(mismatched_lifetime_syntaxes)]` on by default
help: use `'_` for type paths
    |
302 |     pub fn borrow_zero_copy(&mut self) -> Result<GpuBufferBorrow<'_>> {
    |                                                                 ++++

   Compiling gemm-f16 v0.18.2
   Compiling gemm v0.17.1
   Compiling gemm v0.18.2
   Compiling ug v0.1.0
warning: `neuromorphic-engine` (lib) generated 7 warnings
   Compiling candle-core v0.8.4
   Compiling quantum-engine v0.1.0 (/home/diddy/Desktop/PRISM-AI-DoD/03-Source-Code/src/quantum)
warning: unused import: `Array1`
  --> src/quantum/src/prct_coloring.rs:12:15
   |
12 | use ndarray::{Array1, Array2};
   |               ^^^^^^
   |
   = note: `#[warn(unused_imports)]` on by default

warning: unused import: `Context`
  --> src/quantum/src/prct_coloring.rs:14:22
   |
14 | use anyhow::{Result, Context};
   |                      ^^^^^^^

warning: unused import: `Hamiltonian`
  --> src/quantum/src/prct_coloring.rs:17:47
   |
17 | use crate::hamiltonian::{PhaseResonanceField, Hamiltonian};
   |                                               ^^^^^^^^^^^

warning: unused import: `HashMap`
  --> src/quantum/src/gpu_coloring.rs:10:24
   |
10 | use std::collections::{HashMap, HashSet};
   |                        ^^^^^^^

warning: unused import: `Context`
 --> src/quantum/src/prct_tsp.rs:8:22
  |
8 | use anyhow::{Result, Context};
  |                      ^^^^^^^

warning: unused import: `Context`
  --> src/quantum/src/qubo.rs:10:22
   |
10 | use anyhow::{anyhow, Context, Result};
   |                      ^^^^^^^

warning: unused import: `std::sync::Arc`
  --> src/quantum/src/qubo.rs:12:5
   |
12 | use std::sync::Arc;
   |     ^^^^^^^^^^^^^^

warning: variable does not need to be mutable
   --> src/quantum/src/gpu_coloring.rs:287:13
    |
287 |         let mut gpu_priorities = stream.alloc_zeros::<f32>(n)
    |             ----^^^^^^^^^^^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` on by default

warning: variable does not need to be mutable
   --> src/quantum/src/gpu_coloring.rs:289:13
    |
289 |         let mut gpu_colors = stream.alloc_zeros::<u32>(n)
    |             ----^^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
   --> src/quantum/src/gpu_coloring.rs:291:13
    |
291 |         let mut gpu_can_color = stream.alloc_zeros::<u32>(n)
    |             ----^^^^^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: value assigned to `current_energy` is never read
   --> src/quantum/src/qubo.rs:161:17
    |
161 |         let mut current_energy = self.best_energy;
    |                 ^^^^^^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?
    = note: `#[warn(unused_assignments)]` on by default

warning: variable `tour_gpu` is assigned to, but never used
  --> src/quantum/src/gpu_k_opt.rs:86:17
   |
86 |         let mut tour_gpu = stream.memcpy_stod(&tour_i32)?;
   |                 ^^^^^^^^
   |
   = note: consider using `_tour_gpu` instead
   = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `dist_gpu`
  --> src/quantum/src/gpu_k_opt.rs:89:13
   |
89 |         let dist_gpu = stream.memcpy_stod(&dist_flat)?;
   |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_dist_gpu`

warning: unused variable: `best_i_gpu`
  --> src/quantum/src/gpu_k_opt.rs:92:17
   |
92 |         let mut best_i_gpu = stream.alloc_zeros::<i32>(1)?;
   |                 ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_best_i_gpu`

warning: unused variable: `best_j_gpu`
  --> src/quantum/src/gpu_k_opt.rs:93:17
   |
93 |         let mut best_j_gpu = stream.alloc_zeros::<i32>(1)?;
   |                 ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_best_j_gpu`

warning: variable `best_delta_gpu` is assigned to, but never used
  --> src/quantum/src/gpu_k_opt.rs:94:17
   |
94 |         let mut best_delta_gpu = stream.memcpy_stod(&[f32::INFINITY])?;
   |                 ^^^^^^^^^^^^^^
   |
   = note: consider using `_best_delta_gpu` instead

warning: value assigned to `tour_gpu` is never read
   --> src/quantum/src/gpu_k_opt.rs:104:13
    |
104 |             tour_gpu = stream.memcpy_stod(&tour_i32)?;
    |             ^^^^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: value assigned to `best_delta_gpu` is never read
   --> src/quantum/src/gpu_k_opt.rs:108:13
    |
108 |             best_delta_gpu = stream.memcpy_stod(&[f32::INFINITY])?;
    |             ^^^^^^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: unused variable: `block_size`
   --> src/quantum/src/gpu_k_opt.rs:111:17
    |
111 |             let block_size = 16;
    |                 ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_block_size`

warning: unused variable: `cfg`
   --> src/quantum/src/gpu_k_opt.rs:112:17
    |
112 |             let cfg = LaunchConfig {
    |                 ^^^ help: if this is intentional, prefix it with an underscore: `_cfg`

warning: variable does not need to be mutable
  --> src/quantum/src/gpu_k_opt.rs:92:13
   |
92 |         let mut best_i_gpu = stream.alloc_zeros::<i32>(1)?;
   |             ----^^^^^^^^^^
   |             |
   |             help: remove this `mut`

warning: variable does not need to be mutable
  --> src/quantum/src/gpu_k_opt.rs:93:13
   |
93 |         let mut best_j_gpu = stream.alloc_zeros::<i32>(1)?;
   |             ----^^^^^^^^^^
   |             |
   |             help: remove this `mut`

warning: methods `generate_chromatic_coloring` and `optimize_tsp_ordering` are never used
   --> src/quantum/src/hamiltonian.rs:196:8
    |
137 | impl PhaseResonanceField {
    | ------------------------ methods in this implementation
...
196 |     fn generate_chromatic_coloring(&mut self, n_atoms: usize) {
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
220 |     fn optimize_tsp_ordering(&mut self, n_atoms: usize) {
    |        ^^^^^^^^^^^^^^^^^^^^^
    |
    = note: `#[warn(dead_code)]` on by default

warning: fields `masses`, `stencil_order`, and `energy_tolerance` are never read
   --> src/quantum/src/hamiltonian.rs:529:5
    |
522 | pub struct Hamiltonian {
    |            ----------- fields in this struct
...
529 |     masses: Array1<f64>,
    |     ^^^^^^
...
545 |     stencil_order: usize,   // Finite difference stencil order (9-point)
    |     ^^^^^^^^^^^^^
...
575 |     energy_tolerance: f64,
    |     ^^^^^^^^^^^^^^^^
    |
    = note: `Hamiltonian` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: methods `calculate_coupling_strength` and `pauli_dot_product` are never used
    --> src/quantum/src/hamiltonian.rs:1183:8
     |
 581 | impl Hamiltonian {
     | ---------------- methods in this implementation
...
1183 |     fn calculate_coupling_strength(&self, i: usize, j: usize, _t: f64) -> Complex64 {
     |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
1194 |     fn pauli_dot_product(&self, _i: usize, _j: usize) -> Complex64 {
     |        ^^^^^^^^^^^^^^^^^

warning: field `coupling` is never read
  --> src/quantum/src/prct_coloring.rs:33:5
   |
21 | pub struct ChromaticColoring {
   |            ----------------- field in this struct
...
33 |     coupling: Box<Array2<Complex64>>,
   |     ^^^^^^^^
   |
   = note: `ChromaticColoring` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `max_k` is never read
  --> src/quantum/src/gpu_k_opt.rs:14:5
   |
12 | pub struct GpuKOpt {
   |            ------- field in this struct
13 |     context: Arc<CudaContext>,
14 |     max_k: usize,
   |     ^^^^^

   Compiling platform-foundation v0.1.0 (/home/diddy/Desktop/PRISM-AI-DoD/03-Source-Code/src/foundation)
warning: `quantum-engine` (lib) generated 27 warnings (run `cargo fix --lib -p quantum-engine` to apply 12 suggestions)
warning: unused variable: `state`
   --> src/foundation/src/adp/decision_processor.rs:182:34
    |
182 |     fn generate_reasoning(&self, state: &State, action: Action, features: &[f64]) -> String {
    |                                  ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: field `quantum_hamiltonian` is never read
  --> src/foundation/src/platform.rs:33:5
   |
26 | pub struct NeuromorphicQuantumPlatform {
   |            --------------------------- field in this struct
...
33 |     quantum_hamiltonian: Arc<RwLock<Option<Hamiltonian>>>,
   |     ^^^^^^^^^^^^^^^^^^^
   |
   = note: `NeuromorphicQuantumPlatform` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` on by default

warning: field `state_to_reservoir` is never read
   --> src/foundation/src/platform.rs:101:5
    |
 95 | struct BidirectionalCoupling {
    |        --------------------- field in this struct
...
101 |     state_to_reservoir: f64,
    |     ^^^^^^^^^^^^^^^^^^
    |
    = note: `BidirectionalCoupling` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: methods `ensure_quantum_initialized`, `extract_quantum_features`, and `initialize_quantum_state` are never used
   --> src/foundation/src/platform.rs:758:14
    |
167 | impl NeuromorphicQuantumPlatform {
    | -------------------------------- methods in this implementation
...
758 |     async fn ensure_quantum_initialized(&self, input: &PlatformInput) -> Result<()> {
    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^
...
782 |     async fn extract_quantum_features(&self, _input: &PlatformInput, neuro_results: &NeuromorphicResults) -> Vec<f64> {
    |              ^^^^^^^^^^^^^^^^^^^^^^^^
...
822 |     async fn initialize_quantum_state(&self, hamiltonian: &mut Hamiltonian, features: &[f64]) -> Array1<Complex64> {
    |              ^^^^^^^^^^^^^^^^^^^^^^^^

warning: associated function `ingest_from_source` is never used
   --> src/foundation/src/ingestion/engine.rs:325:14
    |
 69 | impl IngestionEngine {
    | -------------------- associated function in this implementation
...
325 |     async fn ingest_from_source(
    |              ^^^^^^^^^^^^^^^^^^

   Compiling prism-ai v0.1.0 (/home/diddy/Desktop/PRISM-AI-DoD/03-Source-Code)
[CUBLAS Interposer] Loaded real CUBLAS: /usr/local/cuda-12.8/lib64/libcublas.so.12
warning: `platform-foundation` (lib) generated 5 warnings
warning: unused import: `rand_distr::Normal`
 --> src/information_theory/advanced_transfer_entropy.rs:9:5
  |
9 | use rand_distr::Normal;
  |     ^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `std::collections::HashMap`
  --> src/information_theory/conditional_te.rs:24:5
   |
24 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> src/information_theory/multivariate_te.rs:24:5
   |
24 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> src/information_theory/time_delayed_te.rs:26:5
   |
26 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Context`
  --> src/orchestration/llm_clients/claude_client.rs:10:22
   |
10 | use anyhow::{Result, Context, bail};
   |                      ^^^^^^^

warning: unused import: `sleep`
 --> src/orchestration/llm_clients/gemini_client.rs:7:19
  |
7 | use tokio::time::{sleep, timeout, Duration, Instant};
  |                   ^^^^^

warning: unused import: `Context`
  --> src/orchestration/llm_clients/grok_client.rs:10:22
   |
10 | use anyhow::{Result, Context, bail};
   |                      ^^^^^^^

warning: unused import: `Duration`
  --> src/orchestration/llm_clients/ensemble.rs:16:28
   |
16 | use tokio::time::{Instant, Duration};
   |                            ^^^^^^^^

warning: unused import: `anyhow::Result`
  --> src/orchestration/thermodynamic/hamiltonian.rs:13:5
   |
13 | use anyhow::Result;
   |     ^^^^^^^^^^^^^^

warning: unused imports: `Array1` and `Array2`
  --> src/orchestration/thermodynamic/advanced_energy.rs:20:15
   |
20 | use ndarray::{Array1, Array2};
   |               ^^^^^^  ^^^^^^

warning: unused import: `Context`
  --> src/orchestration/thermodynamic/temperature_schedules.rs:17:22
   |
17 | use anyhow::{Result, Context};
   |                      ^^^^^^^

warning: unused import: `Context`
  --> src/orchestration/thermodynamic/replica_exchange.rs:15:22
   |
15 | use anyhow::{Result, Context};
   |                      ^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> src/orchestration/thermodynamic/replica_exchange.rs:16:5
   |
16 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Instant`
  --> src/orchestration/active_inference/hierarchical_client.rs:16:29
   |
16 | use tokio::time::{Duration, Instant};
   |                             ^^^^^^^

warning: unused import: `ThreatDetection`
  --> src/orchestration/integration/pwsa_llm_bridge.rs:11:77
   |
11 | use crate::api_server::routes::pwsa::{PwsaFusionPlatform, MissionAwareness, ThreatDetection, OctTelemetry, IrSensorFrame, GroundStationDa...
   |                                                                             ^^^^^^^^^^^^^^^

warning: unused import: `DMatrix`
  --> src/orchestration/integration/mission_charlie_integration.rs:20:25
   |
20 | use nalgebra::{DVector, DMatrix};
   |                         ^^^^^^^

warning: unused import: `parking_lot::RwLock`
  --> src/orchestration/integration/mission_charlie_integration.rs:23:5
   |
23 | use parking_lot::RwLock;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `nalgebra as na`
  --> src/orchestration/integration/prism_ai_integration.rs:14:5
   |
14 | use nalgebra as na;
   |     ^^^^^^^^^^^^^^

warning: unused import: `Array2`
  --> src/orchestration/integration/prism_ai_integration.rs:15:15
   |
15 | use ndarray::{Array2, Array1};
   |               ^^^^^^

warning: unused import: `std::time::SystemTime`
  --> src/orchestration/integration/prism_ai_integration.rs:17:5
   |
17 | use std::time::SystemTime;
   |     ^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `ActiveInferenceController`, `CausalDirection`, `CouplingStrength`, `EvolutionResult`, `ExecutionConfig`, `GenerativeModel`, `InformationChannel`, `PhaseSynchronizer`, `PolicySelector`, `SystemState`, `TransferEntropyResult`, `TransferEntropy`, `compile_and_execute`, and `detect_causal_direction`
  --> src/orchestration/integration/prism_ai_integration.rs:23:9
   |
23 |         GenerativeModel, HierarchicalModel, VariationalInference,
   |         ^^^^^^^^^^^^^^^
24 |         PolicySelector, ActiveInferenceController, FreeEnergyComponents,
   |         ^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^
...
29 |         ThermodynamicMetrics, EvolutionResult,
   |                               ^^^^^^^^^^^^^^^
...
33 |         TransferEntropy, TransferEntropyResult, CausalDirection,
   |         ^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^
34 |         detect_causal_direction,
   |         ^^^^^^^^^^^^^^^^^^^^^^^
...
38 |         CrossDomainBridge, DomainState, CouplingStrength,
   |                                         ^^^^^^^^^^^^^^^^
39 |         InformationChannel, PhaseSynchronizer, UnifiedPlatform,
   |         ^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^
...
44 |         HealthMonitor, ComponentHealth, HealthStatus, SystemState, SystemHealthState,
   |                                                       ^^^^^^^^^^^
...
50 |         compile_and_execute, ExecutionConfig,
   |         ^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^

warning: unused imports: `LLMResponse` and `OrchestrationError`
  --> src/orchestration/integration/prism_ai_integration.rs:77:32
   |
77 |     MissionCharlieIntegration, OrchestrationError, LLMResponse,
   |                                ^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^

warning: unused import: `anyhow::Result`
  --> src/orchestration/optimization/mdl_prompt_optimizer.rs:13:5
   |
13 | use anyhow::Result;
   |     ^^^^^^^^^^^^^^

warning: unused import: `std::io::Write`
  --> src/orchestration/optimization/mdl_prompt_optimizer.rs:51:13
   |
51 |         use std::io::Write;
   |             ^^^^^^^^^^^^^^

warning: unused import: `SymmetricEigen`
 --> src/orchestration/optimization/geometric_manifold.rs:8:39
  |
8 | use nalgebra::{DMatrix, DVector, SVD, SymmetricEigen};
  |                                       ^^^^^^^^^^^^^^

warning: unused import: `anyhow::Result`
  --> src/orchestration/caching/quantum_semantic_cache.rs:16:5
   |
16 | use anyhow::Result;
   |     ^^^^^^^^^^^^^^

warning: unused import: `Array1`
  --> src/orchestration/routing/te_embedding_gpu.rs:12:15
   |
12 | use ndarray::{Array1, Array2};
   |               ^^^^^^

warning: unused import: `Context as AnyhowContext`
  --> src/orchestration/routing/ksg_transfer_entropy_gpu.rs:17:22
   |
17 | use anyhow::{Result, Context as AnyhowContext};
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Array1`
  --> src/orchestration/routing/ksg_transfer_entropy_gpu.rs:18:15
   |
18 | use ndarray::{Array1, Array2, Axis};
   |               ^^^^^^

warning: unused import: `ndarray::Array1`
 --> src/orchestration/routing/te_validation.rs:7:5
  |
7 | use ndarray::Array1;
  |     ^^^^^^^^^^^^^^^

warning: unused import: `anyhow::Result`
  --> src/orchestration/validation/info_theoretic_validator.rs:12:5
   |
12 | use anyhow::Result;
   |     ^^^^^^^^^^^^^^

warning: unused imports: `Array1` and `Array2`
  --> src/orchestration/semantic_analysis/distance_metrics.rs:14:15
   |
14 | use ndarray::{Array1, Array2};
   |               ^^^^^^  ^^^^^^

warning: unused import: `Normal`
  --> src/orchestration/neuromorphic/unified_neuromorphic.rs:10:41
   |
10 | use rand_distr::{Distribution, Poisson, Normal};  // Fixed: rand_distr not rand
   |                                         ^^^^^^

warning: unused import: `ordered_float::OrderedFloat`
  --> src/orchestration/neuromorphic/unified_neuromorphic.rs:11:5
   |
11 | use ordered_float::OrderedFloat;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::gpu::GpuKernelExecutor`
 --> src/orchestration/neuromorphic/gpu_neuromorphic.rs:7:5
  |
7 | use crate::gpu::GpuKernelExecutor;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::gpu::neuromorphic_ffi::*`
 --> src/orchestration/neuromorphic/gpu_neuromorphic.rs:8:5
  |
8 | use crate::gpu::neuromorphic_ffi::*;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `CudaSlice`
 --> src/orchestration/neuromorphic/gpu_neuromorphic.rs:9:35
  |
9 | use cudarc::driver::{CudaContext, CudaSlice};
  |                                   ^^^^^^^^^

warning: unused imports: `DMatrix` and `DVector`
  --> src/orchestration/neuromorphic/gpu_neuromorphic.rs:10:16
   |
10 | use nalgebra::{DMatrix, DVector};
   |                ^^^^^^^  ^^^^^^^

warning: unused import: `std::sync::Arc`
  --> src/orchestration/local_llm/gpu_llm_inference.rs:15:5
   |
15 | use std::sync::Arc;
   |     ^^^^^^^^^^^^^^

warning: unused import: `cudarc::driver::CudaContext`
  --> src/orchestration/local_llm/gpu_llm_inference.rs:16:5
   |
16 | use cudarc::driver::CudaContext;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `GpuTransformerLayer`
  --> src/orchestration/local_llm/gpu_llm_inference.rs:18:30
   |
18 | use super::gpu_transformer::{GpuTransformerLayer, GpuLLMInference};
   |                              ^^^^^^^^^^^^^^^^^^^

warning: variant `Q2_K` should have an upper camel case name
  --> src/orchestration/local_llm/gguf_loader.rs:45:5
   |
45 |     Q2_K = 10,
   |     ^^^^ help: convert the identifier to upper camel case: `Q2K`
   |
   = note: `#[warn(non_camel_case_types)]` on by default

warning: variant `Q3_K` should have an upper camel case name
  --> src/orchestration/local_llm/gguf_loader.rs:46:5
   |
46 |     Q3_K = 11,
   |     ^^^^ help: convert the identifier to upper camel case: `Q3K`

warning: variant `Q4_K` should have an upper camel case name
  --> src/orchestration/local_llm/gguf_loader.rs:47:5
   |
47 |     Q4_K = 12,
   |     ^^^^ help: convert the identifier to upper camel case: `Q4K`

warning: variant `Q5_K` should have an upper camel case name
  --> src/orchestration/local_llm/gguf_loader.rs:48:5
   |
48 |     Q5_K = 13,
   |     ^^^^ help: convert the identifier to upper camel case: `Q5K`

warning: variant `Q6_K` should have an upper camel case name
  --> src/orchestration/local_llm/gguf_loader.rs:49:5
   |
49 |     Q6_K = 14,
   |     ^^^^ help: convert the identifier to upper camel case: `Q6K`

warning: variant `Q8_K` should have an upper camel case name
  --> src/orchestration/local_llm/gguf_loader.rs:50:5
   |
50 |     Q8_K = 15,
   |     ^^^^ help: convert the identifier to upper camel case: `Q8K`

warning: unused import: `anyhow::Result`
  --> src/orchestration/local_llm/attention_analyzer.rs:23:5
   |
23 | use anyhow::Result;
   |     ^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> src/orchestration/local_llm/transfer_entropy_llm.rs:31:5
   |
31 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `BTreeMap`
 --> src/orchestration/decomposition/pid_synergy.rs:9:42
  |
9 | use std::collections::{HashMap, HashSet, BTreeMap, BTreeSet};
  |                                          ^^^^^^^^

warning: unused import: `VecDeque`
 --> src/orchestration/inference/hierarchical_active_inference.rs:9:33
  |
9 | use std::collections::{HashMap, VecDeque};
  |                                 ^^^^^^^^

warning: unused import: `rand_distr::Normal`
  --> src/orchestration/inference/hierarchical_active_inference.rs:11:5
   |
11 | use rand_distr::Normal;
   |     ^^^^^^^^^^^^^^^^^^

warning: unused import: `SVD`
 --> src/orchestration/causality/bidirectional_causality.rs:8:34
  |
8 | use nalgebra::{DMatrix, DVector, SVD};
  |                                  ^^^

warning: unused import: `VecDeque`
 --> src/orchestration/causality/bidirectional_causality.rs:9:42
  |
9 | use std::collections::{HashMap, HashSet, VecDeque};
  |                                          ^^^^^^^^

warning: unused import: `rand_distr::Normal`
  --> src/orchestration/causality/bidirectional_causality.rs:12:5
   |
12 | use rand_distr::Normal;
   |     ^^^^^^^^^^^^^^^^^^

warning: unused import: `Complex`
 --> src/orchestration/quantum/quantum_entanglement_measures.rs:8:34
  |
8 | use nalgebra::{DMatrix, DVector, Complex, SymmetricEigen};
  |                                  ^^^^^^^

warning: unused import: `VecDeque`
  --> src/orchestration/quantum/quantum_entanglement_measures.rs:10:33
   |
10 | use std::collections::{HashMap, VecDeque};
   |                                 ^^^^^^^^

warning: unused import: `Context as AnyhowContext`
 --> src/gpu/gpu_enabled.rs:5:22
  |
5 | use anyhow::{Result, Context as AnyhowContext};
  |                      ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Arc`
 --> src/gpu/cublas_compat.rs:8:17
  |
8 | use std::sync::{Arc, OnceLock};
  |                 ^^^

warning: unused import: `Context`
 --> src/gpu/production_runtime.rs:9:22
  |
9 | use anyhow::{Result, Context};
  |                      ^^^^^^^

warning: unused import: `std::ffi::c_void`
   --> src/gpu/cudarc_replacement.rs:116:17
    |
116 |             use std::ffi::c_void;
    |                 ^^^^^^^^^^^^^^^^

warning: unused import: `cudarc::driver::sys`
   --> src/cma/gpu_integration.rs:159:21
    |
159 |                 use cudarc::driver::sys;
    |                     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::sync::Arc`
  --> src/assistant/local_llm/gpu_llm_inference.rs:15:5
   |
15 | use std::sync::Arc;
   |     ^^^^^^^^^^^^^^

warning: unused import: `cudarc::driver::CudaContext`
  --> src/assistant/local_llm/gpu_llm_inference.rs:16:5
   |
16 | use cudarc::driver::CudaContext;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `GpuTransformerLayer`
  --> src/assistant/local_llm/gpu_llm_inference.rs:18:56
   |
18 | use crate::orchestration::local_llm::gpu_transformer::{GpuTransformerLayer, GpuLLMInference};
   |                                                        ^^^^^^^^^^^^^^^^^^^

warning: variant `Q2_K` should have an upper camel case name
  --> src/assistant/local_llm/gguf_loader.rs:45:5
   |
45 |     Q2_K = 10,
   |     ^^^^ help: convert the identifier to upper camel case: `Q2K`

warning: variant `Q3_K` should have an upper camel case name
  --> src/assistant/local_llm/gguf_loader.rs:46:5
   |
46 |     Q3_K = 11,
   |     ^^^^ help: convert the identifier to upper camel case: `Q3K`

warning: variant `Q4_K` should have an upper camel case name
  --> src/assistant/local_llm/gguf_loader.rs:47:5
   |
47 |     Q4_K = 12,
   |     ^^^^ help: convert the identifier to upper camel case: `Q4K`

warning: variant `Q5_K` should have an upper camel case name
  --> src/assistant/local_llm/gguf_loader.rs:48:5
   |
48 |     Q5_K = 13,
   |     ^^^^ help: convert the identifier to upper camel case: `Q5K`

warning: variant `Q6_K` should have an upper camel case name
  --> src/assistant/local_llm/gguf_loader.rs:49:5
   |
49 |     Q6_K = 14,
   |     ^^^^ help: convert the identifier to upper camel case: `Q6K`

warning: variant `Q8_K` should have an upper camel case name
  --> src/assistant/local_llm/gguf_loader.rs:50:5
   |
50 |     Q8_K = 15,
   |     ^^^^ help: convert the identifier to upper camel case: `Q8K`

warning: unused variable: `input`
  --> src/api_server/graphql_schema.rs:55:9
   |
55 |         input: PortfolioOptimizationInput,
   |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_input`
   |
   = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `input`
  --> src/api_server/graphql_schema.rs:82:9
   |
82 |         input: MotionPlanInput,
   |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_input`

warning: unused variable: `input`
   --> src/api_server/graphql_schema.rs:127:9
    |
127 |         input: HealthcareRiskInput,
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_input`

warning: unused variable: `input`
   --> src/api_server/graphql_schema.rs:140:9
    |
140 |         input: EnergyForecastInput,
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_input`

warning: unused variable: `input`
   --> src/api_server/graphql_schema.rs:198:9
    |
198 |         input: PortfolioOptimizationInput,
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_input`

warning: unused variable: `input`
   --> src/api_server/graphql_schema.rs:216:9
    |
216 |         input: MotionPlanInput,
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_input`

warning: variable does not need to be mutable
   --> src/orchestration/llm_clients/openai_client.rs:126:13
    |
126 |         let mut last = self.last_request.lock().await;
    |             ----^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` on by default

warning: unused variable: `start`
   --> src/orchestration/llm_clients/ensemble.rs:129:13
    |
129 |         let start = Instant::now();
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_start`

warning: unused variable: `manifold_result`
   --> src/orchestration/integration/mission_charlie_integration.rs:260:13
    |
260 |         let manifold_result = self.manifold_optimizer.optimize_llm_responses(
    |             ^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_manifold_result`

warning: unused variable: `context`
   --> src/orchestration/integration/prism_ai_integration.rs:249:45
    |
249 |         let sensor_assessment = if let Some(context) = sensor_context {
    |                                             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_context`

warning: unused variable: `state`
   --> src/orchestration/integration/prism_ai_integration.rs:291:17
    |
291 |             let state = self.response_to_state(&charlie_response);
    |                 ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `bridged_result`
   --> src/orchestration/integration/prism_ai_integration.rs:296:13
    |
296 |         let bridged_result = {
    |             ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_bridged_result`

warning: variable does not need to be mutable
   --> src/orchestration/integration/prism_ai_integration.rs:327:17
    |
327 |             let mut health = self.health_monitor.write();
    |                 ----^^^^^^
    |                 |
    |                 help: remove this `mut`

warning: unused variable: `hamiltonian`
   --> src/phase6/integration.rs:240:9
    |
240 |         hamiltonian: &ModulatedHamiltonian,
    |         ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_hamiltonian`

warning: unused variable: `n`
   --> src/phase6/integration.rs:242:13
    |
242 |         let n = adjacency.nrows();
    |             ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: unused variable: `initial_state`
   --> src/phase6/integration.rs:267:9
    |
267 |         initial_state: &Array1<f64>,
    |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_initial_state`

warning: unused variable: `avg_temp`
   --> src/phase6/integration.rs:271:13
    |
271 |         let avg_temp = hamiltonian.local_temperature.mean().unwrap_or(1.0);
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_avg_temp`

warning: unused variable: `state`
  --> src/api_server/routes/pwsa.rs:95:11
   |
95 |     State(state): State<Arc<AppState>>,
   |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/pwsa.rs:140:11
    |
140 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/pwsa.rs:159:11
    |
159 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/pwsa.rs:179:11
    |
179 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/finance.rs:103:11
    |
103 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/finance.rs:195:11
    |
195 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/finance.rs:215:11
    |
215 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/finance.rs:233:11
    |
233 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/finance.rs:299:11
    |
299 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `request`
   --> src/api_server/routes/finance.rs:300:10
    |
300 |     Json(request): Json<BacktestRequest>,
    |          ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_request`

warning: unused variable: `req`
   --> src/api_server/routes/finance_advanced.rs:258:10
    |
258 |     Json(req): Json<GnnPortfolioPredictionRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/finance_advanced.rs:293:10
    |
293 |     Json(req): Json<TransferEntropyCausalityRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/finance_advanced.rs:321:10
    |
321 |     Json(req): Json<PortfolioRebalancingRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `state`
   --> src/api_server/routes/telecom.rs:101:11
    |
101 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/telecom.rs:122:11
    |
122 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/telecom.rs:142:11
    |
142 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/telecom.rs:157:11
    |
157 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
  --> src/api_server/routes/robotics.rs:83:11
   |
83 |     State(state): State<Arc<AppState>>,
   |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/robotics.rs:168:11
    |
168 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/robotics.rs:185:11
    |
185 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/robotics.rs:208:11
    |
208 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
  --> src/api_server/routes/llm.rs:85:11
   |
85 |     State(state): State<Arc<AppState>>,
   |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/llm.rs:105:11
    |
105 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/llm.rs:125:11
    |
125 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/llm.rs:161:11
    |
161 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/llm.rs:180:11
    |
180 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/time_series.rs:122:11
    |
122 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/time_series.rs:241:11
    |
241 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/time_series.rs:263:11
    |
263 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/time_series.rs:287:11
    |
287 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/time_series.rs:306:11
    |
306 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/pixels.rs:144:11
    |
144 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/pixels.rs:201:11
    |
201 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/pixels.rs:221:11
    |
221 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/pixels.rs:240:11
    |
240 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/pixels.rs:258:11
    |
258 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:296:10
    |
296 |     Json(req): Json<HealthcareRiskRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:329:10
    |
329 |     Json(req): Json<EnergyForecastRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:346:10
    |
346 |     Json(req): Json<ManufacturingMaintenanceRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:362:10
    |
362 |     Json(req): Json<SupplyChainDemandRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:377:10
    |
377 |     Json(req): Json<AgricultureYieldRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:394:10
    |
394 |     Json(req): Json<CybersecurityThreatRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:414:10
    |
414 |     Json(req): Json<ClimateForecastRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:427:10
    |
427 |     Json(req): Json<SmartCityOptimizationRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:443:10
    |
443 |     Json(req): Json<EducationPerformanceRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:468:10
    |
468 |     Json(req): Json<RetailInventoryRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:481:10
    |
481 |     Json(req): Json<ConstructionForecastRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `state`
  --> src/api_server/websocket.rs:76:43
   |
76 | async fn handle_socket(socket: WebSocket, state: Arc<AppState>) {
   |                                           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused import: `Context`
  --> src/statistical_mechanics/gpu.rs:15:30
   |
15 | use anyhow::{Result, anyhow, Context};
   |                              ^^^^^^^

warning: unused import: `Context`
  --> src/active_inference/gpu.rs:16:30
   |
16 | use anyhow::{Result, anyhow, Context};
   |                              ^^^^^^^

warning: unused import: `Read`
  --> src/resilience/checkpoint_manager.rs:38:15
   |
38 | use std::io::{Read, Write};
   |               ^^^^

warning: unused import: `Distribution`
  --> src/orchestration/neuromorphic/unified_neuromorphic.rs:10:18
   |
10 | use rand_distr::{Distribution, Poisson, Normal};  // Fixed: rand_distr not rand
   |                  ^^^^^^^^^^^^

warning: unused import: `rand::distributions::Distribution`
  --> src/orchestration/inference/hierarchical_active_inference.rs:10:5
   |
10 | use rand::distributions::Distribution;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rand::distributions::Distribution`
  --> src/orchestration/causality/bidirectional_causality.rs:11:5
   |
11 | use rand::distributions::Distribution;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Context`
 --> src/quantum_mlir/runtime.rs:6:22
  |
6 | use anyhow::{Result, Context};
  |                      ^^^^^^^

warning: unused import: `sha2::Digest`
  --> src/cma/guarantees/mod.rs:16:5
   |
16 | use sha2::Digest;
   |     ^^^^^^^^^^^^

warning: unused import: `gpu_integration::GpuSolvable`
   --> src/cma/mod.rs:127:13
    |
127 |         use gpu_integration::GpuSolvable;
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused variable: `psi_n`
   --> src/information_theory/transfer_entropy.rs:391:13
    |
391 |         let psi_n = digamma(n as f64);
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_psi_n`

warning: value assigned to `count_greater` is never read
   --> src/information_theory/transfer_entropy.rs:487:17
    |
487 |         let mut count_greater = 0;
    |                 ^^^^^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?
    = note: `#[warn(unused_assignments)]` on by default

warning: unused variable: `rng`
   --> src/information_theory/transfer_entropy.rs:491:17
    |
491 |             let rng = rand::thread_rng();
    |                 ^^^ help: if this is intentional, prefix it with an underscore: `_rng`

warning: unused variable: `lag_xy`
   --> src/information_theory/transfer_entropy.rs:672:10
    |
672 |     let (lag_xy, result_xy) = te_calc.find_optimal_lag(x, y, max_lag);
    |          ^^^^^^ help: if this is intentional, prefix it with an underscore: `_lag_xy`

warning: unused variable: `lag_yx`
   --> src/information_theory/transfer_entropy.rs:675:10
    |
675 |     let (lag_yx, result_yx) = te_calc.find_optimal_lag(y, x, max_lag);
    |          ^^^^^^ help: if this is intentional, prefix it with an underscore: `_lag_yx`

warning: unused variable: `source_i`
   --> src/information_theory/advanced_transfer_entropy.rs:614:38
    |
614 |     pub fn unique_information(&self, source_i: &Array1<f64>,
    |                                      ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_source_i`

warning: unused variable: `other_sources`
   --> src/information_theory/advanced_transfer_entropy.rs:615:30
    |
615 | ...                   other_sources: &[Array1<f64>],
    |                       ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_other_sources`

warning: unused variable: `target`
   --> src/information_theory/advanced_transfer_entropy.rs:616:30
    |
616 | ...                   target: &Array1<f64>) -> f64 {
    |                       ^^^^^^ help: if this is intentional, prefix it with an underscore: `_target`

warning: unused variable: `sources`
   --> src/information_theory/advanced_transfer_entropy.rs:640:43
    |
640 |     pub fn synergistic_information(&self, sources: &[Array1<f64>],
    |                                           ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_sources`

warning: unused variable: `target`
   --> src/information_theory/advanced_transfer_entropy.rs:641:35
    |
641 | ...                   target: &Array1<f64>) -> f64 {
    |                       ^^^^^^ help: if this is intentional, prefix it with an underscore: `_target`

warning: unused variable: `n`
  --> src/information_theory/ksg_estimator.rs:66:13
   |
66 |         let n = source.len();
   |             ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: unused variable: `tree_dim_plus`
   --> src/information_theory/ksg_estimator.rs:349:13
    |
349 |         let tree_dim_plus = KdTree::new(&points_dim_plus);
    |             ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_tree_dim_plus`

warning: unused variable: `dist_cond`
   --> src/information_theory/conditional_te.rs:250:17
    |
250 |             let dist_cond = self.find_kth_neighbor_distance_cond(emb, i)?;
    |                 ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_dist_cond`

warning: unused variable: `x_embed`
   --> src/information_theory/transfer_entropy_gpu.rs:161:26
    |
161 |     fn gpu_ksg_te(&self, x_embed: &[Vec<f64>], y_embed: &[Vec<f64>], y_future: &[f64]) -> Result<f64> {
    |                          ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_x_embed`

warning: unused variable: `y_embed`
   --> src/information_theory/transfer_entropy_gpu.rs:161:48
    |
161 |     fn gpu_ksg_te(&self, x_embed: &[Vec<f64>], y_embed: &[Vec<f64>], y_future: &[f64]) -> Result<f64> {
    |                                                ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_y_embed`

warning: unused variable: `y_future`
   --> src/information_theory/transfer_entropy_gpu.rs:161:70
    |
161 |     fn gpu_ksg_te(&self, x_embed: &[Vec<f64>], y_embed: &[Vec<f64>], y_future: &[f64]) -> Result<f64> {
    |                                                                      ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_y_future`

warning: unused variable: `source`
   --> src/information_theory/transfer_entropy_gpu.rs:168:36
    |
168 |     fn gpu_permutation_test(&self, source: &Array1<f64>, target: &Array1<f64>, observed_te: f64) -> Result<f64> {
    |                                    ^^^^^^ help: if this is intentional, prefix it with an underscore: `_source`

warning: unused variable: `target`
   --> src/information_theory/transfer_entropy_gpu.rs:168:58
    |
168 |     fn gpu_permutation_test(&self, source: &Array1<f64>, target: &Array1<f64>, observed_te: f64) -> Result<f64> {
    |                                                          ^^^^^^ help: if this is intentional, prefix it with an underscore: `_target`

warning: unused variable: `observed_te`
   --> src/information_theory/transfer_entropy_gpu.rs:168:80
    |
168 |     fn gpu_permutation_test(&self, source: &Array1<f64>, target: &Array1<f64>, observed_te: f64) -> Result<f64> {
    |                                                                                ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_observed_te`

warning: unused variable: `source`
   --> src/information_theory/transfer_entropy_gpu.rs:174:36
    |
174 |     fn gpu_ksg_significance(&self, source: &Array1<f64>, target: &Array1<f64>, observed_te: f64) -> Result<f64> {
    |                                    ^^^^^^ help: if this is intentional, prefix it with an underscore: `_source`

warning: unused variable: `target`
   --> src/information_theory/transfer_entropy_gpu.rs:174:58
    |
174 |     fn gpu_ksg_significance(&self, source: &Array1<f64>, target: &Array1<f64>, observed_te: f64) -> Result<f64> {
    |                                                          ^^^^^^ help: if this is intentional, prefix it with an underscore: `_target`

warning: unused variable: `observed_te`
   --> src/information_theory/transfer_entropy_gpu.rs:174:80
    |
174 |     fn gpu_ksg_significance(&self, source: &Array1<f64>, target: &Array1<f64>, observed_te: f64) -> Result<f64> {
    |                                                                                ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_observed_te`

warning: unused variable: `mi_y_x1`
   --> src/information_theory/pid.rs:227:13
    |
227 |         let mi_y_x1 = self.mutual_information(y, x1)?;
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_mi_y_x1`

warning: unused variable: `mi_y_x2`
   --> src/information_theory/pid.rs:228:13
    |
228 |         let mi_y_x2 = self.mutual_information(y, x2)?;
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_mi_y_x2`

warning: unused variable: `mi_y_x1x2`
   --> src/information_theory/pid.rs:229:13
    |
229 |         let mi_y_x1x2 = self.mutual_information_joint(y, x1, x2)?;
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_mi_y_x1x2`

warning: unused variable: `dtheta`
   --> src/statistical_mechanics/thermodynamic_network.rs:273:13
    |
273 |         let dtheta = 2.0 * PI / 10.0; // 10 bins in phase
    |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_dtheta`

warning: unused variable: `dv`
   --> src/statistical_mechanics/thermodynamic_network.rs:274:13
    |
274 |         let dv = (KB * temperature).sqrt() / 5.0; // 5 bins in velocity
    |             ^^ help: if this is intentional, prefix it with an underscore: `_dv`

warning: unused variable: `natural_frequencies`
   --> src/statistical_mechanics/thermodynamic_network.rs:296:9
    |
296 |         natural_frequencies: &[f64],
    |         ^^^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_natural_frequencies`

warning: unused variable: `initial_entropy`
   --> src/statistical_mechanics/thermodynamic_network.rs:416:13
    |
416 |         let initial_entropy = self.state.entropy;
    |             ^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_initial_entropy`

warning: unused variable: `order_r`
   --> src/statistical_mechanics/gpu.rs:266:13
    |
266 |         let order_r = (order_real_vec[0]*order_real_vec[0] + order_imag_vec[0]*order_imag_vec[0]).sqrt() / (n as f64);
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_order_r`

warning: unused variable: `horizon`
   --> src/active_inference/hierarchical_model.rs:434:31
    |
434 |     pub fn predict(&mut self, horizon: f64) {
    |                               ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_horizon`

warning: unused variable: `weighted_dynamical`
   --> src/active_inference/variational_inference.rs:225:13
    |
225 |         let weighted_dynamical = &dynamical_error * &model.level1.belief.precision;
    |             ^^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_weighted_dynamical`

warning: unused variable: `action`
  --> src/active_inference/controller.rs:43:17
   |
43 |             let action = self.controller.control(&test_model);
   |                 ^^^^^^ help: if this is intentional, prefix it with an underscore: `_action`

warning: unused variable: `obs`
  --> src/active_inference/controller.rs:46:17
   |
46 |             let obs = Array1::<f64>::ones(100);  // Simplified
   |                 ^^^ help: if this is intentional, prefix it with an underscore: `_obs`

warning: unused variable: `num_steps`
  --> src/active_inference/controller.rs:66:9
   |
66 |         num_steps: usize,
   |         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_num_steps`

warning: unused variable: `jacobian_f32`
   --> src/active_inference/gpu_inference.rs:172:13
    |
172 |         let jacobian_f32: Vec<f32> = jacobian.as_slice().unwrap()
    |             ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_jacobian_f32`

warning: unused variable: `error_f32`
   --> src/active_inference/gpu_inference.rs:174:13
    |
174 |         let error_f32: Vec<f32> = error.as_slice().unwrap()
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_error_f32`

warning: unused variable: `diffusion`
   --> src/active_inference/gpu_inference.rs:261:13
    |
261 |         let diffusion = level.diffusion;
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_diffusion`

warning: unused variable: `predicted`
   --> src/active_inference/gpu_inference.rs:326:17
    |
326 |             let predicted = self.predict_observations_gpu(
    |                 ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_predicted`

warning: unused variable: `model`
   --> src/active_inference/gpu_policy_eval.rs:684:42
    |
684 |     fn compute_efe_components(&mut self, model: &HierarchicalModel) -> Result<()> {
    |                                          ^^^^^ help: if this is intentional, prefix it with an underscore: `_model`

warning: unused variable: `t`
   --> src/active_inference/policy_search_gpu.rs:380:18
    |
380 |             for (t, base_action) in base_policy.actions.iter().enumerate() {
    |                  ^ help: if this is intentional, prefix it with an underscore: `_t`

warning: unused variable: `j`
  --> src/integration/information_channel.rs:60:22
   |
60 |                 for (j, &p_y_given_x) in self.transition_matrix.column(i).iter().enumerate() {
   |                      ^ help: if this is intentional, prefix it with an underscore: `_j`

warning: unused variable: `performance`
   --> src/integration/unified_platform.rs:101:13
    |
101 |         let performance = self.total_latency_ms < 500.0;
    |             ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_performance`

warning: unused variable: `exec`
   --> src/integration/multi_modal_reasoner.rs:216:13
    |
216 |         let exec = self.executor.lock().unwrap();
    |             ^^^^ help: if this is intentional, prefix it with an underscore: `_exec`

warning: unused variable: `conf_gpu`
   --> src/integration/multi_modal_reasoner.rs:220:13
    |
220 |         let conf_gpu = stream.memcpy_stod(&confidences)?;
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_conf_gpu`

warning: unused variable: `n`
  --> src/orchestration/llm_clients/ensemble.rs:68:13
   |
68 |         let n = llm_clients.len();
   |             ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: unused variable: `n`
   --> src/orchestration/thermodynamic/advanced_energy.rs:188:13
    |
188 |         let n = self.models.len();
    |             ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: unused variable: `kernel`
   --> src/orchestration/thermodynamic/advanced_energy.rs:244:13
    |
244 |         let kernel = executor_lock.get_kernel("weighted_energy_sum")?;
    |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_kernel`

warning: unused variable: `costs_dev`
   --> src/orchestration/thermodynamic/advanced_energy.rs:249:13
    |
249 |         let costs_dev = stream.memcpy_stod(costs)?;
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_costs_dev`

warning: unused variable: `qualities_dev`
   --> src/orchestration/thermodynamic/advanced_energy.rs:250:13
    |
250 |         let qualities_dev = stream.memcpy_stod(qualities)?;
    |             ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_qualities_dev`

warning: unused variable: `latencies_dev`
   --> src/orchestration/thermodynamic/advanced_energy.rs:251:13
    |
251 |         let latencies_dev = stream.memcpy_stod(latencies)?;
    |             ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_latencies_dev`

warning: unused variable: `uncertainties_dev`
   --> src/orchestration/thermodynamic/advanced_energy.rs:252:13
    |
252 |         let uncertainties_dev = stream.memcpy_stod(uncertainties)?;
    |             ^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_uncertainties_dev`

warning: unused variable: `cfg`
   --> src/orchestration/thermodynamic/advanced_energy.rs:265:13
    |
265 |         let cfg = cudarc::driver::LaunchConfig {
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_cfg`

warning: unused variable: `energies_f32`
   --> src/orchestration/thermodynamic/advanced_energy.rs:279:13
    |
279 |         let energies_f32: Vec<f32> = costs.iter().zip(qualities.iter()).zip(latencies.iter()).zip(uncertainties.iter())
    |             ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_energies_f32`

warning: unnecessary `unsafe` block
   --> src/orchestration/thermodynamic/advanced_energy.rs:271:9
    |
271 |         unsafe {
    |         ^^^^^^ unnecessary `unsafe` block
    |
    = note: `#[warn(unused_unsafe)]` on by default

warning: variable does not need to be mutable
   --> src/orchestration/thermodynamic/advanced_energy.rs:253:13
    |
253 |         let mut energies_dev = stream.alloc_zeros::<f32>(n)?;
    |             ----^^^^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `n_accepted`
   --> src/orchestration/thermodynamic/replica_exchange.rs:145:13
    |
145 |         let n_accepted = self.exchange_manager.exchange_round();
    |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_n_accepted`

warning: unused variable: `g`
   --> src/orchestration/optimization/geometric_manifold.rs:960:13
    |
960 |         let g = (self.manifold.metric.g)(x);
    |             ^ help: if this is intentional, prefix it with an underscore: `_g`

warning: unused variable: `tangent`
    --> src/orchestration/optimization/geometric_manifold.rs:1365:17
     |
1365 |             let tangent = &geodesic.tangents[i];
     |                 ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_tangent`

warning: unused variable: `g0_inv`
    --> src/orchestration/optimization/geometric_manifold.rs:1371:26
     |
1371 |             if let (Some(g0_inv), Some(g1_inv)) = (g0.clone().try_inverse(), g1.try_inverse()) {
     |                          ^^^^^^ help: if this is intentional, prefix it with an underscore: `_g0_inv`

warning: unused variable: `manifold_dimension`
    --> src/orchestration/optimization/geometric_manifold.rs:1396:13
     |
1396 |         let manifold_dimension = self.manifold.dimension;
     |             ^^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_manifold_dimension`

warning: unused variable: `kernel`
  --> src/orchestration/routing/te_embedding_gpu.rs:93:13
   |
93 |         let kernel = executor_lock.get_kernel("time_delayed_embedding")?;
   |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_kernel`

warning: unused variable: `ts_dev`
  --> src/orchestration/routing/te_embedding_gpu.rs:97:13
   |
97 |         let ts_dev = stream.memcpy_stod(&time_series_f32)?;
   |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_ts_dev`

warning: value assigned to `embedded_dev` is never read
  --> src/orchestration/routing/te_embedding_gpu.rs:98:17
   |
98 |         let mut embedded_dev = stream.alloc_zeros::<f32>(n_embedded * embedding_dim)?;
   |                 ^^^^^^^^^^^^
   |
   = help: maybe it is overwritten before being read?

warning: unused variable: `cfg`
   --> src/orchestration/routing/te_embedding_gpu.rs:104:13
    |
104 |         let cfg = LaunchConfig {
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_cfg`

warning: unnecessary `unsafe` block
   --> src/orchestration/routing/te_embedding_gpu.rs:110:9
    |
110 |         unsafe {
    |         ^^^^^^ unnecessary `unsafe` block

warning: unused variable: `kernel`
   --> src/orchestration/routing/gpu_kdtree.rs:170:13
    |
170 |         let kernel = executor_lock.get_kernel("compute_distances")?;
    |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_kernel`

warning: unused variable: `dataset_dev`
   --> src/orchestration/routing/gpu_kdtree.rs:174:13
    |
174 |         let dataset_dev = stream.memcpy_stod(&dataset_f32)?;
    |             ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_dataset_dev`

warning: unused variable: `query_dev`
   --> src/orchestration/routing/gpu_kdtree.rs:175:13
    |
175 |         let query_dev = stream.memcpy_stod(&query_f32)?;
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_query_dev`

warning: value assigned to `distances_dev` is never read
   --> src/orchestration/routing/gpu_kdtree.rs:176:17
    |
176 |         let mut distances_dev = stream.alloc_zeros::<f32>(n_points)?;
    |                 ^^^^^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: unused variable: `cfg`
   --> src/orchestration/routing/gpu_kdtree.rs:182:13
    |
182 |         let cfg = LaunchConfig {
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_cfg`

warning: unnecessary `unsafe` block
   --> src/orchestration/routing/gpu_kdtree.rs:188:9
    |
188 |         unsafe {
    |         ^^^^^^ unnecessary `unsafe` block

warning: variable does not need to be mutable
   --> src/orchestration/routing/te_validation.rs:367:13
    |
367 |         let mut total = results.len();
    |             ----^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `dim`
    --> src/orchestration/neuromorphic/unified_neuromorphic.rs:1054:13
     |
1054 |         for dim in 0..input_dim {
     |             ^^^ help: if this is intentional, prefix it with an underscore: `_dim`

warning: unused variable: `poisson`
    --> src/orchestration/neuromorphic/unified_neuromorphic.rs:1109:17
     |
1109 |             let poisson = Poisson::new((modulated_rate * 0.05).max(0.1)).unwrap();  // Scale for 50ms window
     |                 ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_poisson`

warning: unused variable: `weights`
  --> src/orchestration/neuromorphic/gpu_neuromorphic.rs:53:9
   |
53 |         weights: Option<&[f32]>,
   |         ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_weights`

warning: unused variable: `params`
  --> src/orchestration/neuromorphic/gpu_neuromorphic.rs:78:9
   |
78 |         params: &[(f32, f32, f32, f32)], // (a, b, c, d)
   |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_params`

warning: unused variable: `currents`
  --> src/orchestration/neuromorphic/gpu_neuromorphic.rs:96:61
   |
96 |     pub fn apply_input(&mut self, neuron_indices: &[usize], currents: &[f32]) -> Result<(), OrchestrationError> {
   |                                                             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_currents`

warning: unused variable: `batch_size`
   --> src/orchestration/local_llm/gpu_transformer.rs:254:13
    |
254 |         let batch_size = 1;  // For simplicity, batch_size = 1
    |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_batch_size`

warning: unused variable: `hidden_activated`
   --> src/orchestration/local_llm/gpu_transformer.rs:370:17
    |
370 |         let mut hidden_activated = hidden.clone();
    |                 ^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_hidden_activated`

warning: variable does not need to be mutable
   --> src/orchestration/local_llm/gpu_transformer.rs:370:13
    |
370 |         let mut hidden_activated = hidden.clone();
    |             ----^^^^^^^^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `tda`
   --> src/orchestration/local_llm/attention_analyzer.rs:315:58
    |
315 |         let topology_suggests_collapse = if let Some(ref tda) = self.tda_analyzer {
    |                                                          ^^^ help: if this is intentional, prefix it with an underscore: `_tda`

warning: unused variable: `y`
   --> src/orchestration/local_llm/transfer_entropy_llm.rs:340:35
    |
340 |     fn conditional_entropy(&self, y: usize, x_seq: &[usize]) -> Result<f32> {
    |                                   ^ help: if this is intentional, prefix it with an underscore: `_y`

warning: unused variable: `data`
  --> src/orchestration/local_llm/tda_topology_adapter.rs:23:32
   |
23 |     fn analyze_topology(&self, data: &[f64]) -> Result<TopologyAnalysis> {
   |                                ^^^^ help: if this is intentional, prefix it with an underscore: `_data`

warning: unused variable: `edges`
   --> src/orchestration/decomposition/pid_synergy.rs:846:46
    |
846 |     fn compute_mobius(nodes: &[LatticeNode], edges: &HashMap<usize, Vec<usize>>) -> HashMap<(usize, usize), f64> {
    |                                              ^^^^^ help: if this is intentional, prefix it with an underscore: `_edges`

warning: unused variable: `n_levels`
   --> src/orchestration/inference/hierarchical_active_inference.rs:200:13
    |
200 |         let n_levels = level_dims.len();
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_n_levels`

warning: unused variable: `iteration`
   --> src/orchestration/inference/hierarchical_active_inference.rs:286:13
    |
286 |         for iteration in 0..10 {  // Fixed iterations for now
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_iteration`

warning: value assigned to `total_F` is never read
   --> src/orchestration/inference/hierarchical_active_inference.rs:520:17
    |
520 |         let mut total_F = 0.0;
    |                 ^^^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: unused variable: `i`
   --> src/orchestration/inference/hierarchical_active_inference.rs:568:14
    |
568 |         for (i, policy) in self.action_selection.policies.iter().enumerate() {
    |              ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `state`
   --> src/orchestration/inference/hierarchical_active_inference.rs:664:49
    |
664 |     fn compute_expected_information_gain(&self, state: &DVector<f64>) -> Result<f64, OrchestrationError> {
    |                                                 ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `query`
   --> src/orchestration/inference/hierarchical_active_inference.rs:817:30
    |
817 | ...                   query: &str,
    |                       ^^^^^ help: if this is intentional, prefix it with an underscore: `_query`

warning: unused variable: `i`
   --> src/orchestration/inference/hierarchical_active_inference.rs:862:14
    |
862 |         for (i, response) in responses.iter().enumerate() {
    |              ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `delay`
   --> src/orchestration/inference/joint_active_inference.rs:604:21
    |
604 |                 let delay = match self.communication.bandwidth.delay_dist {
    |                     ^^^^^ help: if this is intentional, prefix it with an underscore: `_delay`

warning: unused variable: `i`
   --> src/orchestration/inference/joint_active_inference.rs:765:17
    |
765 |             for i in 0..n {
    |                 ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: variable does not need to be mutable
   --> src/orchestration/inference/joint_active_inference.rs:767:21
    |
767 |                 let mut received = proposals.clone();
    |                     ----^^^^^^^^
    |                     |
    |                     help: remove this `mut`

warning: unused variable: `agent`
   --> src/orchestration/inference/joint_active_inference.rs:982:14
    |
982 |         for (agent, agent_policy) in self.agents.iter().zip(&policy.agent_policies) {
    |              ^^^^^ help: if this is intentional, prefix it with an underscore: `_agent`

warning: unused variable: `constraint`
    --> src/orchestration/inference/joint_active_inference.rs:1030:32
     |
1030 |     fn check_constraint(&self, constraint: &CoordinationConstraint, policies: &[AgentPolicy]) -> bool {
     |                                ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_constraint`

warning: unused variable: `policies`
    --> src/orchestration/inference/joint_active_inference.rs:1030:69
     |
1030 |     fn check_constraint(&self, constraint: &CoordinationConstraint, policies: &[AgentPolicy]) -> bool {
     |                                                                     ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_policies`

warning: unused variable: `agent`
    --> src/orchestration/inference/joint_active_inference.rs:1217:13
     |
1217 |         for agent in &self.agents {
     |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_agent`

warning: variable does not need to be mutable
   --> src/orchestration/causality/bidirectional_causality.rs:321:13
    |
321 |         let mut ccm_result = self.convergent_cross_mapping(x_data, y_data)?;
    |             ----^^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `x_curr`
   --> src/orchestration/causality/bidirectional_causality.rs:738:31
    |
738 |         for ((y_next, y_curr, x_curr), p_joint) in &joint_prob {
    |                               ^^^^^^ help: if this is intentional, prefix it with an underscore: `_x_curr`

warning: unused variable: `query`
    --> src/orchestration/causality/bidirectional_causality.rs:1525:67
     |
1525 |     pub fn analyze_llm_causality(&mut self, responses: &[String], query: &str) -> Result<LLMCausalityAnalysis, OrchestrationError> {
     |                                                                   ^^^^^ help: if this is intentional, prefix it with an underscore: `_query`

warning: unused variable: `basis`
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:970:46
    |
970 |     fn compute_classical_correlations(&self, basis: &DMatrix<Complex64>) -> Result<f64, OrchestrationError> {
    |                                              ^^^^^ help: if this is intentional, prefix it with an underscore: `_basis`

warning: unused variable: `op`
   --> src/quantum_mlir/dialect.rs:117:42
    |
117 |             verification: Some(Box::new(|op| {
    |                                          ^^ help: if this is intentional, prefix it with an underscore: `_op`

warning: unused variable: `op`
   --> src/quantum_mlir/dialect.rs:166:42
    |
166 |             verification: Some(Box::new(|op| {
    |                                          ^^ help: if this is intentional, prefix it with an underscore: `_op`

warning: unused variable: `block_size`
  --> src/gpu/gpu_tensor_optimized.rs:69:13
   |
69 |         let block_size = 16;
   |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_block_size`

warning: unused variable: `lda`
  --> src/gpu/production_runtime.rs:59:17
   |
59 |         a: u64, lda: usize,
   |                 ^^^ help: if this is intentional, prefix it with an underscore: `_lda`

warning: unused variable: `ldb`
  --> src/gpu/production_runtime.rs:60:17
   |
60 |         b: u64, ldb: usize,
   |                 ^^^ help: if this is intentional, prefix it with an underscore: `_ldb`

warning: unused variable: `ldc`
  --> src/gpu/production_runtime.rs:62:17
   |
62 |         c: u64, ldc: usize,
   |                 ^^^ help: if this is intentional, prefix it with an underscore: `_ldc`

warning: unnecessary `unsafe` block
  --> src/gpu/cudarc_replacement.rs:45:9
   |
45 |         unsafe {
   |         ^^^^^^ unnecessary `unsafe` block

warning: unnecessary `unsafe` block
  --> src/gpu/cudarc_replacement.rs:63:9
   |
63 |         unsafe {
   |         ^^^^^^ unnecessary `unsafe` block

warning: unnecessary `unsafe` block
  --> src/gpu/cudarc_replacement.rs:78:9
   |
78 |         unsafe {
   |         ^^^^^^ unnecessary `unsafe` block

warning: unused variable: `transa`
   --> src/gpu/cudarc_replacement.rs:162:13
    |
162 |             transa: bool,
    |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_transa`

warning: unused variable: `transb`
   --> src/gpu/cudarc_replacement.rs:163:13
    |
163 |             transb: bool,
    |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_transb`

warning: unused variable: `incx`
   --> src/gpu/cudarc_replacement.rs:194:13
    |
194 |             incx: i32,
    |             ^^^^ help: if this is intentional, prefix it with an underscore: `_incx`

warning: unused variable: `incy`
   --> src/gpu/cudarc_replacement.rs:196:13
    |
196 |             incy: i32,
    |             ^^^^ help: if this is intentional, prefix it with an underscore: `_incy`

warning: unused variable: `regulated`
   --> src/phase6/predictive_neuro.rs:510:13
    |
510 |         let regulated = matrix + reg * Array2::eye(n);
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_regulated`

warning: unused variable: `block_size`
   --> src/phase6/gpu_tda.rs:179:13
    |
179 |         let block_size = 16;
    |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_block_size`

warning: unused variable: `delay`
   --> src/cma/causal_discovery.rs:131:13
    |
131 |         let delay = 1;
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_delay`

warning: unused variable: `beta`
   --> src/cma/quantum/path_integral.rs:143:9
    |
143 |         beta: f64,
    |         ^^^^ help: if this is intentional, prefix it with an underscore: `_beta`

warning: unused variable: `hamiltonian`
   --> src/cma/quantum/pimc_gpu.rs:168:37
    |
168 |     fn hamiltonian_to_matrix(&self, hamiltonian: &ProblemHamiltonian, n_dim: usize) -> Vec<f32> {
    |                                     ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_hamiltonian`

warning: unused variable: `hamiltonian`
   --> src/cma/neural/neural_quantum.rs:511:9
    |
511 |         hamiltonian: &ProblemHamiltonian,
    |         ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_hamiltonian`

warning: unused variable: `hamiltonian`
   --> src/cma/neural/neural_quantum.rs:526:9
    |
526 |         hamiltonian: &ProblemHamiltonian,
    |         ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_hamiltonian`

warning: unused variable: `batch_size`
   --> src/cma/neural/gnn_training.rs:296:9
    |
296 |         batch_size: usize,
    |         ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_batch_size`

warning: unused variable: `learning_rate`
   --> src/cma/neural/gnn_training.rs:777:9
    |
777 |         learning_rate: f64,
    |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_learning_rate`

warning: unused variable: `source_model`
   --> src/cma/neural/gnn_transfer_learning.rs:434:9
    |
434 |         source_model: &E3EquivariantGNN,
    |         ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_source_model`

warning: unused variable: `trained_model`
   --> src/cma/neural/gnn_transfer_learning.rs:518:13
    |
518 |         let trained_model = trainer.get_model();
    |             ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_trained_model`

warning: unused variable: `ensembles`
   --> src/cma/neural/gnn_transfer_learning.rs:702:9
    |
702 |         ensembles: &[Ensemble],
    |         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ensembles`

warning: unused variable: `manifolds`
   --> src/cma/neural/gnn_transfer_learning.rs:703:9
    |
703 |         manifolds: &[CausalManifold],
    |         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_manifolds`

warning: unused variable: `model`
   --> src/cma/neural/gnn_training_pipeline.rs:478:9
    |
478 |         model: &E3EquivariantGNN,
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_model`

warning: unused variable: `i`
   --> src/cma/neural/gnn_training_pipeline.rs:674:14
    |
674 |         for (i, metric) in metrics.iter().enumerate() {
    |              ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `rng`
  --> src/cma/gpu_integration.rs:76:13
   |
76 |         let rng = ChaCha20Rng::seed_from_u64(seed);
   |             ^^^ help: if this is intentional, prefix it with an underscore: `_rng`

warning: unnecessary `unsafe` block
   --> src/cma/gpu_integration.rs:158:13
    |
158 |             unsafe {
    |             ^^^^^^ unnecessary `unsafe` block

warning: unused variable: `n`
  --> src/cma/transfer_entropy_gpu.rs:63:13
   |
63 |         let n = source.len();
   |             ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: unused variable: `psi`
   --> src/cma/pac_bayes.rs:208:13
    |
208 |         let psi = |x: f64| -> f64 {
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_psi`

warning: unused variable: `train_data`
   --> src/cma/conformal_prediction.rs:210:14
    |
210 |         let (train_data, calib_data) = proper_training_data.split_at(split_point);
    |              ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_train_data`

warning: unused variable: `candidates`
   --> src/cma/conformal_prediction.rs:389:58
    |
389 |     fn compute_efficiency(&self, prediction_set: &[f64], candidates: &[f64]) -> f64 {
    |                                                          ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_candidates`

warning: unused variable: `x`
   --> src/cma/conformal_prediction.rs:474:35
    |
474 |     fn predict_uncertainty(&self, x: &Array1<f64>) -> Result<f64> {
    |                                   ^ help: if this is intentional, prefix it with an underscore: `_x`

warning: unused variable: `history`
   --> src/applications/robotics/trajectory_forecasting.rs:253:17
    |
253 |             let history = vec![TrajectoryPoint {
    |                 ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_history`

warning: unused variable: `historical_interactions`
   --> src/applications/robotics/trajectory_forecasting.rs:240:9
    |
240 |         historical_interactions: &[InteractionHistory],
    |         ^^^^^^^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_historical_interactions`

warning: unused variable: `protein_smiles`
  --> src/chemistry/gpu_docking.rs:35:9
   |
35 |         protein_smiles: &str,
   |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_protein_smiles`

warning: unused variable: `x_arr`
   --> src/time_series/lstm_forecaster.rs:362:13
    |
362 |         let x_arr = Array1::from(input_vec);
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_x_arr`

warning: unused variable: `variance`
   --> src/finance/portfolio_optimizer.rs:288:17
    |
288 |             let variance = self.compute_portfolio_variance(&weights, covariance);
    |                 ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_variance`

warning: value assigned to `temperature` is never read
   --> src/finance/thermodynamic_consensus.rs:190:17
    |
190 |         let mut temperature = self.config.temperature;
    |                 ^^^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: unused variable: `key`
   --> src/api_server/advanced_info_theory.rs:140:13
    |
140 |         let key = (hash_sequence(&x_history), hash_sequence(&y_prev_history), y_current);
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_key`

warning: unused variable: `y_recent`
   --> src/api_server/advanced_info_theory.rs:350:9
    |
350 |     let y_recent = if y_history.is_empty() {
    |         ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_y_recent`

warning: unused variable: `sharpe`
  --> src/api_server/portfolio.rs:86:17
   |
86 |             let sharpe = (portfolio_return - self.risk_free_rate) / portfolio_risk;
   |                 ^^^^^^ help: if this is intentional, prefix it with an underscore: `_sharpe`

warning: unused variable: `params`
   --> src/assistant/autonomous_agent.rs:220:55
    |
220 |     pub fn call_robotics_tool(&self, operation: &str, params: serde_json::Value) -> Result<ToolResult> {
    |                                                       ^^^^^^ help: if this is intentional, prefix it with an underscore: `_params`

warning: unused variable: `params`
   --> src/assistant/autonomous_agent.rs:243:58
    |
243 |     pub fn call_time_series_tool(&self, operation: &str, params: serde_json::Value) -> Result<ToolResult> {
    |                                                          ^^^^^^ help: if this is intentional, prefix it with an underscore: `_params`

warning: unused variable: `batch_size`
   --> src/assistant/local_llm/gpu_transformer.rs:254:13
    |
254 |         let batch_size = 1;  // For simplicity, batch_size = 1
    |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_batch_size`

warning: unused variable: `hidden_activated`
   --> src/assistant/local_llm/gpu_transformer.rs:370:17
    |
370 |         let mut hidden_activated = hidden.clone();
    |                 ^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_hidden_activated`

warning: variable does not need to be mutable
   --> src/assistant/local_llm/gpu_transformer.rs:370:13
    |
370 |         let mut hidden_activated = hidden.clone();
    |             ----^^^^^^^^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: type `LLMStatistics` is more private than the item `BanditLLMEnsemble::get_statistics`
   --> src/orchestration/llm_clients/ensemble.rs:207:5
    |
207 |     pub fn get_statistics(&self) -> Vec<LLMStatistics> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method `BanditLLMEnsemble::get_statistics` is reachable at visibility `pub`
    |
note: but type `LLMStatistics` is only usable at visibility `pub(self)`
   --> src/orchestration/llm_clients/ensemble.rs:45:1
    |
 45 | struct LLMStatistics {
    | ^^^^^^^^^^^^^^^^^^^^
    = note: `#[warn(private_interfaces)]` on by default

warning: type `mission_charlie_integration::IntegrationMetrics` is more private than the item `DiagnosticReport::performance_metrics`
   --> src/orchestration/integration/mission_charlie_integration.rs:578:5
    |
578 |     pub performance_metrics: IntegrationMetrics,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ field `DiagnosticReport::performance_metrics` is reachable at visibility `pub`
    |
note: but type `mission_charlie_integration::IntegrationMetrics` is only usable at visibility `pub(self)`
   --> src/orchestration/integration/mission_charlie_integration.rs:73:1
    |
 73 | struct IntegrationMetrics {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: type `Geodesic` is more private than the item `GeometricManifoldOptimizer::compute_geodesic`
    --> src/orchestration/optimization/geometric_manifold.rs:1148:5
     |
1148 |     pub fn compute_geodesic(&mut self, start: &DVector<f64>, end: &DVector<f64>) -> Result<Geodesic, OrchestrationError> {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method `GeometricManifoldOptimizer::compute_geodesic` is reachable at visibility `pub`
     |
note: but type `Geodesic` is only usable at visibility `pub(self)`
    --> src/orchestration/optimization/geometric_manifold.rs:286:1
     |
 286 | struct Geodesic {
     | ^^^^^^^^^^^^^^^

warning: type `Geodesic` is more private than the item `GeometricManifoldOptimizer::parallel_transport`
    --> src/orchestration/optimization/geometric_manifold.rs:1327:5
     |
1327 |     pub fn parallel_transport(&mut self, vector: &DVector<f64>, geodesic: &Geodesic) -> Result<DVector<f64>, OrchestrationError> {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method `GeometricManifoldOptimizer::parallel_transport` is reachable at visibility `pub`
     |
note: but type `Geodesic` is only usable at visibility `pub(self)`
    --> src/orchestration/optimization/geometric_manifold.rs:286:1
     |
 286 | struct Geodesic {
     | ^^^^^^^^^^^^^^^

warning: type `GpuEmbeddings` is more private than the item `GpuKSGEstimator::create_embeddings`
   --> src/cma/transfer_entropy_gpu.rs:223:5
    |
223 |     pub fn create_embeddings(&self, source: &TimeSeries, target: &TimeSeries) -> Result<GpuEmbeddings> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method `GpuKSGEstimator::create_embeddings` is reachable at visibility `pub`
    |
note: but type `GpuEmbeddings` is only usable at visibility `pub(self)`
   --> src/cma/transfer_entropy_gpu.rs:303:1
    |
303 | struct GpuEmbeddings {
    | ^^^^^^^^^^^^^^^^^^^^

warning: field `n_conditioning` is never read
  --> src/information_theory/conditional_te.rs:54:5
   |
46 | pub struct ConditionalTE {
   |            ------------- field in this struct
...
54 |     n_conditioning: usize,
   |     ^^^^^^^^^^^^^^
   |
   = note: `ConditionalTE` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` on by default

warning: field `dimensions` is never read
  --> src/information_theory/memory_efficient.rs:32:5
   |
26 | pub struct SparseHistogram {
   |            --------------- field in this struct
...
32 |     dimensions: usize,
   |     ^^^^^^^^^^
   |
   = note: `SparseHistogram` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `dimensions` is never read
   --> src/information_theory/memory_efficient.rs:264:5
    |
258 | pub struct CompressedHistogram {
    |            ------------------- field in this struct
...
264 |     dimensions: usize,
    |     ^^^^^^^^^^

warning: field `config` is never read
  --> src/information_theory/gpu_transfer_entropy.rs:17:5
   |
16 | pub struct GpuTransferEntropy {
   |            ------------------ field in this struct
17 |     config: TransferEntropy,
   |     ^^^^^^

warning: field `n_sources` is never read
   --> src/information_theory/multivariate_te.rs:422:5
    |
414 | struct MultivariateEmbeddings {
    |        ---------------------- field in this struct
...
422 |     n_sources: usize,
    |     ^^^^^^^^^
    |
    = note: `MultivariateEmbeddings` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `init_kernel` is never read
  --> src/statistical_mechanics/gpu.rs:27:5
   |
23 | pub struct ThermodynamicGpu {
   |            ---------------- field in this struct
...
27 |     init_kernel: Arc<CudaFunction>,
   |     ^^^^^^^^^^^

warning: fields `precision_weight_kernel`, `axpby_kernel`, `velocity_update_kernel`, and `hierarchical_project_kernel` are never read
  --> src/active_inference/gpu.rs:31:5
   |
24 | pub struct ActiveInferenceGpu {
   |            ------------------ fields in this struct
...
31 |     precision_weight_kernel: Arc<CudaFunction>,
   |     ^^^^^^^^^^^^^^^^^^^^^^^
...
35 |     axpby_kernel: Arc<CudaFunction>,
   |     ^^^^^^^^^^^^
36 |     velocity_update_kernel: Arc<CudaFunction>,
   |     ^^^^^^^^^^^^^^^^^^^^^^
37 |     hierarchical_project_kernel: Arc<CudaFunction>,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: field `rng_init_kernel` is never read
   --> src/active_inference/gpu_policy_eval.rs:105:5
    |
 96 | pub struct GpuPolicyEvaluator {
    |            ------------------ field in this struct
...
105 |     rng_init_kernel: Arc<CudaFunction>,
    |     ^^^^^^^^^^^^^^^
    |
    = note: `GpuPolicyEvaluator` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: field `config` is never read
   --> src/active_inference/hierarchical_inference_gpu.rs:111:5
    |
107 | pub struct HierarchicalActiveInferenceGpu {
    |            ------------------------------ field in this struct
...
111 |     config: HierarchicalConfig,
    |     ^^^^^^

warning: field `cuda_context` is never read
   --> src/integration/unified_platform.rs:162:5
    |
160 | pub struct UnifiedPlatform {
    |            --------------- field in this struct
161 |     /// Shared CUDA context (GPU resources)
162 |     cuda_context: Arc<CudaContext>,
    |     ^^^^^^^^^^^^

warning: field `num_qubits` is never read
  --> src/integration/quantum_mlir_integration.rs:24:5
   |
18 | pub struct QuantumMlirIntegration {
   |            ---------------------- field in this struct
...
24 |     num_qubits: usize,
   |     ^^^^^^^^^^

warning: method `calculate_coherence` is never used
   --> src/integration/quantum_mlir_integration.rs:204:8
    |
 37 | impl QuantumMlirIntegration {
    | --------------------------- method in this implementation
...
204 |     fn calculate_coherence(&self, state: &QuantumState) -> f64 {
    |        ^^^^^^^^^^^^^^^^^^^

warning: fields `constraint_weights_gpu`, `gnn_weights_gpu`, and `hamiltonian_gpu` are never read
  --> src/integration/multi_modal_reasoner.rs:49:5
   |
44 | pub struct MultiModalReasoner {
   |            ------------------ fields in this struct
...
49 |     constraint_weights_gpu: Option<CudaSlice<f32>>,
   |     ^^^^^^^^^^^^^^^^^^^^^^
...
52 |     gnn_weights_gpu: Option<Vec<CudaSlice<f32>>>,
   |     ^^^^^^^^^^^^^^^
...
55 |     hamiltonian_gpu: Option<CudaSlice<f32>>,
   |     ^^^^^^^^^^^^^^^

warning: field `id` is never read
  --> src/optimization/memory_optimizer.rs:48:5
   |
42 | pub struct PinnedBuffer {
   |            ------------ field in this struct
...
48 |     id: usize,
   |     ^^

warning: fields `buffer_size` and `num_buffers` are never read
  --> src/optimization/memory_optimizer.rs:92:5
   |
86 | pub struct PinnedMemoryPool {
   |            ---------------- fields in this struct
...
92 |     buffer_size: usize,
   |     ^^^^^^^^^^^
93 |     /// Total number of buffers
94 |     num_buffers: usize,
   |     ^^^^^^^^^^^

warning: field `id` is never read
  --> src/orchestration/llm_clients/openai_client.rs:62:5
   |
61 | struct OpenAIResponse {
   |        -------------- field in this struct
62 |     id: String,
   |     ^^
   |
   = note: `OpenAIResponse` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `id` is never read
  --> src/orchestration/llm_clients/claude_client.rs:43:5
   |
42 | struct ClaudeResponse {
   |        -------------- field in this struct
43 |     id: String,
   |     ^^
   |
   = note: `ClaudeResponse` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: field `timestamp` is never read
  --> src/orchestration/llm_clients/claude_client.rs:64:5
   |
62 | struct CachedResponse {
   |        -------------- field in this struct
63 |     response: LLMResponse,
64 |     timestamp: SystemTime,
   |     ^^^^^^^^^
   |
   = note: `CachedResponse` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: field `timestamp` is never read
  --> src/orchestration/llm_clients/gemini_client.rs:84:5
   |
82 | struct CachedResponse {
   |        -------------- field in this struct
83 |     response: LLMResponse,
84 |     timestamp: SystemTime,
   |     ^^^^^^^^^
   |
   = note: `CachedResponse` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: field `timestamp` is never read
  --> src/orchestration/llm_clients/grok_client.rs:61:5
   |
59 | struct CachedResponse {
   |        -------------- field in this struct
60 |     response: LLMResponse,
61 |     timestamp: SystemTime,
   |     ^^^^^^^^^
   |
   = note: `CachedResponse` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: field `model_name` is never read
  --> src/orchestration/llm_clients/ensemble.rs:46:5
   |
45 | struct LLMStatistics {
   |        ------------- field in this struct
46 |     model_name: String,
   |     ^^^^^^^^^^
   |
   = note: `LLMStatistics` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: field `model_priors` is never read
   --> src/orchestration/llm_clients/ensemble.rs:235:5
    |
228 | pub struct BayesianLLMEnsemble {
    |            ------------------- field in this struct
...
235 |     model_priors: Array1<f64>,
    |     ^^^^^^^^^^^^

warning: field `uncertainty_threshold` is never read
   --> src/orchestration/llm_clients/ensemble.rs:413:5
    |
405 | pub struct LLMOrchestrator {
    |            --------------- field in this struct
...
413 |     uncertainty_threshold: f64,
    |     ^^^^^^^^^^^^^^^^^^^^^

warning: field `cuda_context` is never read
  --> src/orchestration/thermodynamic/gpu_thermodynamic_consensus.rs:47:5
   |
45 | pub struct GpuThermodynamicConsensus {
   |            ------------------------- field in this struct
46 |     gpu_executor: Arc<std::sync::Mutex<GpuKernelExecutor>>,
47 |     cuda_context: Arc<CudaContext>,
   |     ^^^^^^^^^^^^

warning: field `timestamp` is never read
   --> src/orchestration/thermodynamic/advanced_energy.rs:154:5
    |
149 | struct EnergyRecord {
    |        ------------ field in this struct
...
154 |     timestamp: std::time::Instant,
    |     ^^^^^^^^^
    |
    = note: `EnergyRecord` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `token_predictor` is never read
  --> src/orchestration/active_inference/hierarchical_client.rs:34:5
   |
26 | pub struct HierarchicalActiveInferenceClient {
   |            --------------------------------- field in this struct
...
34 |     token_predictor: Option<TokenPredictor>,
   |     ^^^^^^^^^^^^^^^

warning: field `predicted_tokens` is never read
  --> src/orchestration/active_inference/hierarchical_client.rs:56:5
   |
55 | struct TokenPredictor {
   |        -------------- field in this struct
56 |     predicted_tokens: Vec<String>,
   |     ^^^^^^^^^^^^^^^^

warning: fields `mdl_optimizer` and `pwsa_bridge` are never read
  --> src/orchestration/integration/mission_charlie_integration.rs:39:5
   |
33 | pub struct MissionCharlieIntegration {
   |            ------------------------- fields in this struct
...
39 |     mdl_optimizer: MDLPromptOptimizer,
   |     ^^^^^^^^^^^^^
...
43 |     pwsa_bridge: PWSAIntegrationBridge,
   |     ^^^^^^^^^^^

warning: field `synergy` is never read
  --> src/orchestration/integration/mission_charlie_integration.rs:79:5
   |
73 | struct IntegrationMetrics {
   |        ------------------ field in this struct
...
79 |     synergy: HashMap<(String, String), f64>,
   |     ^^^^^^^
   |
   = note: `IntegrationMetrics` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `gpu_backend` is never read
   --> src/orchestration/integration/prism_ai_integration.rs:109:5
    |
 88 | pub struct PrismAIOrchestrator {
    |            ------------------- field in this struct
...
109 |     gpu_backend: Arc<RwLock<GpuBackend>>,
    |     ^^^^^^^^^^^

warning: field `feature_importance` is never read
  --> src/orchestration/optimization/mdl_prompt_optimizer.rs:18:5
   |
16 | pub struct MDLPromptOptimizer {
   |            ------------------ field in this struct
17 |     /// Feature importance (learned from historical queries)
18 |     feature_importance: HashMap<String, f64>,
   |     ^^^^^^^^^^^^^^^^^^

warning: field `curvature` is never read
  --> src/orchestration/optimization/geometric_manifold.rs:25:5
   |
13 | pub struct GeometricManifoldOptimizer {
   |            -------------------------- field in this struct
...
25 |     curvature: CurvatureAnalyzer,
   |     ^^^^^^^^^

warning: field `chart` is never read
  --> src/orchestration/optimization/geometric_manifold.rs:44:5
   |
32 | struct RiemannianManifold {
   |        ------------------ field in this struct
...
44 |     chart: LocalChart,
   |     ^^^^^
   |
   = note: `RiemannianManifold` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: fields `g_inv` and `det_g` are never read
  --> src/orchestration/optimization/geometric_manifold.rs:64:5
   |
60 | struct MetricTensor {
   |        ------------ fields in this struct
...
64 |     g_inv: Box<dyn Fn(&DVector<f64>) -> DMatrix<f64> + Send + Sync>,
   |     ^^^^^
65 |     /// Determinant of metric
66 |     det_g: Box<dyn Fn(&DVector<f64>) -> f64 + Send + Sync>,
   |     ^^^^^

warning: fields `grad_h` and `hess_h` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:103:5
    |
 99 | struct ManifoldConstraint {
    |        ------------------ fields in this struct
...
103 |     grad_h: fn(&DVector<f64>) -> DVector<f64>,
    |     ^^^^^^
104 |     /// Hessian of constraint
105 |     hess_h: fn(&DVector<f64>) -> DMatrix<f64>,
    |     ^^^^^^
    |
    = note: `ManifoldConstraint` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `domain`, `phi`, `phi_inv`, and `d_phi` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:112:5
    |
110 | struct LocalChart {
    |        ---------- fields in this struct
111 |     /// Chart domain
112 |     domain: Domain,
    |     ^^^^^^
113 |     /// Coordinate map
114 |     phi: fn(&DVector<f64>) -> DVector<f64>,
    |     ^^^
115 |     /// Inverse map
116 |     phi_inv: fn(&DVector<f64>) -> DVector<f64>,
    |     ^^^^^^^
117 |     /// Jacobian of coordinate map
118 |     d_phi: fn(&DVector<f64>) -> DMatrix<f64>,
    |     ^^^^^
    |
    = note: `LocalChart` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `lower` and `upper` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:124:5
    |
122 | struct Domain {
    |        ------ fields in this struct
123 |     /// Lower bounds
124 |     lower: DVector<f64>,
    |     ^^^^^
125 |     /// Upper bounds
126 |     upper: DVector<f64>,
    |     ^^^^^
    |
    = note: `Domain` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `line_search` and `trust_region` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:139:5
    |
131 | struct ManifoldOptimizer {
    |        ----------------- fields in this struct
...
139 |     line_search: LineSearchMethod,
    |     ^^^^^^^^^^^
140 |     /// Trust region parameters
141 |     trust_region: TrustRegionParams,
    |     ^^^^^^^^^^^^
    |
    = note: `ManifoldOptimizer` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: multiple variants are never constructed
   --> src/orchestration/optimization/geometric_manifold.rs:146:5
    |
145 | enum OptimizationAlgorithm {
    |      --------------------- variants in this enum
146 |     RiemannianGradientDescent,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
147 |     RiemannianConjugateGradient,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
148 |     RiemannianNewton,
    |     ^^^^^^^^^^^^^^^^
149 |     RiemannianQuasiNewton,
    |     ^^^^^^^^^^^^^^^^^^^^^
150 |     RiemannianTrustRegion,
    |     ^^^^^^^^^^^^^^^^^^^^^
151 |     NaturalGradientDescent,
    |     ^^^^^^^^^^^^^^^^^^^^^^
152 |     RiemannianAdam,
153 |     RiemannianLBFGS,
    |     ^^^^^^^^^^^^^^^
    |
    = note: `OptimizationAlgorithm` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Fixed`, `LineSearch`, and `Armijo` are never constructed
   --> src/orchestration/optimization/geometric_manifold.rs:158:5
    |
157 | enum StepSizeSchedule {
    |      ---------------- variants in this enum
158 |     Fixed(f64),
    |     ^^^^^
159 |     Adaptive(AdaptiveSchedule),
160 |     LineSearch,
    |     ^^^^^^^^^^
161 |     Armijo,
    |     ^^^^^^
    |
    = note: `StepSizeSchedule` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `min_step` is never read
   --> src/orchestration/optimization/geometric_manifold.rs:168:5
    |
165 | struct AdaptiveSchedule {
    |        ---------------- field in this struct
...
168 |     min_step: f64,
    |     ^^^^^^^^
    |
    = note: `AdaptiveSchedule` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `f_tol` and `x_tol` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:178:5
    |
172 | struct ConvergenceCriteria {
    |        ------------------- fields in this struct
...
178 |     f_tol: f64,
    |     ^^^^^
179 |     /// Step size tolerance
180 |     x_tol: f64,
    |     ^^^^^
    |
    = note: `ConvergenceCriteria` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Backtracking`, `WolfeConditions`, and `NonmonotoneLineSearch` are never constructed
   --> src/orchestration/optimization/geometric_manifold.rs:185:5
    |
184 | enum LineSearchMethod {
    |      ---------------- variants in this enum
185 |     Backtracking,
    |     ^^^^^^^^^^^^
186 |     WolfeConditions,
    |     ^^^^^^^^^^^^^^^
187 |     StrongWolfe,
188 |     NonmonotoneLineSearch,
    |     ^^^^^^^^^^^^^^^^^^^^^
    |
    = note: `LineSearchMethod` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `delta`, `delta_max`, `eta_1`, and `eta_2` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:194:5
    |
192 | struct TrustRegionParams {
    |        ----------------- fields in this struct
193 |     /// Initial trust region radius
194 |     delta: f64,
    |     ^^^^^
195 |     /// Maximum radius
196 |     delta_max: f64,
    |     ^^^^^^^^^
197 |     /// Radius update parameters
198 |     eta_1: f64,
    |     ^^^^^
199 |     eta_2: f64,
    |     ^^^^^
    |
    = note: `TrustRegionParams` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `lambda`, `diagonal`, and `kfac` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:208:5
    |
204 | struct NaturalGradient {
    |        --------------- fields in this struct
...
208 |     lambda: f64,
    |     ^^^^^^
209 |     /// Use diagonal approximation
210 |     diagonal: bool,
    |     ^^^^^^^^
211 |     /// Use KFAC approximation
212 |     kfac: bool,
    |     ^^^^
    |
    = note: `NaturalGradient` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `F_diag`, `A`, and `G` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:222:5
    |
218 | struct FisherInformation {
    |        ----------------- fields in this struct
...
222 |     F_diag: DVector<f64>,
    |     ^^^^^^
223 |     /// KFAC factors
224 |     A: Option<DMatrix<f64>>,
    |     ^
225 |     G: Option<DMatrix<f64>>,
    |     ^
    |
    = note: `FisherInformation` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `integration` is never read
   --> src/orchestration/optimization/geometric_manifold.rs:234:5
    |
232 | struct GeodesicSolver {
    |        -------------- field in this struct
233 |     /// Integration method
234 |     integration: IntegrationMethod,
    |     ^^^^^^^^^^^
    |
    = note: `GeodesicSolver` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `DormandPrince`, `SymplecticEuler`, and `Verlet` are never constructed
   --> src/orchestration/optimization/geometric_manifold.rs:246:5
    |
244 | enum IntegrationMethod {
    |      ----------------- variants in this enum
245 |     RungeKutta4,
246 |     DormandPrince,
    |     ^^^^^^^^^^^^^
247 |     SymplecticEuler,
    |     ^^^^^^^^^^^^^^^
248 |     Verlet,
    |     ^^^^^^
    |
    = note: `IntegrationMethod` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `max_iter` is never read
   --> src/orchestration/optimization/geometric_manifold.rs:258:5
    |
252 | struct BVPSolver {
    |        --------- field in this struct
...
258 |     max_iter: usize,
    |     ^^^^^^^^
    |
    = note: `BVPSolver` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `FiniteDifference` and `Collocation` are never constructed
   --> src/orchestration/optimization/geometric_manifold.rs:264:5
    |
262 | enum BVPMethod {
    |      --------- variants in this enum
263 |     Shooting,
264 |     FiniteDifference,
    |     ^^^^^^^^^^^^^^^^
265 |     Collocation,
    |     ^^^^^^^^^^^
    |
    = note: `BVPMethod` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `velocity_search` and `newton_tol` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:271:5
    |
269 | struct ShootingMethod {
    |        -------------- fields in this struct
270 |     /// Initial velocity search
271 |     velocity_search: VelocitySearch,
    |     ^^^^^^^^^^^^^^^
272 |     /// Newton iterations
273 |     newton_tol: f64,
    |     ^^^^^^^^^^
    |
    = note: `ShootingMethod` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `GradientDescent` and `ParticleSwarm` are never constructed
   --> src/orchestration/optimization/geometric_manifold.rs:281:5
    |
279 | enum VelocitySearch {
    |      -------------- variants in this enum
280 |     Newton,
281 |     GradientDescent,
    |     ^^^^^^^^^^^^^^^
282 |     ParticleSwarm,
    |     ^^^^^^^^^^^^^
    |
    = note: `VelocitySearch` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `start` is never read
   --> src/orchestration/optimization/geometric_manifold.rs:288:5
    |
286 | struct Geodesic {
    |        -------- field in this struct
287 |     /// Starting point
288 |     start: DVector<f64>,
    |     ^^^^^
    |
    = note: `Geodesic` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `pole_params` and `cache` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:307:5
    |
301 | struct ParallelTransport {
    |        ----------------- fields in this struct
...
307 |     pole_params: PoleLadder,
    |     ^^^^^^^^^^^
308 |     /// Transport cache
309 |     cache: HashMap<u64, DMatrix<f64>>,
    |     ^^^^^
    |
    = note: `ParallelTransport` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `PoleLadder`, `FermiWalker`, and `LieTransport` are never constructed
   --> src/orchestration/optimization/geometric_manifold.rs:315:5
    |
313 | enum TransportMethod {
    |      --------------- variants in this enum
314 |     SchildLadder,
315 |     PoleLadder,
    |     ^^^^^^^^^^
316 |     FermiWalker,
    |     ^^^^^^^^^^^
317 |     LieTransport,
    |     ^^^^^^^^^^^^
    |
    = note: `TransportMethod` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `order` is never read
   --> src/orchestration/optimization/geometric_manifold.rs:325:5
    |
321 | struct SchildLadder {
    |        ------------ field in this struct
...
325 |     order: usize,
    |     ^^^^^
    |
    = note: `SchildLadder` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `pole` and `retraction` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:331:5
    |
329 | struct PoleLadder {
    |        ---------- fields in this struct
330 |     /// Pole point
331 |     pole: Option<DVector<f64>>,
    |     ^^^^
332 |     /// Retraction type
333 |     retraction: RetractionType,
    |     ^^^^^^^^^^
    |
    = note: `PoleLadder` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Cayley` and `Projection` are never constructed
   --> src/orchestration/optimization/geometric_manifold.rs:339:5
    |
337 | enum RetractionType {
    |      -------------- variants in this enum
338 |     Exponential,
339 |     Cayley,
    |     ^^^^^^
340 |     Projection,
    |     ^^^^^^^^^^
    |
    = note: `RetractionType` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `riemann`, `ricci`, `scalar`, and `sectional` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:347:5
    |
345 | struct CurvatureAnalyzer {
    |        ----------------- fields in this struct
346 |     /// Riemann curvature tensor
347 |     riemann: RiemannTensor,
    |     ^^^^^^^
348 |     /// Ricci curvature
349 |     ricci: RicciCurvature,
    |     ^^^^^
350 |     /// Scalar curvature
351 |     scalar: ScalarCurvature,
    |     ^^^^^^
352 |     /// Sectional curvatures
353 |     sectional: SectionalCurvatures,
    |     ^^^^^^^^^
    |
    = note: `CurvatureAnalyzer` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `components` and `symmetries` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:359:5
    |
357 | struct RiemannTensor {
    |        ------------- fields in this struct
358 |     /// R^l_ijk components
359 |     components: HashMap<(usize, usize, usize, usize), f64>,
    |     ^^^^^^^^^^
360 |     /// Symmetries
361 |     symmetries: TensorSymmetries,
    |     ^^^^^^^^^^
    |
    = note: `RiemannTensor` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `antisym_12`, `antisym_34`, `interchange`, and `bianchi` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:366:5
    |
365 | struct TensorSymmetries {
    |        ---------------- fields in this struct
366 |     antisym_12: bool,
    |     ^^^^^^^^^^
367 |     antisym_34: bool,
    |     ^^^^^^^^^^
368 |     interchange: bool,
    |     ^^^^^^^^^^^
369 |     bianchi: bool,
    |     ^^^^^^^
    |
    = note: `TensorSymmetries` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `tensor` and `eigenvalues` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:375:5
    |
373 | struct RicciCurvature {
    |        -------------- fields in this struct
374 |     /// Ricci tensor R_ij
375 |     tensor: DMatrix<f64>,
    |     ^^^^^^
376 |     /// Eigenvalues
377 |     eigenvalues: DVector<f64>,
    |     ^^^^^^^^^^^
    |
    = note: `RicciCurvature` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `value` and `gradient` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:383:5
    |
381 | struct ScalarCurvature {
    |        --------------- fields in this struct
382 |     /// Scalar curvature value
383 |     value: f64,
    |     ^^^^^
384 |     /// Gradient of scalar curvature
385 |     gradient: DVector<f64>,
    |     ^^^^^^^^
    |
    = note: `ScalarCurvature` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `curvatures` and `principal` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:391:5
    |
389 | struct SectionalCurvatures {
    |        ------------------- fields in this struct
390 |     /// Sectional curvatures for 2-planes
391 |     curvatures: HashMap<(usize, usize), f64>,
    |     ^^^^^^^^^^
392 |     /// Principal curvatures
393 |     principal: Vec<f64>,
    |     ^^^^^^^^^
    |
    = note: `SectionalCurvatures` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `f_decrease`, `step_norm`, and `constraint_violation` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:416:5
    |
412 | struct ConvergenceMetrics {
    |        ------------------ fields in this struct
...
416 |     f_decrease: f64,
    |     ^^^^^^^^^^
417 |     /// Step norm
418 |     step_norm: f64,
    |     ^^^^^^^^^
419 |     /// Constraint violation
420 |     constraint_violation: f64,
    |     ^^^^^^^^^^^^^^^^^^^^
    |
    = note: `ConvergenceMetrics` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `timestamp` is never read
  --> src/orchestration/caching/quantum_semantic_cache.rs:43:5
   |
39 | struct CachedEntry {
   |        ----------- field in this struct
...
43 |     timestamp: SystemTime,
   |     ^^^^^^^^^
   |
   = note: `CachedEntry` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: field `model_name` is never read
  --> src/orchestration/routing/thermodynamic_balancer.rs:30:5
   |
29 | struct LLMPerformanceProfile {
   |        --------------------- field in this struct
30 |     model_name: String,
   |     ^^^^^^^^^^
   |
   = note: `LLMPerformanceProfile` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: method `extract_core_concept` is never used
   --> src/orchestration/routing/thermodynamic_balancer.rs:296:8
    |
164 | impl QuantumVotingConsensus {
    | --------------------------- method in this implementation
...
296 |     fn extract_core_concept(&self, response: &str) -> String {
    |        ^^^^^^^^^^^^^^^^^^^^

warning: field `timestamp` is never read
  --> src/orchestration/routing/transfer_entropy_router.rs:62:5
   |
56 | struct RoutingHistory {
   |        -------------- field in this struct
...
62 |     timestamp: u64,
   |     ^^^^^^^^^

warning: field `enable_domain` is never read
  --> src/orchestration/routing/transfer_entropy_router.rs:86:5
   |
84 | struct FeatureConfig {
   |        ------------- field in this struct
85 |     /// Enable domain detection
86 |     enable_domain: bool,
   |     ^^^^^^^^^^^^^
   |
   = note: `FeatureConfig` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `cuda_context` is never read
  --> src/orchestration/routing/gpu_transfer_entropy_router.rs:93:5
   |
91 | pub struct GpuTransferEntropyRouter {
   |            ------------------------ field in this struct
92 |     gpu_executor: Arc<std::sync::Mutex<GpuKernelExecutor>>,
93 |     cuda_context: Arc<CudaContext>,
   |     ^^^^^^^^^^^^

warning: fields `time` and `amplitude` are never read
   --> src/orchestration/neuromorphic/spike_consensus.rs:108:5
    |
107 | struct Spike {
    |        ----- fields in this struct
108 |     time: f64,
    |     ^^^^
109 |     amplitude: f64,
    |     ^^^^^^^^^

warning: field `neuron_type` is never read
  --> src/orchestration/neuromorphic/unified_neuromorphic.rs:61:5
   |
50 | struct IzhikevichNeuron {
   |        ---------------- field in this struct
...
61 |     neuron_type: NeuronType,
   |     ^^^^^^^^^^^
   |
   = note: `IzhikevichNeuron` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `LowThreshold` and `Resonator` are never constructed
  --> src/orchestration/neuromorphic/unified_neuromorphic.rs:75:5
   |
71 | enum NeuronType {
   |      ---------- variants in this enum
...
75 |     LowThreshold,        // LTS interneurons
   |     ^^^^^^^^^^^^
76 |     Resonator,           // Resonator neurons
   |     ^^^^^^^^^
   |
   = note: `NeuronType` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `delay` is never read
  --> src/orchestration/neuromorphic/unified_neuromorphic.rs:90:5
   |
82 | struct Synapse {
   |        ------- field in this struct
...
90 |     delay: f64,
   |     ^^^^^
   |
   = note: `Synapse` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Static`, `ShortTerm`, `Homeostatic`, and `Neuromodulated` are never constructed
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:103:5
    |
102 | enum PlasticityType {
    |      -------------- variants in this enum
103 |     Static,
    |     ^^^^^^
104 |     STDP,
105 |     ShortTerm,
    |     ^^^^^^^^^
106 |     Homeostatic,
    |     ^^^^^^^^^^^
107 |     Neuromodulated,
    |     ^^^^^^^^^^^^^^
    |
    = note: `PlasticityType` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `tau_F` and `tau_D` are never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:118:5
    |
112 | struct STPState {
    |        -------- fields in this struct
...
118 |     tau_F: f64,
    |     ^^^^^
119 |     tau_D: f64,
    |     ^^^^^
    |
    = note: `STPState` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `layer_type` is never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:128:5
    |
124 | struct Layer {
    |        ----- field in this struct
...
128 |     layer_type: LayerType,
    |     ^^^^^^^^^^
    |
    = note: `Layer` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variant `Reservoir` is never constructed
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:138:5
    |
134 | enum LayerType {
    |      --------- variant in this enum
...
138 |     Reservoir,  // For liquid state machine
    |     ^^^^^^^^^
    |
    = note: `LayerType` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `tau_plus` and `tau_minus` are never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:145:5
    |
143 | struct STDPEngine {
    |        ---------- fields in this struct
144 |     /// STDP window parameters
145 |     tau_plus: f64,   // LTP time constant (ms)
    |     ^^^^^^^^
146 |     tau_minus: f64,  // LTD time constant (ms)
    |     ^^^^^^^^^
    |
    = note: `STDPEngine` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `neurons_per_dim`, `tuning_curves`, `decoding_matrix`, `sparsity`, and `lambda_sparse` are never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:170:5
    |
168 | struct PopulationCoder {
    |        --------------- fields in this struct
169 |     /// Number of neurons per dimension
170 |     neurons_per_dim: usize,
    |     ^^^^^^^^^^^^^^^
171 |     /// Tuning curves for each neuron
172 |     tuning_curves: Vec<TuningCurve>,
    |     ^^^^^^^^^^^^^
173 |     /// Decoding weights
174 |     decoding_matrix: DMatrix<f64>,
    |     ^^^^^^^^^^^^^^^
175 |     /// Sparse coding parameters
176 |     sparsity: f64,
    |     ^^^^^^^^
177 |     lambda_sparse: f64,
    |     ^^^^^^^^^^^^^
    |
    = note: `PopulationCoder` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `preferred`, `sigma`, `max_rate`, and `baseline` are never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:183:5
    |
181 | struct TuningCurve {
    |        ----------- fields in this struct
182 |     /// Preferred value
183 |     preferred: f64,
    |     ^^^^^^^^^
184 |     /// Tuning width
185 |     sigma: f64,
    |     ^^^^^
186 |     /// Maximum firing rate
187 |     max_rate: f64,
    |     ^^^^^^^^
188 |     /// Baseline rate
189 |     baseline: f64,
    |     ^^^^^^^^
    |
    = note: `TuningCurve` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `temporal_kernel` and `sequence_memory` are never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:198:5
    |
194 | struct TemporalProcessor {
    |        ----------------- fields in this struct
...
198 |     temporal_kernel: Vec<f64>,
    |     ^^^^^^^^^^^^^^^
...
202 |     sequence_memory: SequenceMemory,
    |     ^^^^^^^^^^^^^^^
    |
    = note: `TemporalProcessor` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `spectral_radius` is never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:210:5
    |
206 | struct ReservoirState {
    |        -------------- field in this struct
...
210 |     spectral_radius: f64,
    |     ^^^^^^^^^^^^^^^
    |
    = note: `ReservoirState` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `sequences`, `similarity_threshold`, and `max_length` are never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:230:5
    |
228 | struct SequenceMemory {
    |        -------------- fields in this struct
229 |     /// Stored sequences
230 |     sequences: Vec<Vec<DVector<f64>>>,
    |     ^^^^^^^^^
231 |     /// Sequence similarity threshold
232 |     similarity_threshold: f64,
    |     ^^^^^^^^^^^^^^^^^^^^
233 |     /// Maximum sequence length
234 |     max_length: usize,
    |     ^^^^^^^^^^
    |
    = note: `SequenceMemory` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `tau_homeostatic` is never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:245:5
    |
239 | struct HomeostaticController {
    |        --------------------- field in this struct
...
245 |     tau_homeostatic: f64,
    |     ^^^^^^^^^^^^^^^
    |
    = note: `HomeostaticController` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `routing_table` and `pattern_threshold` are never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:256:5
    |
254 | struct SpikeRouter {
    |        ----------- fields in this struct
255 |     /// Routing table based on spike patterns
256 |     routing_table: HashMap<SpikePattern, usize>,
    |     ^^^^^^^^^^^^^
...
262 |     pattern_threshold: f64,
    |     ^^^^^^^^^^^^^^^^^
    |
    = note: `SpikeRouter` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `source`, `target`, and `weight` are never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:276:5
    |
274 | struct Route {
    |        ----- fields in this struct
275 |     /// Source layer
276 |     source: usize,
    |     ^^^^^^
277 |     /// Target layer
278 |     target: usize,
    |     ^^^^^^
279 |     /// Routing weight
280 |     weight: f64,
    |     ^^^^^^
    |
    = note: `Route` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `device` is never read
   --> src/orchestration/production/gpu_monitoring.rs:111:5
    |
105 | pub struct GpuMonitor {
    |            ---------- field in this struct
...
111 |     device: Option<Arc<CudaContext>>,
    |     ^^^^^^

warning: fields `wq`, `wk`, `wv`, and `wo` are never read
  --> src/orchestration/local_llm/gpu_transformer.rs:22:5
   |
17 | pub struct GpuTransformerLayer {
   |            ------------------- fields in this struct
...
22 |     wq: CudaSlice<f32>,  // Query projection weights
   |     ^^
23 |     wk: CudaSlice<f32>,  // Key projection weights
   |     ^^
24 |     wv: CudaSlice<f32>,  // Value projection weights
   |     ^^
25 |     wo: CudaSlice<f32>,  // Output projection weights
   |     ^^

warning: fields `metrics`, `attention_analyzer`, `transfer_entropy`, and `n_heads` are never read
   --> src/orchestration/local_llm/gpu_transformer.rs:416:5
    |
396 | pub struct GpuLLMInference {
    |            --------------- fields in this struct
...
416 |     metrics: Option<LLMMetrics>,
    |     ^^^^^^^
417 |     attention_analyzer: Option<AttentionAnalyzer>,
    |     ^^^^^^^^^^^^^^^^^^
418 |     transfer_entropy: Option<TransferEntropyLLM>,
    |     ^^^^^^^^^^^^^^^^
...
424 |     n_heads: usize,
    |     ^^^^^^^

warning: field `alignment` is never read
   --> src/orchestration/local_llm/gguf_loader.rs:199:5
    |
185 | pub struct GgufLoader {
    |            ---------- field in this struct
...
199 |     alignment: u64,
    |     ^^^^^^^^^

warning: field `timestamp` is never read
  --> src/orchestration/cache/quantum_cache.rs:43:5
   |
39 | struct CachedEntry {
   |        ----------- field in this struct
...
43 |     timestamp: SystemTime,
   |     ^^^^^^^^^
   |
   = note: `CachedEntry` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: field `temperature` is never read
 --> src/orchestration/consensus/hamiltonian.rs:7:5
  |
5 | pub struct InformationHamiltonian {
  |            ---------------------- field in this struct
6 |     n_llms: usize,
7 |     temperature: f64,
  |     ^^^^^^^^^^^

warning: fields `edges` and `mobius` are never read
  --> src/orchestration/decomposition/pid_synergy.rs:32:5
   |
28 | struct InformationLattice {
   |        ------------------ fields in this struct
...
32 |     edges: HashMap<usize, Vec<usize>>,
   |     ^^^^^
33 |     /// Möbius function values for inclusion-exclusion
34 |     mobius: HashMap<(usize, usize), f64>,
   |     ^^^^^^
   |
   = note: `InformationLattice` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `pi_value` and `cumulative_info` are never read
  --> src/orchestration/decomposition/pid_synergy.rs:42:5
   |
38 | struct LatticeNode {
   |        ----------- fields in this struct
...
42 |     pi_value: f64,
   |     ^^^^^^^^
43 |     /// Cumulative information (PI + all descendants)
44 |     cumulative_info: f64,
   |     ^^^^^^^^^^^^^^^
   |
   = note: `LatticeNode` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `use_gpu` and `parallel_threshold` are never read
  --> src/orchestration/decomposition/pid_synergy.rs:71:5
   |
65 | struct OptimizationConfig {
   |        ------------------ fields in this struct
...
71 |     use_gpu: bool,
   |     ^^^^^^^
72 |     /// Parallel decomposition for large systems
73 |     parallel_threshold: usize,
   |     ^^^^^^^^^^^^^^^^^^
   |
   = note: `OptimizationConfig` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `pi_a` is never read
  --> src/orchestration/inference/hierarchical_active_inference.rs:58:5
   |
52 | struct PrecisionMatrix {
   |        --------------- field in this struct
...
58 |     pi_a: DMatrix<f64>,
   |     ^^^^
   |
   = note: `PrecisionMatrix` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `kl_divergence` is never read
  --> src/orchestration/inference/hierarchical_active_inference.rs:75:5
   |
67 | struct VariationalParameters {
   |        --------------------- field in this struct
...
75 |     kl_divergence: f64,
   |     ^^^^^^^^^^^^^
   |
   = note: `VariationalParameters` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `eta_pi` and `eta_a` are never read
  --> src/orchestration/inference/hierarchical_active_inference.rs:86:5
   |
82 | struct LearningRates {
   |        ------------- fields in this struct
...
86 |     eta_pi: f64,
   |     ^^^^^^
...
90 |     eta_a: f64,
   |     ^^^^^
   |
   = note: `LearningRates` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `habits` is never read
   --> src/orchestration/inference/hierarchical_active_inference.rs:120:5
    |
110 | struct ActionSelection {
    |        --------------- field in this struct
...
120 |     habits: DVector<f64>,
    |     ^^^^^^
    |
    = note: `ActionSelection` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `probability` and `expected_outcomes` are never read
   --> src/orchestration/inference/hierarchical_active_inference.rs:128:5
    |
124 | struct Policy {
    |        ------ fields in this struct
...
128 |     probability: f64,
    |     ^^^^^^^^^^^
129 |     /// Expected outcomes under this policy
130 |     expected_outcomes: Vec<DVector<f64>>,
    |     ^^^^^^^^^^^^^^^^^
    |
    = note: `Policy` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `id` is never read
  --> src/orchestration/inference/joint_active_inference.rs:34:5
   |
32 | struct ActiveInferenceAgent {
   |        -------------------- field in this struct
33 |     /// Agent ID
34 |     id: usize,
   |     ^^
   |
   = note: `ActiveInferenceAgent` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `B`, `C`, `D`, `theta`, and `depth` are never read
  --> src/orchestration/inference/joint_active_inference.rs:57:5
   |
53 | struct LocalGenerativeModel {
   |        -------------------- fields in this struct
...
57 |     B: DMatrix<f64>,
   |     ^
58 |     /// Prior preferences C
59 |     C: DVector<f64>,
   |     ^
60 |     /// Initial state prior D
61 |     D: DVector<f64>,
   |     ^
62 |     /// Model parameters θ
63 |     theta: DVector<f64>,
   |     ^^^^^
64 |     /// Hierarchical depth
65 |     depth: usize,
   |     ^^^^^
   |
   = note: `LocalGenerativeModel` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `sigma` and `info_gain` are never read
  --> src/orchestration/inference/joint_active_inference.rs:74:5
   |
70 | struct BeliefState {
   |        ----------- fields in this struct
...
74 |     sigma: DMatrix<f64>,
   |     ^^^^^
...
80 |     info_gain: f64,
   |     ^^^^^^^^^
   |
   = note: `BeliefState` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `pi_w`, `pi_gamma`, `attention`, and `adaptive` are never read
  --> src/orchestration/inference/joint_active_inference.rs:91:5
   |
87 | struct PrecisionWeights {
   |        ---------------- fields in this struct
...
91 |     pi_w: f64,
   |     ^^^^
92 |     /// Policy precision
93 |     pi_gamma: f64,
   |     ^^^^^^^^
94 |     /// Attention weights
95 |     attention: DVector<f64>,
   |     ^^^^^^^^^
96 |     /// Adaptive precision
97 |     adaptive: bool,
   |     ^^^^^^^^
   |
   = note: `PrecisionWeights` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `eta_theta`, `eta_pi`, `temperature`, and `gamma` are never read
   --> src/orchestration/inference/joint_active_inference.rs:106:5
    |
102 | struct LearningParameters {
    |        ------------------ fields in this struct
...
106 |     eta_theta: f64,
    |     ^^^^^^^^^
107 |     /// Learning rate for precision
108 |     eta_pi: f64,
    |     ^^^^^^
109 |     /// Exploration temperature
110 |     temperature: f64,
    |     ^^^^^^^^^^^
111 |     /// Discount factor
112 |     gamma: f64,
    |     ^^^^^
    |
    = note: `LearningParameters` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `from`, `msg_type`, and `timestamp` are never read
   --> src/orchestration/inference/joint_active_inference.rs:119:5
    |
117 | struct Message {
    |        ------- fields in this struct
118 |     /// Sender ID
119 |     from: usize,
    |     ^^^^
...
123 |     msg_type: MessageType,
    |     ^^^^^^^^
...
127 |     timestamp: f64,
    |     ^^^^^^^^^
    |
    = note: `Message` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `PolicyProposal`, `ObservationReport`, `CoordinationRequest`, and `ConsensusVote` are never constructed
   --> src/orchestration/inference/joint_active_inference.rs:133:5
    |
131 | enum MessageType {
    |      ----------- variants in this enum
132 |     BeliefUpdate,
133 |     PolicyProposal,
    |     ^^^^^^^^^^^^^^
134 |     ObservationReport,
    |     ^^^^^^^^^^^^^^^^^
135 |     CoordinationRequest,
    |     ^^^^^^^^^^^^^^^^^^^
136 |     ConsensusVote,
    |     ^^^^^^^^^^^^^
    |
    = note: `MessageType` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Policy`, `Observation`, `Coordination`, and `Vote` are never constructed
   --> src/orchestration/inference/joint_active_inference.rs:142:5
    |
140 | enum MessageContent {
    |      -------------- variants in this enum
141 |     Belief(DVector<f64>),
142 |     Policy(Vec<f64>),
    |     ^^^^^^
143 |     Observation(DVector<f64>),
    |     ^^^^^^^^^^^
144 |     Coordination(CoordinationData),
    |     ^^^^^^^^^^^^
145 |     Vote(f64),
    |     ^^^^
    |
    = note: `MessageContent` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `action_proposal`, `expected_outcome`, and `confidence` are never read
   --> src/orchestration/inference/joint_active_inference.rs:150:5
    |
149 | struct CoordinationData {
    |        ---------------- fields in this struct
150 |     action_proposal: DVector<f64>,
    |     ^^^^^^^^^^^^^^^
151 |     expected_outcome: DVector<f64>,
    |     ^^^^^^^^^^^^^^^^
152 |     confidence: f64,
    |     ^^^^^^^^^^
    |
    = note: `CoordinationData` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `global_states`, `joint_dynamics`, and `shared_priors` are never read
   --> src/orchestration/inference/joint_active_inference.rs:159:5
    |
157 | struct SharedGenerativeModel {
    |        --------------------- fields in this struct
158 |     /// Global state space
159 |     global_states: DMatrix<f64>,
    |     ^^^^^^^^^^^^^
160 |     /// Joint transition dynamics
161 |     joint_dynamics: JointDynamics,
    |     ^^^^^^^^^^^^^^
162 |     /// Shared priors
163 |     shared_priors: SharedPriors,
    |     ^^^^^^^^^^^^^
    |
    = note: `SharedGenerativeModel` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `T`, `I`, and `nonlinear` are never read
   --> src/orchestration/inference/joint_active_inference.rs:173:5
    |
171 | struct JointDynamics {
    |        ------------- fields in this struct
172 |     /// Joint state transition
173 |     T: DMatrix<f64>,
    |     ^
174 |     /// Interaction terms
175 |     I: DMatrix<f64>,
    |     ^
176 |     /// Nonlinear coupling
177 |     nonlinear: NonlinearCoupling,
    |     ^^^^^^^^^
    |
    = note: `JointDynamics` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `f` and `J` are never read
   --> src/orchestration/inference/joint_active_inference.rs:183:5
    |
181 | struct NonlinearCoupling {
    |        ----------------- fields in this struct
182 |     /// Coupling function
183 |     f: fn(&DVector<f64>, &DVector<f64>) -> DVector<f64>,
    |     ^
184 |     /// Jacobian
185 |     J: DMatrix<f64>,
    |     ^
    |
    = note: `NonlinearCoupling` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `goals`, `constraints`, and `prior_cov` are never read
   --> src/orchestration/inference/joint_active_inference.rs:191:5
    |
189 | struct SharedPriors {
    |        ------------ fields in this struct
190 |     /// Shared goals
191 |     goals: DVector<f64>,
    |     ^^^^^
192 |     /// Common constraints
193 |     constraints: Vec<Constraint>,
    |     ^^^^^^^^^^^
194 |     /// Prior covariance
195 |     prior_cov: DMatrix<f64>,
    |     ^^^^^^^^^
    |
    = note: `SharedPriors` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `constraint_type` and `value` are never read
   --> src/orchestration/inference/joint_active_inference.rs:201:5
    |
199 | struct Constraint {
    |        ---------- fields in this struct
200 |     /// Constraint type
201 |     constraint_type: ConstraintType,
    |     ^^^^^^^^^^^^^^^
202 |     /// Constraint value
203 |     value: f64,
    |     ^^^^^
    |
    = note: `Constraint` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Equality`, `Inequality`, and `Boundary` are never constructed
   --> src/orchestration/inference/joint_active_inference.rs:208:5
    |
207 | enum ConstraintType {
    |      -------------- variants in this enum
208 |     Equality,
    |     ^^^^^^^^
209 |     Inequality,
    |     ^^^^^^^^^^
210 |     Boundary,
    |     ^^^^^^^^
    |
    = note: `ConstraintType` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `delays` and `adaptive` are never read
   --> src/orchestration/inference/joint_active_inference.rs:218:5
    |
214 | struct CouplingMatrix {
    |        -------------- fields in this struct
...
218 |     delays: DMatrix<usize>,
    |     ^^^^^^
219 |     /// Adaptive coupling
220 |     adaptive: bool,
    |     ^^^^^^^^
    |
    = note: `CouplingMatrix` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `state`, `emergence`, and `stability` are never read
   --> src/orchestration/inference/joint_active_inference.rs:226:5
    |
224 | struct EmergentState {
    |        ------------- fields in this struct
225 |     /// State vector
226 |     state: DVector<f64>,
    |     ^^^^^
227 |     /// Emergence measure
228 |     emergence: f64,
    |     ^^^^^^^^^
229 |     /// Stability
230 |     stability: f64,
    |     ^^^^^^^^^
    |
    = note: `EmergentState` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `encoding` is never read
   --> src/orchestration/inference/joint_active_inference.rs:241:5
    |
235 | struct CommunicationProtocol {
    |        --------------------- field in this struct
...
241 |     encoding: MessageEncoding,
    |     ^^^^^^^^
    |
    = note: `CommunicationProtocol` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Ring`, `Star`, `Hierarchical`, `SmallWorld`, and `Dynamic` are never constructed
   --> src/orchestration/inference/joint_active_inference.rs:249:5
    |
247 | enum CommunicationTopology {
    |      --------------------- variants in this enum
248 |     FullyConnected,
249 |     Ring,
    |     ^^^^
250 |     Star,
    |     ^^^^
251 |     Hierarchical,
    |     ^^^^^^^^^^^^
252 |     SmallWorld,
    |     ^^^^^^^^^^
253 |     Dynamic,
    |     ^^^^^^^
    |
    = note: `CommunicationTopology` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `max_size` is never read
   --> src/orchestration/inference/joint_active_inference.rs:261:5
    |
257 | struct BandwidthLimits {
    |        --------------- field in this struct
...
261 |     max_size: usize,
    |     ^^^^^^^^
    |
    = note: `BandwidthLimits` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Uniform` and `Exponential` are never constructed
   --> src/orchestration/inference/joint_active_inference.rs:269:5
    |
267 | enum DelayDistribution {
    |      ----------------- variants in this enum
268 |     Constant(f64),
269 |     Uniform(f64, f64),
    |     ^^^^^^^
270 |     Exponential(f64),
    |     ^^^^^^^^^^^
    |
    = note: `DelayDistribution` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Sparse`, `Compressed`, and `Hierarchical` are never constructed
   --> src/orchestration/inference/joint_active_inference.rs:276:5
    |
274 | enum MessageEncoding {
    |      --------------- variants in this enum
275 |     Dense,
276 |     Sparse,
    |     ^^^^^^
277 |     Compressed,
    |     ^^^^^^^^^^
278 |     Hierarchical,
    |     ^^^^^^^^^^^^
    |
    = note: `MessageEncoding` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `max_retries` is never read
   --> src/orchestration/inference/joint_active_inference.rs:288:5
    |
282 | struct ReliabilityParams {
    |        ----------------- field in this struct
...
288 |     max_retries: usize,
    |     ^^^^^^^^^^^
    |
    = note: `ReliabilityParams` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `synchronization` and `commitment` are never read
   --> src/orchestration/inference/joint_active_inference.rs:297:5
    |
293 | struct CoordinationMechanism {
    |        --------------------- fields in this struct
...
297 |     synchronization: SynchronizationMethod,
    |     ^^^^^^^^^^^^^^^
...
301 |     commitment: CommitmentProtocol,
    |     ^^^^^^^^^^
    |
    = note: `CoordinationMechanism` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Averaging`, `Voting`, `Raft`, and `PBFT` are never constructed
   --> src/orchestration/inference/joint_active_inference.rs:306:5
    |
305 | enum ConsensusAlgorithm {
    |      ------------------ variants in this enum
306 |     Averaging,
    |     ^^^^^^^^^
307 |     Voting,
    |     ^^^^^^
308 |     ByzantineAgreement,
309 |     Raft,
    |     ^^^^
310 |     PBFT,
    |     ^^^^
    |
    = note: `ConsensusAlgorithm` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Synchronous`, `Asynchronous`, and `EventDriven` are never constructed
   --> src/orchestration/inference/joint_active_inference.rs:315:5
    |
314 | enum SynchronizationMethod {
    |      --------------------- variants in this enum
315 |     Synchronous,
    |     ^^^^^^^^^^^
316 |     Asynchronous,
    |     ^^^^^^^^^^^^
317 |     PartiallySynchronous,
318 |     EventDriven,
    |     ^^^^^^^^^^^
    |
    = note: `SynchronizationMethod` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Priority`, `Arbitration`, and `RandomSelection` are never constructed
   --> src/orchestration/inference/joint_active_inference.rs:323:5
    |
322 | enum ConflictResolution {
    |      ------------------ variants in this enum
323 |     Priority,
    |     ^^^^^^^^
324 |     Negotiation,
325 |     Arbitration,
    |     ^^^^^^^^^^^
326 |     RandomSelection,
    |     ^^^^^^^^^^^^^^^
    |
    = note: `ConflictResolution` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `two_phase`, `timeout`, and `rollback` are never read
   --> src/orchestration/inference/joint_active_inference.rs:332:5
    |
330 | struct CommitmentProtocol {
    |        ------------------ fields in this struct
331 |     /// Two-phase commit
332 |     two_phase: bool,
    |     ^^^^^^^^^
333 |     /// Timeout for commitment
334 |     timeout: f64,
    |     ^^^^^^^
335 |     /// Rollback mechanism
336 |     rollback: bool,
    |     ^^^^^^^^
    |
    = note: `CommitmentProtocol` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `time`, `order_before`, and `critical_point` are never read
   --> src/orchestration/inference/joint_active_inference.rs:372:5
    |
370 | struct PhaseTransition {
    |        --------------- fields in this struct
371 |     /// Time of transition
372 |     time: f64,
    |     ^^^^
373 |     /// Order parameter before
374 |     order_before: f64,
    |     ^^^^^^^^^^^^
...
378 |     critical_point: f64,
    |     ^^^^^^^^^^^^^^
    |
    = note: `PhaseTransition` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `pattern_type`, `spatial`, `temporal`, and `stability` are never read
   --> src/orchestration/inference/joint_active_inference.rs:384:5
    |
382 | struct EmergentPattern {
    |        --------------- fields in this struct
383 |     /// Pattern type
384 |     pattern_type: PatternType,
    |     ^^^^^^^^^^^^
385 |     /// Spatial configuration
386 |     spatial: DMatrix<f64>,
    |     ^^^^^^^
387 |     /// Temporal dynamics
388 |     temporal: Vec<f64>,
    |     ^^^^^^^^
389 |     /// Stability measure
390 |     stability: f64,
    |     ^^^^^^^^^
    |
    = note: `EmergentPattern` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Clustering`, `WaveFormation`, and `Differentiation` are never constructed
   --> src/orchestration/inference/joint_active_inference.rs:396:5
    |
394 | enum PatternType {
    |      ----------- variants in this enum
395 |     Synchronization,
396 |     Clustering,
    |     ^^^^^^^^^^
397 |     WaveFormation,
    |     ^^^^^^^^^^^^^
398 |     Consensus,
399 |     Differentiation,
    |     ^^^^^^^^^^^^^^^
    |
    = note: `PatternType` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `individual_spaces`, `joint_actions`, and `pareto_frontier` are never read
   --> src/orchestration/inference/joint_active_inference.rs:406:5
    |
404 | struct JointActionSpace {
    |        ---------------- fields in this struct
405 |     /// Individual action spaces
406 |     individual_spaces: Vec<ActionSpace>,
    |     ^^^^^^^^^^^^^^^^^
407 |     /// Joint action combinations
408 |     joint_actions: Vec<JointAction>,
    |     ^^^^^^^^^^^^^
...
412 |     pareto_frontier: Vec<JointAction>,
    |     ^^^^^^^^^^^^^^^
    |
    = note: `JointActionSpace` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `discrete`, `continuous`, and `mixed` are never read
   --> src/orchestration/inference/joint_active_inference.rs:418:5
    |
416 | struct ActionSpace {
    |        ----------- fields in this struct
417 |     /// Discrete actions
418 |     discrete: Vec<usize>,
    |     ^^^^^^^^
419 |     /// Continuous actions
420 |     continuous: DVector<f64>,
    |     ^^^^^^^^^^
421 |     /// Mixed actions
422 |     mixed: MixedAction,
    |     ^^^^^
    |
    = note: `ActionSpace` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `discrete_part` and `continuous_part` are never read
   --> src/orchestration/inference/joint_active_inference.rs:427:5
    |
426 | struct MixedAction {
    |        ----------- fields in this struct
427 |     discrete_part: usize,
    |     ^^^^^^^^^^^^^
428 |     continuous_part: DVector<f64>,
    |     ^^^^^^^^^^^^^^^
    |
    = note: `MixedAction` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `actions`, `expected_outcome`, `utility`, and `feasible` are never read
   --> src/orchestration/inference/joint_active_inference.rs:434:5
    |
432 | struct JointAction {
    |        ----------- fields in this struct
433 |     /// Actions for each agent
434 |     actions: Vec<DVector<f64>>,
    |     ^^^^^^^
435 |     /// Expected joint outcome
436 |     expected_outcome: DVector<f64>,
    |     ^^^^^^^^^^^^^^^^
437 |     /// Joint utility
438 |     utility: f64,
    |     ^^^^^^^
439 |     /// Feasibility
440 |     feasible: bool,
    |     ^^^^^^^^
    |
    = note: `JointAction` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `agents` and `constraint_fn` are never read
   --> src/orchestration/inference/joint_active_inference.rs:446:5
    |
444 | struct CoordinationConstraint {
    |        ---------------------- fields in this struct
445 |     /// Agents involved
446 |     agents: Vec<usize>,
    |     ^^^^^^
447 |     /// Constraint function
448 |     constraint_fn: fn(&[DVector<f64>]) -> bool,
    |     ^^^^^^^^^^^^^
    |
    = note: `CoordinationConstraint` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `expected_value` and `coordination_cost` are never read
    --> src/orchestration/inference/joint_active_inference.rs:1534:5
     |
1532 | struct JointPolicy {
     |        ----------- fields in this struct
1533 |     agent_policies: Vec<AgentPolicy>,
1534 |     expected_value: f64,
     |     ^^^^^^^^^^^^^^
1535 |     coordination_cost: f64,
     |     ^^^^^^^^^^^^^^^^^
     |
     = note: `JointPolicy` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `original` is never read
  --> src/orchestration/causality/bidirectional_causality.rs:54:5
   |
50 | struct ShadowManifold {
   |        -------------- field in this struct
...
54 |     original: DVector<f64>,
   |     ^^^^^^^^
   |
   = note: `ShadowManifold` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `FixedWidth`, `KernelDensity`, and `Symbolic` are never constructed
  --> src/orchestration/causality/bidirectional_causality.rs:80:5
   |
79 | enum BinningMethod {
   |      ------------- variants in this enum
80 |     FixedWidth(usize),
   |     ^^^^^^^^^^
81 |     Adaptive,
82 |     KernelDensity,
   |     ^^^^^^^^^^^^^
83 |     Symbolic,
   |     ^^^^^^^^
   |
   = note: `BinningMethod` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `alpha`, `use_var`, `spectral`, and `conditional_vars` are never read
   --> src/orchestration/causality/bidirectional_causality.rs:92:5
    |
 88 | struct GrangerCausalityTester {
    |        ---------------------- fields in this struct
...
 92 |     alpha: f64,
    |     ^^^^^
 93 |     /// Use VAR model
 94 |     use_var: bool,
    |     ^^^^^^^
...
 98 |     spectral: bool,
    |     ^^^^^^^^
 99 |     /// Conditional Granger causality
100 |     conditional_vars: Vec<String>,
    |     ^^^^^^^^^^^^^^^^
    |
    = note: `GrangerCausalityTester` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `d_separation_cache` and `backdoor_paths` are never read
   --> src/orchestration/causality/bidirectional_causality.rs:113:5
    |
105 | struct CausalGraph {
    |        ----------- fields in this struct
...
113 |     d_separation_cache: HashMap<(usize, usize, HashSet<usize>), bool>,
    |     ^^^^^^^^^^^^^^^^^^
114 |     /// Backdoor paths
115 |     backdoor_paths: HashMap<(usize, usize), Vec<Vec<usize>>>,
    |     ^^^^^^^^^^^^^^
    |
    = note: `CausalGraph` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `node_type`, `observed`, and `intervened` are never read
   --> src/orchestration/causality/bidirectional_causality.rs:123:5
    |
119 | struct CausalNode {
    |        ---------- fields in this struct
...
123 |     node_type: NodeType,
    |     ^^^^^^^^^
124 |     /// Is observed
125 |     observed: bool,
    |     ^^^^^^^^
126 |     /// Intervention state
127 |     intervened: Option<f64>,
    |     ^^^^^^^^^^
    |
    = note: `CausalNode` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Latent`, `Confounder`, `Mediator`, and `Collider` are never constructed
   --> src/orchestration/causality/bidirectional_causality.rs:133:5
    |
131 | enum NodeType {
    |      -------- variants in this enum
132 |     Observed,
133 |     Latent,
    |     ^^^^^^
134 |     Confounder,
    |     ^^^^^^^^^^
135 |     Mediator,
    |     ^^^^^^^^
136 |     Collider,
    |     ^^^^^^^^
    |
    = note: `NodeType` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `strength`, `edge_type`, and `lag` are never read
   --> src/orchestration/causality/bidirectional_causality.rs:142:5
    |
140 | struct CausalEdge {
    |        ---------- fields in this struct
141 |     /// Edge strength
142 |     strength: f64,
    |     ^^^^^^^^
143 |     /// Edge type
144 |     edge_type: EdgeType,
    |     ^^^^^^^^^
145 |     /// Time lag
146 |     lag: usize,
    |     ^^^
    |
    = note: `CausalEdge` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variant `TimeDelayed` is never constructed
   --> src/orchestration/causality/bidirectional_causality.rs:154:5
    |
150 | enum EdgeType {
    |      -------- variant in this enum
...
154 |     TimeDelayed,
    |     ^^^^^^^^^^^
    |
    = note: `EdgeType` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `conflict_resolution` is never read
   --> src/orchestration/causality/bidirectional_causality.rs:169:5
    |
159 | struct PCAlgorithm {
    |        ----------- field in this struct
...
169 |     conflict_resolution: ConflictResolution,
    |     ^^^^^^^^^^^^^^^^^^^
    |
    = note: `PCAlgorithm` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `PartialCorrelation`, `MutualInformation`, and `KernelCIT` are never constructed
   --> src/orchestration/causality/bidirectional_causality.rs:174:5
    |
173 | enum IndependenceTest {
    |      ---------------- variants in this enum
174 |     PartialCorrelation,
    |     ^^^^^^^^^^^^^^^^^^
175 |     MutualInformation,
    |     ^^^^^^^^^^^^^^^^^
176 |     HSIC,  // Hilbert-Schmidt Independence Criterion
177 |     KernelCIT,  // Kernel Conditional Independence Test
    |     ^^^^^^^^^
    |
    = note: `IndependenceTest` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variant `ConservativeOrientation` is never constructed
   --> src/orchestration/causality/bidirectional_causality.rs:184:5
    |
181 | enum OrientationRule {
    |      --------------- variant in this enum
...
184 |     ConservativeOrientation,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: `OrientationRule` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Conservative`, `Majority`, and `MaxStrength` are never constructed
   --> src/orchestration/causality/bidirectional_causality.rs:190:5
    |
189 | enum ConflictResolution {
    |      ------------------ variants in this enum
190 |     Conservative,
    |     ^^^^^^^^^^^^
191 |     Majority,
    |     ^^^^^^^^
192 |     MaxStrength,
    |     ^^^^^^^^^^^
    |
    = note: `ConflictResolution` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `RandomShuffle`, `PhaseRandomization`, and `TwinSurrogates` are never constructed
   --> src/orchestration/causality/bidirectional_causality.rs:215:5
    |
214 | enum SurrogateMethod {
    |      --------------- variants in this enum
215 |     RandomShuffle,
    |     ^^^^^^^^^^^^^
216 |     PhaseRandomization,
    |     ^^^^^^^^^^^^^^^^^^
217 |     IAAFT,  // Iterative Amplitude Adjusted Fourier Transform
218 |     TwinSurrogates,
    |     ^^^^^^^^^^^^^^
    |
    = note: `SurrogateMethod` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `None`, `Bonferroni`, and `BenjaminiYekutieli` are never constructed
   --> src/orchestration/causality/bidirectional_causality.rs:223:5
    |
222 | enum MultipleTestingCorrection {
    |      ------------------------- variants in this enum
223 |     None,
    |     ^^^^
224 |     Bonferroni,
    |     ^^^^^^^^^^
225 |     BenjaminiHochberg,
226 |     BenjaminiYekutieli,
    |     ^^^^^^^^^^^^^^^^^^
    |
    = note: `MultipleTestingCorrection` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `sampling_rate` and `capacity` are never read
   --> src/orchestration/causality/bidirectional_causality.rs:235:5
    |
231 | struct TimeSeriesBuffer {
    |        ---------------- fields in this struct
...
235 |     sampling_rate: f64,
    |     ^^^^^^^^^^^^^
236 |     /// Buffer capacity
237 |     capacity: usize,
    |     ^^^^^^^^
    |
    = note: `TimeSeriesBuffer` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `p_value`, `adjusted_p`, and `significant` are never read
    --> src/orchestration/causality/bidirectional_causality.rs:1788:5
     |
1787 | struct SignificanceResult {
     |        ------------------ fields in this struct
1788 |     p_value: f64,
     |     ^^^^^^^
1789 |     adjusted_p: f64,
     |     ^^^^^^^^^^
1790 |     significant: bool,
     |     ^^^^^^^^^^^
     |
     = note: `SignificanceResult` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `channels` and `multipartite` are never read
  --> src/orchestration/quantum/quantum_entanglement_measures.rs:24:5
   |
14 | pub struct QuantumEntanglementAnalyzer {
   |            --------------------------- fields in this struct
...
24 |     channels: QuantumChannels,
   |     ^^^^^^^^
...
28 |     multipartite: MultipartiteEntanglement,
   |     ^^^^^^^^^^^^

warning: field `eigenvectors` is never read
  --> src/orchestration/quantum/quantum_entanglement_measures.rs:45:5
   |
33 | struct DensityMatrixHandler {
   |        -------------------- field in this struct
...
45 |     eigenvectors: DMatrix<Complex64>,
   |     ^^^^^^^^^^^^
   |
   = note: `DensityMatrixHandler` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `squashed`, `formation`, and `distillable` are never read
  --> src/orchestration/quantum/quantum_entanglement_measures.rs:58:5
   |
50 | struct EntanglementMeasures {
   |        -------------------- fields in this struct
...
58 |     squashed: SquashedEntanglement,
   |     ^^^^^^^^
59 |     /// Entanglement of formation
60 |     formation: EntanglementOfFormation,
   |     ^^^^^^^^^
61 |     /// Distillable entanglement
62 |     distillable: DistillableEntanglement,
   |     ^^^^^^^^^^^
   |
   = note: `EntanglementMeasures` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `magic_basis` is never read
  --> src/orchestration/quantum/quantum_entanglement_measures.rs:74:5
   |
68 | struct ConcurrenceMeasure {
   |        ------------------ field in this struct
...
74 |     magic_basis: DMatrix<Complex64>,
   |     ^^^^^^^^^^^
   |
   = note: `ConcurrenceMeasure` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `iterations` is never read
  --> src/orchestration/quantum/quantum_entanglement_measures.rs:96:5
   |
90 | struct RelativeEntropyMeasure {
   |        ---------------------- field in this struct
...
96 |     iterations: usize,
   |     ^^^^^^^^^^
   |
   = note: `RelativeEntropyMeasure` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `value`, `cmi`, and `extension_dim` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:102:5
    |
100 | struct SquashedEntanglement {
    |        -------------------- fields in this struct
101 |     /// Squashed entanglement value
102 |     value: f64,
    |     ^^^^^
103 |     /// Conditional mutual information
104 |     cmi: f64,
    |     ^^^
105 |     /// Extension dimension
106 |     extension_dim: usize,
    |     ^^^^^^^^^^^^^
    |
    = note: `SquashedEntanglement` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `value`, `decomposition`, and `convex_roof` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:112:5
    |
110 | struct EntanglementOfFormation {
    |        ----------------------- fields in this struct
111 |     /// EOF value
112 |     value: f64,
    |     ^^^^^
113 |     /// Optimal decomposition
114 |     decomposition: Vec<(f64, DMatrix<Complex64>)>,
    |     ^^^^^^^^^^^^^
115 |     /// Convex roof
116 |     convex_roof: f64,
    |     ^^^^^^^^^^^
    |
    = note: `EntanglementOfFormation` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `rate`, `efficiency`, and `fidelity` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:122:5
    |
120 | struct DistillableEntanglement {
    |        ----------------------- fields in this struct
121 |     /// Distillable entanglement rate
122 |     rate: f64,
    |     ^^^^
123 |     /// Protocol efficiency
124 |     efficiency: f64,
    |     ^^^^^^^^^^
125 |     /// Fidelity after distillation
126 |     fidelity: f64,
    |     ^^^^^^^^
    |
    = note: `DistillableEntanglement` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `monotone` and `additive` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:134:5
    |
130 | struct LogarithmicNegativity {
    |        --------------------- fields in this struct
...
134 |     monotone: bool,
    |     ^^^^^^^^
135 |     /// Additivity satisfied
136 |     additive: bool,
    |     ^^^^^^^^
    |
    = note: `LogarithmicNegativity` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `geometric_discord`, `mid`, `deficit`, and `work_deficit` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:145:5
    |
141 | struct QuantumCorrelations {
    |        ------------------- fields in this struct
...
145 |     geometric_discord: GeometricDiscord,
    |     ^^^^^^^^^^^^^^^^^
146 |     /// Measurement-induced disturbance
147 |     mid: MeasurementInducedDisturbance,
    |     ^^^
148 |     /// Quantum deficit
149 |     deficit: QuantumDeficit,
    |     ^^^^^^^
150 |     /// One-way work deficit
151 |     work_deficit: OneWayWorkDeficit,
    |     ^^^^^^^^^^^^
    |
    = note: `QuantumCorrelations` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `value`, `closest_classical`, and `hs_distance` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:169:5
    |
167 | struct GeometricDiscord {
    |        ---------------- fields in this struct
168 |     /// Geometric discord value
169 |     value: f64,
    |     ^^^^^
170 |     /// Closest classical state
171 |     closest_classical: DMatrix<Complex64>,
    |     ^^^^^^^^^^^^^^^^^
172 |     /// Hilbert-Schmidt distance
173 |     hs_distance: f64,
    |     ^^^^^^^^^^^
    |
    = note: `GeometricDiscord` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `value`, `pre_state`, and `post_state` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:179:5
    |
177 | struct MeasurementInducedDisturbance {
    |        ----------------------------- fields in this struct
178 |     /// MID value
179 |     value: f64,
    |     ^^^^^
180 |     /// Pre-measurement state
181 |     pre_state: DMatrix<Complex64>,
    |     ^^^^^^^^^
182 |     /// Post-measurement state
183 |     post_state: DMatrix<Complex64>,
    |     ^^^^^^^^^^
    |
    = note: `MeasurementInducedDisturbance` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `value`, `zero_way`, and `one_way` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:189:5
    |
187 | struct QuantumDeficit {
    |        -------------- fields in this struct
188 |     /// Deficit value
189 |     value: f64,
    |     ^^^^^
190 |     /// Zero-way deficit
191 |     zero_way: f64,
    |     ^^^^^^^^
192 |     /// One-way deficit
193 |     one_way: f64,
    |     ^^^^^^^
    |
    = note: `QuantumDeficit` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `value`, `extractable_work`, and `thermal_state` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:199:5
    |
197 | struct OneWayWorkDeficit {
    |        ----------------- fields in this struct
198 |     /// Work deficit value
199 |     value: f64,
    |     ^^^^^
200 |     /// Extractable work
201 |     extractable_work: f64,
    |     ^^^^^^^^^^^^^^^^
202 |     /// Thermal state
203 |     thermal_state: DMatrix<Complex64>,
    |     ^^^^^^^^^^^^^
    |
    = note: `OneWayWorkDeficit` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `nonlinear`, `optimal`, and `decomposition` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:212:5
    |
208 | struct EntanglementWitnesses {
    |        --------------------- fields in this struct
...
212 |     nonlinear: Vec<NonlinearWitness>,
    |     ^^^^^^^^^
213 |     /// Optimal witness
214 |     optimal: OptimalWitness,
    |     ^^^^^^^
215 |     /// Witness decomposition
216 |     decomposition: WitnessDecomposition,
    |     ^^^^^^^^^^^^^
    |
    = note: `EntanglementWitnesses` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `W`, `expectation`, `threshold`, and `detected` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:222:5
    |
220 | struct LinearWitness {
    |        ------------- fields in this struct
221 |     /// Witness operator
222 |     W: DMatrix<Complex64>,
    |     ^
223 |     /// Expectation value
224 |     expectation: f64,
    |     ^^^^^^^^^^^
225 |     /// Detection threshold
226 |     threshold: f64,
    |     ^^^^^^^^^
227 |     /// Detected entanglement
228 |     detected: bool,
    |     ^^^^^^^^
    |
    = note: `LinearWitness` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `witness_fn`, `value`, and `separable_bound` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:234:5
    |
232 | struct NonlinearWitness {
    |        ---------------- fields in this struct
233 |     /// Witness function
234 |     witness_fn: fn(&DMatrix<Complex64>) -> f64,
    |     ^^^^^^^^^^
235 |     /// Value for current state
236 |     value: f64,
    |     ^^^^^
237 |     /// Separable bound
238 |     separable_bound: f64,
    |     ^^^^^^^^^^^^^^^
    |
    = note: `NonlinearWitness` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `W_opt`, `method`, and `strength` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:244:5
    |
242 | struct OptimalWitness {
    |        -------------- fields in this struct
243 |     /// Optimal witness operator
244 |     W_opt: DMatrix<Complex64>,
    |     ^^^^^
245 |     /// Optimization method used
246 |     method: OptimizationMethod,
    |     ^^^^^^
247 |     /// Witness strength
248 |     strength: f64,
    |     ^^^^^^^^
    |
    = note: `OptimalWitness` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `GradientDescent`, `GeneticAlgorithm`, and `ConvexOptimization` are never constructed
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:254:5
    |
252 | enum OptimizationMethod {
    |      ------------------ variants in this enum
253 |     SDP,  // Semidefinite programming
254 |     GradientDescent,
    |     ^^^^^^^^^^^^^^^
255 |     GeneticAlgorithm,
    |     ^^^^^^^^^^^^^^^^
256 |     ConvexOptimization,
    |     ^^^^^^^^^^^^^^^^^^
    |
    = note: `OptimizationMethod` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `positive`, `negative`, and `error` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:262:5
    |
260 | struct WitnessDecomposition {
    |        -------------------- fields in this struct
261 |     /// Positive part
262 |     positive: DMatrix<Complex64>,
    |     ^^^^^^^^
263 |     /// Negative part
264 |     negative: DMatrix<Complex64>,
    |     ^^^^^^^^
265 |     /// Decomposition error
266 |     error: f64,
    |     ^^^^^
    |
    = note: `WitnessDecomposition` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `depolarizing`, `amplitude_damping`, `phase_damping`, `entanglement_breaking`, and `locc` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:273:5
    |
271 | struct QuantumChannels {
    |        --------------- fields in this struct
272 |     /// Depolarizing channel
273 |     depolarizing: DepolarizingChannel,
    |     ^^^^^^^^^^^^
274 |     /// Amplitude damping
275 |     amplitude_damping: AmplitudeDampingChannel,
    |     ^^^^^^^^^^^^^^^^^
276 |     /// Phase damping
277 |     phase_damping: PhaseDampingChannel,
    |     ^^^^^^^^^^^^^
278 |     /// Entanglement breaking channels
279 |     entanglement_breaking: EntanglementBreakingChannel,
    |     ^^^^^^^^^^^^^^^^^^^^^
280 |     /// LOCC operations
281 |     locc: LOCCOperations,
    |     ^^^^
    |
    = note: `QuantumChannels` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `p`, `kraus`, and `capacity` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:287:5
    |
285 | struct DepolarizingChannel {
    |        ------------------- fields in this struct
286 |     /// Depolarizing probability
287 |     p: f64,
    |     ^
288 |     /// Kraus operators
289 |     kraus: Vec<DMatrix<Complex64>>,
    |     ^^^^^
290 |     /// Channel capacity
291 |     capacity: f64,
    |     ^^^^^^^^
    |
    = note: `DepolarizingChannel` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `gamma`, `kraus`, and `steady_state` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:297:5
    |
295 | struct AmplitudeDampingChannel {
    |        ----------------------- fields in this struct
296 |     /// Damping parameter
297 |     gamma: f64,
    |     ^^^^^
298 |     /// Kraus operators
299 |     kraus: Vec<DMatrix<Complex64>>,
    |     ^^^^^
300 |     /// Steady state
301 |     steady_state: DMatrix<Complex64>,
    |     ^^^^^^^^^^^^
    |
    = note: `AmplitudeDampingChannel` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `lambda`, `kraus`, and `t2` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:307:5
    |
305 | struct PhaseDampingChannel {
    |        ------------------- fields in this struct
306 |     /// Dephasing rate
307 |     lambda: f64,
    |     ^^^^^^
308 |     /// Kraus operators
309 |     kraus: Vec<DMatrix<Complex64>>,
    |     ^^^^^
310 |     /// Decoherence time
311 |     t2: f64,
    |     ^^
    |
    = note: `PhaseDampingChannel` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `p_break`, `measurement_basis`, and `preparation_states` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:317:5
    |
315 | struct EntanglementBreakingChannel {
    |        --------------------------- fields in this struct
316 |     /// Breaking probability
317 |     p_break: f64,
    |     ^^^^^^^
318 |     /// Measurement basis
319 |     measurement_basis: DMatrix<Complex64>,
    |     ^^^^^^^^^^^^^^^^^
320 |     /// Preparation states
321 |     preparation_states: Vec<DMatrix<Complex64>>,
    |     ^^^^^^^^^^^^^^^^^^
    |
    = note: `EntanglementBreakingChannel` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `local_ops`, `comm_rounds`, and `success_prob` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:327:5
    |
325 | struct LOCCOperations {
    |        -------------- fields in this struct
326 |     /// Local operations
327 |     local_ops: Vec<LocalOperation>,
    |     ^^^^^^^^^
328 |     /// Classical communication rounds
329 |     comm_rounds: usize,
    |     ^^^^^^^^^^^
330 |     /// Success probability
331 |     success_prob: f64,
    |     ^^^^^^^^^^^^
    |
    = note: `LOCCOperations` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `party`, `operation`, and `probability` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:337:5
    |
335 | struct LocalOperation {
    |        -------------- fields in this struct
336 |     /// Party index
337 |     party: usize,
    |     ^^^^^
338 |     /// Operation
339 |     operation: DMatrix<Complex64>,
    |     ^^^^^^^^^
340 |     /// Probability
341 |     probability: f64,
    |     ^^^^^^^^^^^
    |
    = note: `LocalOperation` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `sudden_death`, `oscillations`, and `asymptotic` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:350:5
    |
346 | struct EntanglementDynamics {
    |        -------------------- fields in this struct
...
350 |     sudden_death: SuddenDeathBirth,
    |     ^^^^^^^^^^^^
351 |     /// Entanglement oscillations
352 |     oscillations: EntanglementOscillations,
    |     ^^^^^^^^^^^^
353 |     /// Asymptotic entanglement
354 |     asymptotic: AsymptoticEntanglement,
    |     ^^^^^^^^^^
    |
    = note: `EntanglementDynamics` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `H` is never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:360:5
    |
358 | struct TimeEvolution {
    |        ------------- field in this struct
359 |     /// Hamiltonian
360 |     H: DMatrix<Complex64>,
    |     ^
    |
    = note: `TimeEvolution` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `death_times`, `birth_times`, `dark_periods`, and `revival_amplitude` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:372:5
    |
370 | struct SuddenDeathBirth {
    |        ---------------- fields in this struct
371 |     /// Death times
372 |     death_times: Vec<f64>,
    |     ^^^^^^^^^^^
373 |     /// Birth times
374 |     birth_times: Vec<f64>,
    |     ^^^^^^^^^^^
375 |     /// Dark periods
376 |     dark_periods: Vec<(f64, f64)>,
    |     ^^^^^^^^^^^^
377 |     /// Revival amplitude
378 |     revival_amplitude: f64,
    |     ^^^^^^^^^^^^^^^^^
    |
    = note: `SuddenDeathBirth` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `frequency`, `amplitude`, `phase`, and `damping` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:384:5
    |
382 | struct EntanglementOscillations {
    |        ------------------------ fields in this struct
383 |     /// Oscillation frequency
384 |     frequency: f64,
    |     ^^^^^^^^^
385 |     /// Amplitude
386 |     amplitude: f64,
    |     ^^^^^^^^^
387 |     /// Phase
388 |     phase: f64,
    |     ^^^^^
389 |     /// Damping rate
390 |     damping: f64,
    |     ^^^^^^^
    |
    = note: `EntanglementOscillations` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `steady_state`, `convergence_rate`, and `equilibrium_time` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:396:5
    |
394 | struct AsymptoticEntanglement {
    |        ---------------------- fields in this struct
395 |     /// Steady state entanglement
396 |     steady_state: f64,
    |     ^^^^^^^^^^^^
397 |     /// Convergence rate
398 |     convergence_rate: f64,
    |     ^^^^^^^^^^^^^^^^
399 |     /// Equilibrium time
400 |     equilibrium_time: f64,
    |     ^^^^^^^^^^^^^^^^
    |
    = note: `AsymptoticEntanglement` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `ghz`, `w_state`, `cluster`, `graph`, and `gme` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:407:5
    |
405 | struct MultipartiteEntanglement {
    |        ------------------------ fields in this struct
406 |     /// GHZ state fidelity
407 |     ghz: GHZEntanglement,
    |     ^^^
408 |     /// W state entanglement
409 |     w_state: WStateEntanglement,
    |     ^^^^^^^
410 |     /// Cluster state entanglement
411 |     cluster: ClusterEntanglement,
    |     ^^^^^^^
412 |     /// Graph state entanglement
413 |     graph: GraphStateEntanglement,
    |     ^^^^^
414 |     /// Genuine multipartite entanglement
415 |     gme: GenuineMultipartiteEntanglement,
    |     ^^^
    |
    = note: `MultipartiteEntanglement` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `ghz_state`, `fidelity`, and `three_tangle` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:421:5
    |
419 | struct GHZEntanglement {
    |        --------------- fields in this struct
420 |     /// GHZ state
421 |     ghz_state: DMatrix<Complex64>,
    |     ^^^^^^^^^
422 |     /// Fidelity with ideal GHZ
423 |     fidelity: f64,
    |     ^^^^^^^^
424 |     /// Three-tangle
425 |     three_tangle: f64,
    |     ^^^^^^^^^^^^
    |
    = note: `GHZEntanglement` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `w_state`, `fidelity`, and `robustness` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:431:5
    |
429 | struct WStateEntanglement {
    |        ------------------ fields in this struct
430 |     /// W state
431 |     w_state: DMatrix<Complex64>,
    |     ^^^^^^^
432 |     /// Fidelity with ideal W
433 |     fidelity: f64,
    |     ^^^^^^^^
434 |     /// Robustness
435 |     robustness: f64,
    |     ^^^^^^^^^^
    |
    = note: `WStateEntanglement` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `cluster_state`, `stabilizers`, and `connectivity` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:441:5
    |
439 | struct ClusterEntanglement {
    |        ------------------- fields in this struct
440 |     /// Cluster state
441 |     cluster_state: DMatrix<Complex64>,
    |     ^^^^^^^^^^^^^
442 |     /// Stabilizers
443 |     stabilizers: Vec<DMatrix<Complex64>>,
    |     ^^^^^^^^^^^
444 |     /// Graph connectivity
445 |     connectivity: f64,
    |     ^^^^^^^^^^^^
    |
    = note: `ClusterEntanglement` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `adjacency`, `graph_state`, and `lc_equivalence` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:451:5
    |
449 | struct GraphStateEntanglement {
    |        ---------------------- fields in this struct
450 |     /// Graph adjacency matrix
451 |     adjacency: DMatrix<f64>,
    |     ^^^^^^^^^
452 |     /// Graph state
453 |     graph_state: DMatrix<Complex64>,
    |     ^^^^^^^^^^^
454 |     /// Local complementation equivalence
455 |     lc_equivalence: Vec<usize>,
    |     ^^^^^^^^^^^^^^
    |
    = note: `GraphStateEntanglement` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `gme_measure`, `biseparable`, and `k_separability` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:461:5
    |
459 | struct GenuineMultipartiteEntanglement {
    |        ------------------------------- fields in this struct
460 |     /// GME measure
461 |     gme_measure: f64,
    |     ^^^^^^^^^^^
462 |     /// Biseparability test
463 |     biseparable: bool,
    |     ^^^^^^^^^^^
464 |     /// k-separability
465 |     k_separability: usize,
    |     ^^^^^^^^^^^^^^
    |
    = note: `GenuineMultipartiteEntanglement` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `optimization_level` and `target_arch` are never read
  --> src/quantum_mlir/mod.rs:31:5
   |
27 | pub struct QuantumCompiler {
   |            --------------- fields in this struct
...
31 |     optimization_level: OptimizationLevel,
   |     ^^^^^^^^^^^^^^^^^^
32 |     /// Target GPU architecture
33 |     target_arch: GpuArchitecture,
   |     ^^^^^^^^^^^

warning: methods `build_mlir_module`, `optimize_module`, `lower_to_gpu`, and `generate_ptx` are never used
   --> src/quantum_mlir/mod.rs:127:8
    |
 66 | impl QuantumCompiler {
    | -------------------- methods in this implementation
...
127 |     fn build_mlir_module(&self, operations: &[QuantumOp]) -> Result<mlir::Module> {
    |        ^^^^^^^^^^^^^^^^^
...
156 |     fn optimize_module(&self, module: mlir::Module) -> Result<mlir::Module> {
    |        ^^^^^^^^^^^^^^^
...
193 |     fn lower_to_gpu(&self, module: mlir::Module) -> Result<mlir::Module> {
    |        ^^^^^^^^^^^^
...
200 |     fn generate_ptx(&self, module: mlir::Module) -> Result<String> {
    |        ^^^^^^^^^^^^

warning: field `high_precision` is never read
   --> src/quantum_mlir/mod.rs:283:5
    |
279 | pub struct CompiledQuantumKernel {
    |            --------------------- field in this struct
...
283 |     high_precision: bool,
    |     ^^^^^^^^^^^^^^

warning: methods `size`, `as_ptr`, and `as_mut_ptr` are never used
   --> src/quantum_mlir/mod.rs:345:8
    |
344 | impl QuantumState {
    | ----------------- methods in this implementation
345 |     fn size(&self) -> usize {
    |        ^^^^
...
349 |     fn as_ptr(&self) -> *const u8 {
    |        ^^^^^^
...
353 |     fn as_mut_ptr(&mut self) -> *mut u8 {
    |        ^^^^^^^^^^

warning: field `namespace` is never read
  --> src/quantum_mlir/dialect.rs:21:5
   |
19 | pub struct QuantumDialect {
   |            -------------- field in this struct
20 |     /// Dialect namespace
21 |     namespace: &'static str,
   |     ^^^^^^^^^

warning: fields `name`, `qubit`, and `target` are never read
  --> src/quantum_mlir/ops.rs:24:5
   |
23 | pub struct Operation {
   |            --------- fields in this struct
24 |     name: &'static str,
   |     ^^^^
25 |     qubit: usize,
   |     ^^^^^
26 |     target: Option<usize>,
   |     ^^^^^^

warning: field `target_arch` is never read
   --> src/quantum_mlir/passes.rs:136:5
    |
135 | pub struct LowerQuantumToGpu {
    |            ----------------- field in this struct
136 |     target_arch: super::GpuArchitecture,
    |     ^^^^^^^^^^^

warning: field `cuda_context` is never read
  --> src/gpu/gpu_enabled.rs:14:5
   |
13 | struct GpuState {
   |        -------- field in this struct
14 |     cuda_context: Option<Arc<CudaCompatContext>>,
   |     ^^^^^^^^^^^^

warning: fields `in_features` and `out_features` are never read
   --> src/gpu/gpu_enabled.rs:355:5
    |
352 | pub struct GpuLinear {
    |            --------- fields in this struct
...
355 |     in_features: usize,
    |     ^^^^^^^^^^^
356 |     out_features: usize,
    |     ^^^^^^^^^^^^

warning: method `convert_f16_to_f32_gpu` is never used
    --> src/gpu/kernel_executor.rs:3198:8
     |
1975 | impl GpuKernelExecutor {
     | ---------------------- method in this implementation
...
3198 |     fn convert_f16_to_f32_gpu(&self, data: &[u16]) -> Result<Vec<f32>> {
     |        ^^^^^^^^^^^^^^^^^^^^^^

warning: fields `size_bytes` and `timestamp_ns` are never read
   --> src/gpu/memory_pool.rs:154:5
    |
153 | struct AllocationRecord {
    |        ---------------- fields in this struct
154 |     size_bytes: usize,
    |     ^^^^^^^^^^
155 |     timestamp_ns: u64,
    |     ^^^^^^^^^^^^
    |
    = note: `AllocationRecord` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: fields `allocated_at` and `last_used` are never read
  --> src/gpu/active_memory_pool.rs:90:5
   |
87 | struct BufferMetadata {
   |        -------------- fields in this struct
...
90 |     allocated_at: u64,
   |     ^^^^^^^^^^^^
91 |     last_used: u64,
   |     ^^^^^^^^^
   |
   = note: `BufferMetadata` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `config` is never read
  --> src/gpu/kernel_autotuner.rs:44:5
   |
43 | struct ConfigPerformance {
   |        ----------------- field in this struct
44 |     config: LaunchConfig,
   |     ^^^^^^
   |
   = note: `ConfigPerformance` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: fields `context` and `device` are never read
   --> src/gpu/production_runtime.rs:137:5
    |
136 | pub struct ProductionGpuRuntime {
    |            -------------------- fields in this struct
137 |     context: usize,  // Store as usize for Send/Sync
    |     ^^^^^^^
138 |     device: i32,
    |     ^^^^^^

warning: function `cuDeviceGetCount` is never used
  --> src/gpu/production_runtime.rs:16:8
   |
16 |     fn cuDeviceGetCount(count: *mut i32) -> i32;
   |        ^^^^^^^^^^^^^^^^

warning: function `cuCtxSetCurrent` is never used
  --> src/gpu/production_runtime.rs:19:8
   |
19 |     fn cuCtxSetCurrent(ctx: *mut c_void) -> i32;
   |        ^^^^^^^^^^^^^^^

warning: function `cuMemcpyDtoD_v2` is never used
  --> src/gpu/production_runtime.rs:26:8
   |
26 |     fn cuMemcpyDtoD_v2(dst: u64, src: u64, bytesize: usize) -> i32;
   |        ^^^^^^^^^^^^^^^

warning: function `cuStreamCreate` is never used
  --> src/gpu/production_runtime.rs:46:8
   |
46 |     fn cuStreamCreate(stream: *mut *mut c_void, flags: u32) -> i32;
   |        ^^^^^^^^^^^^^^

warning: function `cuStreamSynchronize` is never used
  --> src/gpu/production_runtime.rs:47:8
   |
47 |     fn cuStreamSynchronize(stream: *mut c_void) -> i32;
   |        ^^^^^^^^^^^^^^^^^^^

warning: fields `device` and `max_simplices` are never read
   --> src/phase6/tda.rs:113:5
    |
110 | pub struct TdaAdapter {
    |            ---------- fields in this struct
...
113 |     device: Arc<()>,
    |     ^^^^^^
...
117 |     max_simplices: usize,
    |     ^^^^^^^^^^^^^

warning: field `max_dimension` is never read
   --> src/phase6/tda.rs:557:5
    |
554 | struct VietorisRipsComplex {
    |        ------------------- field in this struct
...
557 |     max_dimension: usize,
    |     ^^^^^^^^^^^^^

warning: fields `spectral_radius`, `generative_model`, and `prediction_history` are never read
   --> src/phase6/predictive_neuro.rs:87:5
    |
 83 | pub struct PredictiveNeuromorphic {
    |            ---------------------- fields in this struct
...
 87 |     spectral_radius: f64,
    |     ^^^^^^^^^^^^^^^
...
101 |     generative_model: GenerativeModel,
    |     ^^^^^^^^^^^^^^^^
...
105 |     prediction_history: Vec<Array1<f64>>,
    |     ^^^^^^^^^^^^^^^^^^

warning: field `gnn` is never read
   --> src/phase6/meta_learning.rs:126:5
    |
121 | pub struct MetaLearningCoordinator {
    |            ----------------------- field in this struct
...
126 |     gnn: Arc<RwLock<E3EquivariantGNN>>,
    |     ^^^

warning: fields `active_inference` and `health_monitor` are never read
  --> src/phase6/integration.rs:28:5
   |
23 | pub struct Phase6Integration {
   |            ----------------- fields in this struct
...
28 |     active_inference: Arc<RwLock<HierarchicalModel>>,
   |     ^^^^^^^^^^^^^^^^
...
37 |     health_monitor: Arc<RwLock<HealthMonitor>>,
   |     ^^^^^^^^^^^^^^

warning: field `free_energy` is never read
   --> src/phase6/integration.rs:415:5
    |
413 | struct InferenceResult {
    |        --------------- field in this struct
414 |     state: Array1<f64>,
415 |     free_energy: f64,
    |     ^^^^^^^^^^^

warning: field `energy` is never read
   --> src/phase6/integration.rs:420:5
    |
418 | struct ThermoResult {
    |        ------------ field in this struct
419 |     state: Array1<f64>,
420 |     energy: f64,
    |     ^^^^^^

warning: field `max_dimension` is never read
  --> src/phase6/gpu_tda.rs:16:5
   |
13 | pub struct GpuTDA {
   |            ------ field in this struct
...
16 |     max_dimension: usize,
   |     ^^^^^^^^^^^^^

warning: fields `transfer_entropy` and `active_inference` are never read
  --> src/cma/mod.rs:56:5
   |
39 | pub struct CausalManifoldAnnealing {
   |            ----------------------- fields in this struct
...
56 |     transfer_entropy: Arc<crate::information_theory::transfer_entropy::TransferEntropy>,
   |     ^^^^^^^^^^^^^^^^
57 |     active_inference: Arc<crate::active_inference::ActiveInferenceController>,
   |     ^^^^^^^^^^^^^^^^

warning: field `ksg_neighbors` is never read
  --> src/cma/causal_discovery.rs:20:5
   |
18 | pub struct CausalManifoldDiscovery {
   |            ----------------------- field in this struct
19 |     fdr_threshold: f64,
20 |     ksg_neighbors: usize,
   |     ^^^^^^^^^^^^^

warning: multiple methods are never used
   --> src/cma/causal_discovery.rs:121:8
    |
 28 | impl CausalManifoldDiscovery {
    | ---------------------------- methods in this implementation
...
121 |     fn ksg_transfer_entropy(&self, source: &[f64], target: &[f64]) -> (f64, f64) {
    |        ^^^^^^^^^^^^^^^^^^^^
...
285 |     fn compute_distance(
    |        ^^^^^^^^^^^^^^^^
...
304 |     fn count_neighbors_marginal(
    |        ^^^^^^^^^^^^^^^^^^^^^^^^
...
328 |     fn count_neighbors_joint(
    |        ^^^^^^^^^^^^^^^^^^^^^
...
353 |     fn count_neighbors_marginal_past(
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
376 |     fn digamma(&self, x: f64) -> f64 {
    |        ^^^^^^^
...
385 |     fn bootstrap_p_value(&self, source: &[f64], target: &[f64], observed_te: f64) -> f64 {
    |        ^^^^^^^^^^^^^^^^^

warning: fields `initial_temp` and `final_temp` are never read
  --> src/cma/quantum_annealer.rs:19:5
   |
17 | pub struct GeometricQuantumAnnealer {
   |            ------------------------ fields in this struct
18 |     n_steps: usize,
19 |     initial_temp: f64,
   |     ^^^^^^^^^^^^
20 |     final_temp: f64,
   |     ^^^^^^^^^^

warning: field `dimension` is never read
   --> src/cma/quantum_annealer.rs:479:5
    |
477 | struct QuantumState {
    |        ------------ field in this struct
478 |     amplitudes: Vec<Complex64>,
479 |     dimension: usize,
    |     ^^^^^^^^^

warning: field `manifold_penalty` is never read
   --> src/cma/quantum_annealer.rs:486:5
    |
483 | struct QuantumHamiltonian {
    |        ------------------ field in this struct
...
486 |     manifold_penalty: f64,
    |     ^^^^^^^^^^^^^^^^

warning: field `device` is never read
  --> src/cma/neural/mod.rs:75:5
   |
73 | pub struct GeometricManifoldLearner {
   |            ------------------------ field in this struct
74 |     gnn: E3EquivariantGNN,
75 |     device: Device,
   |     ^^^^^^

warning: field `solution_dim` is never read
   --> src/cma/neural/mod.rs:155:5
    |
153 | pub struct DiffusionRefinement {
    |            ------------------- field in this struct
154 |     diffusion: ConsistencyDiffusion,
155 |     solution_dim: usize,
    |     ^^^^^^^^^^^^

warning: field `solution_dim` is never read
   --> src/cma/neural/mod.rs:206:5
    |
204 | pub struct NeuralQuantumState {
    |            ------------------ field in this struct
205 |     vmc: VariationalMonteCarlo,
206 |     solution_dim: usize,
    |     ^^^^^^^^^^^^

warning: fields `device`, `embed_dim`, and `num_heads` are never read
   --> src/cma/neural/mod.rs:254:5
    |
253 | pub struct MetaOptimizationTransformer {
    |            --------------------------- fields in this struct
254 |     device: Device,
    |     ^^^^^^
255 |     embed_dim: usize,
    |     ^^^^^^^^^
256 |     num_heads: usize,
    |     ^^^^^^^^^

warning: fields `device`, `node_dim`, `edge_dim`, `hidden_dim`, and `num_layers` are never read
  --> src/cma/neural/gnn_integration.rs:14:5
   |
13 | pub struct E3EquivariantGNN {
   |            ---------------- fields in this struct
14 |     device: Device,
   |     ^^^^^^
15 |     node_dim: usize,
   |     ^^^^^^^^
16 |     edge_dim: usize,
   |     ^^^^^^^^
17 |     hidden_dim: usize,
   |     ^^^^^^^^^^
18 |     num_layers: usize,
   |     ^^^^^^^^^^

warning: fields `solution_dim`, `hidden_dim`, `num_steps`, and `device` are never read
  --> src/cma/neural/diffusion.rs:13:5
   |
12 | pub struct ConsistencyDiffusion {
   |            -------------------- fields in this struct
13 |     solution_dim: usize,
   |     ^^^^^^^^^^^^
14 |     hidden_dim: usize,
   |     ^^^^^^^^^^
15 |     num_steps: usize,
   |     ^^^^^^^^^
16 |     device: Device,
   |     ^^^^^^

warning: field `normalized_shape` is never read
   --> src/cma/neural/neural_quantum.rs:138:5
    |
137 | pub struct LayerNorm {
    |            --------- field in this struct
138 |     normalized_shape: usize,
    |     ^^^^^^^^^^^^^^^^

warning: fields `device`, `hidden_dim`, and `num_layers` are never read
   --> src/cma/neural/neural_quantum.rs:161:5
    |
159 | pub struct NeuralQuantumState {
    |            ------------------ fields in this struct
160 |     network: ResNet,
161 |     device: Device,
    |     ^^^^^^
162 |     hidden_dim: usize,
    |     ^^^^^^^^^^
163 |     num_layers: usize,
    |     ^^^^^^^^^^

warning: fields `input_dim`, `hidden_dim`, `num_layers`, and `device` are never read
   --> src/cma/neural/neural_quantum.rs:370:5
    |
369 | pub struct ResNet {
    |            ------ fields in this struct
370 |     input_dim: usize,
    |     ^^^^^^^^^
371 |     hidden_dim: usize,
    |     ^^^^^^^^^^
372 |     num_layers: usize,
    |     ^^^^^^^^^^
373 |     device: Device,
    |     ^^^^^^

warning: fields `hidden_dim` and `device` are never read
   --> src/cma/neural/neural_quantum.rs:438:5
    |
437 | struct ResidualLayer {
    |        ------------- fields in this struct
438 |     hidden_dim: usize,
    |     ^^^^^^^^^^
439 |     device: Device,
    |     ^^^^^^

warning: field `num_iterations` is never read
   --> src/cma/neural/neural_quantum.rs:484:5
    |
481 | pub struct VariationalMonteCarlo {
    |            --------------------- field in this struct
...
484 |     num_iterations: usize,
    |     ^^^^^^^^^^^^^^

warning: fields `optimizer` and `device` are never read
   --> src/cma/neural/gnn_training.rs:665:5
    |
663 | pub struct GNNTrainer {
    |            ---------- fields in this struct
664 |     model: E3EquivariantGNN,
665 |     optimizer: Optimizer,
    |     ^^^^^^^^^
...
669 |     device: Device,
    |     ^^^^^^

warning: field `device` is never read
   --> src/cma/neural/gnn_training.rs:922:5
    |
920 | pub struct GpuBatchGNNTrainer {
    |            ------------------ field in this struct
921 |     trainers: Vec<GNNTrainer>,
922 |     device: Device,
    |     ^^^^^^

warning: fields `teacher` and `device` are never read
   --> src/cma/neural/gnn_transfer_learning.rs:686:5
    |
685 | pub struct KnowledgeDistiller {
    |            ------------------ fields in this struct
686 |     teacher: E3EquivariantGNN,
    |     ^^^^^^^
687 |     config: DistillationConfig,
688 |     device: Device,
    |     ^^^^^^

warning: method `distillation_loss` is never used
   --> src/cma/neural/gnn_transfer_learning.rs:730:8
    |
691 | impl KnowledgeDistiller {
    | ----------------------- method in this implementation
...
730 |     fn distillation_loss(
    |        ^^^^^^^^^^^^^^^^^

warning: field `augmenter` is never read
   --> src/cma/neural/gnn_training_pipeline.rs:614:5
    |
612 | pub struct GNNTrainingPipeline {
    |            ------------------- field in this struct
613 |     preprocessor: DataPreprocessor,
614 |     augmenter: Option<DataAugmenter>,
    |     ^^^^^^^^^

warning: methods `estimate_kl_divergence`, `non_conformity_score`, and `verify_proof_internal` are never used
   --> src/cma/guarantees/mod.rs:198:8
    |
 36 | impl PrecisionFramework {
    | ----------------------- methods in this implementation
...
198 |     fn estimate_kl_divergence(&self, solution: &super::Solution, ensemble: &super::Ensemble) -> f64 {
    |        ^^^^^^^^^^^^^^^^^^^^^^
...
244 |     fn non_conformity_score(&self, solution: &super::Solution, calibration: &CalibrationPoint) -> f64 {
    |        ^^^^^^^^^^^^^^^^^^^^
...
270 |     fn verify_proof_internal(&self, _commitment: &str, _proof: &str) -> bool {
    |        ^^^^^^^^^^^^^^^^^^^^^

warning: fields `empirical_risk`, `kl_divergence`, and `sample_size` are never read
   --> src/cma/guarantees/mod.rs:290:5
    |
289 | struct PacBayesBound {
    |        ------------- fields in this struct
290 |     empirical_risk: f64,
    |     ^^^^^^^^^^^^^^
291 |     kl_divergence: f64,
    |     ^^^^^^^^^^^^^
292 |     error_bound: f64,
293 |     sample_size: usize,
    |     ^^^^^^^^^^^
    |
    = note: `PacBayesBound` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `recent_scores` is never read
   --> src/cma/guarantees/conformal.rs:340:5
    |
337 | pub struct AdaptiveConformalPredictor {
    |            -------------------------- field in this struct
...
340 |     recent_scores: std::collections::VecDeque<f64>,
    |     ^^^^^^^^^^^^^

warning: field `security_parameter` is never read
  --> src/cma/guarantees/zkp.rs:17:5
   |
16 | pub struct ZKProofSystem {
   |            ------------- field in this struct
17 |     security_parameter: usize, // Bits of security (e.g., 256)
   |     ^^^^^^^^^^^^^^^^^^

warning: fields `rmsd_threshold`, `binding_affinity_cutoff`, and `folding_temperature` are never read
   --> src/cma/applications/mod.rs:103:5
    |
102 | pub struct BiomolecularAdapter {
    |            ------------------- fields in this struct
103 |     rmsd_threshold: f64,
    |     ^^^^^^^^^^^^^^
104 |     binding_affinity_cutoff: f64,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
105 |     folding_temperature: f64,
    |     ^^^^^^^^^^^^^^^^^^^

warning: fields `property_r2_threshold`, `synthesis_confidence_min`, and `stability_window_ev` are never read
   --> src/cma/applications/mod.rs:253:5
    |
252 | pub struct MaterialsAdapter {
    |            ---------------- fields in this struct
253 |     property_r2_threshold: f64,
    |     ^^^^^^^^^^^^^^^^^^^^^
254 |     synthesis_confidence_min: f64,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^
255 |     stability_window_ev: f64,
    |     ^^^^^^^^^^^^^^^^^^^

warning: fields `solver_pool` and `pool_size` are never read
  --> src/cma/gpu_integration.rs:46:5
   |
44 | pub struct GpuTspBridge {
   |            ------------ fields in this struct
45 |     /// Pre-allocated solvers for batch processing
46 |     solver_pool: Vec<Arc<parking_lot::Mutex<GpuTspSolver>>>,
   |     ^^^^^^^^^^^
47 |     /// Number of parallel solvers
48 |     pool_size: usize,
   |     ^^^^^^^^^

warning: fields `namespace` and `control_frequency` are never read
  --> src/applications/robotics/ros_bridge.rs:91:5
   |
89 | pub struct RosInterface {
   |            ------------ fields in this struct
90 |     /// Robot namespace
91 |     namespace: String,
   |     ^^^^^^^^^
92 |     /// Control frequency (Hz)
93 |     control_frequency: f64,
   |     ^^^^^^^^^^^^^^^^^

warning: field `config` is never read
  --> src/applications/scientific/mod.rs:40:5
   |
39 | pub struct ScientificDiscovery {
   |            ------------------- field in this struct
40 |     config: ScientificConfig,
   |     ^^^^^^

warning: field `n_candidates` is never read
  --> src/applications/scientific/experiment_design.rs:30:5
   |
28 | pub struct ExperimentDesigner {
   |            ------------------ field in this struct
29 |     /// Number of candidate experiments to evaluate
30 |     n_candidates: usize,
   |     ^^^^^^^^^^^^

warning: field `config` is never read
  --> src/applications/scientific/parameter_optimization.rs:27:5
   |
26 | pub struct ParameterOptimizer {
   |            ------------------ field in this struct
27 |     config: OptimizationConfig,
   |     ^^^^^^

warning: field `confidence_level` is never read
  --> src/applications/scientific/hypothesis_testing.rs:25:5
   |
24 | pub struct HypothesisTester {
   |            ---------------- field in this struct
25 |     confidence_level: f64,
   |     ^^^^^^^^^^^^^^^^

warning: field `device` is never read
  --> src/chemistry/gpu_docking.rs:11:5
   |
10 | pub struct GpuMolecularDocker {
   |            ------------------ field in this struct
11 |     device: Arc<CudaContext>,
   |     ^^^^^^

warning: field `refine_solution` is never read
  --> src/time_series/arima_gpu.rs:62:5
   |
46 | pub struct ArimaGpu {
   |            -------- field in this struct
...
62 |     refine_solution: bool,
   |     ^^^^^^^^^^^^^^^

warning: method `solve_via_qr` is never used
   --> src/time_series/arima_gpu.rs:464:8
    |
 65 | impl ArimaGpu {
    | ------------- method in this implementation
...
464 |     fn solve_via_qr(&self, a_flat: &[f64], b: &[f64], n: usize) -> Result<Vec<f64>> {
    |        ^^^^^^^^^^^^

warning: fields `last_hidden_states` and `last_cell_states` are never read
  --> src/time_series/lstm_forecaster.rs:81:5
   |
70 | pub struct LstmForecaster {
   |            -------------- fields in this struct
...
81 |     last_hidden_states: Option<Vec<Array1<f64>>>,
   |     ^^^^^^^^^^^^^^^^^^
82 |     last_cell_states: Option<Vec<Array1<f64>>>,
   |     ^^^^^^^^^^^^^^^^

warning: field `gpu_available` is never read
  --> src/time_series/kalman_filter.rs:72:5
   |
56 | pub struct KalmanFilter {
   |            ------------ field in this struct
...
72 |     gpu_available: bool,
   |     ^^^^^^^^^^^^^

warning: fields `ar_coefficients` and `state_buffer` are never read
   --> src/time_series/kalman_filter.rs:389:5
    |
385 | pub struct ArimaKalmanFusion {
    |            ----------------- fields in this struct
...
389 |     ar_coefficients: Vec<f64>,
    |     ^^^^^^^^^^^^^^^
390 |     /// State buffer for AR(p) model
391 |     state_buffer: Vec<f64>,
    |     ^^^^^^^^^^^^

warning: field `workspace` is never read
  --> src/time_series/optimizations.rs:30:5
   |
22 | pub struct OptimizedGruCell {
   |            ---------------- field in this struct
...
30 |     workspace: Vec<f64>,
   |     ^^^^^^^^^

warning: field `config` is never read
   --> src/time_series/optimizations.rs:139:5
    |
135 | struct CachedArimaModel {
    |        ---------------- field in this struct
...
139 |     config: ArimaConfig,
    |     ^^^^^^
    |
    = note: `CachedArimaModel` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: field `num_threads` is never read
   --> src/time_series/optimizations.rs:258:5
    |
254 | pub struct BatchForecaster {
    |            --------------- field in this struct
...
258 |     num_threads: usize,
    |     ^^^^^^^^^^^

warning: field `gpu_available` is never read
  --> src/time_series/arima_gpu_optimized.rs:34:5
   |
20 | pub struct ArimaGpuOptimized {
   |            ----------------- field in this struct
...
34 |     gpu_available: bool,
   |     ^^^^^^^^^^^^^

warning: field `gpu_available` is never read
  --> src/time_series/lstm_gpu_optimized.rs:31:5
   |
22 | pub struct LstmGpuOptimized {
   |            ---------------- field in this struct
...
31 |     gpu_available: bool,
   |     ^^^^^^^^^^^^^

warning: field `num_gates` is never read
  --> src/time_series/lstm_gpu_optimized.rs:45:5
   |
35 | struct GpuWeightSet {
   |        ------------ field in this struct
...
45 |     num_gates: usize,
   |     ^^^^^^^^^

warning: field `gpu_available` is never read
  --> src/time_series/uncertainty_gpu_optimized.rs:23:5
   |
17 | pub struct UncertaintyGpuOptimized {
   |            ----------------------- field in this struct
...
23 |     gpu_available: bool,
   |     ^^^^^^^^^^^^^

warning: field `gpu_pool` is never read
   --> src/finance/portfolio_optimizer.rs:103:5
    |
101 | pub struct PortfolioOptimizer {
    |            ------------------ field in this struct
102 |     /// GPU memory pool for covariance computation
103 |     gpu_pool: GpuMemoryPool,
    |     ^^^^^^^^

warning: method `remove_last` is never used
   --> src/api_server/rate_limit.rs:358:8
    |
325 | impl SlidingWindow {
    | ------------------ method in this implementation
...
358 |     fn remove_last(&mut self) {
    |        ^^^^^^^^^^^

warning: field `safety_mode` is never read
  --> src/assistant/autonomous_agent.rs:35:5
   |
33 | pub struct AutonomousAgent {
   |            --------------- field in this struct
34 |     /// Safety mode - controls execution permissions
35 |     safety_mode: SafetyMode,
   |     ^^^^^^^^^^^

warning: fields `wq`, `wk`, `wv`, and `wo` are never read
  --> src/assistant/local_llm/gpu_transformer.rs:22:5
   |
17 | pub struct GpuTransformerLayer {
   |            ------------------- fields in this struct
...
22 |     wq: CudaSlice<f32>,  // Query projection weights
   |     ^^
23 |     wk: CudaSlice<f32>,  // Key projection weights
   |     ^^
24 |     wv: CudaSlice<f32>,  // Value projection weights
   |     ^^
25 |     wo: CudaSlice<f32>,  // Output projection weights
   |     ^^

warning: fields `metrics`, `attention_analyzer`, `transfer_entropy`, and `n_heads` are never read
   --> src/assistant/local_llm/gpu_transformer.rs:416:5
    |
396 | pub struct GpuLLMInference {
    |            --------------- fields in this struct
...
416 |     metrics: Option<LLMMetrics>,
    |     ^^^^^^^
417 |     attention_analyzer: Option<AttentionAnalyzer>,
    |     ^^^^^^^^^^^^^^^^^^
418 |     transfer_entropy: Option<TransferEntropyLLM>,
    |     ^^^^^^^^^^^^^^^^
...
424 |     n_heads: usize,
    |     ^^^^^^^

warning: field `alignment` is never read
   --> src/assistant/local_llm/gguf_loader.rs:199:5
    |
185 | pub struct GgufLoader {
    |            ---------- field in this struct
...
199 |     alignment: u64,
    |     ^^^^^^^^^

warning: method `Quantum` should have a snake case name
  --> src/integration/cross_domain_bridge.rs:56:12
   |
56 |     pub fn Quantum(data: Vec<f64>) -> Self {
   |            ^^^^^^^ help: convert the identifier to snake case: `quantum`
   |
   = note: `#[warn(non_snake_case)]` on by default

warning: method `Neuromorphic` should have a snake case name
  --> src/integration/cross_domain_bridge.rs:67:12
   |
67 |     pub fn Neuromorphic(data: Vec<f64>) -> Self {
   |            ^^^^^^^^^^^^ help: convert the identifier to snake case: `neuromorphic`

warning: structure field `F` should have a snake case name
   --> src/orchestration/optimization/geometric_manifold.rs:220:5
    |
220 |     F: DMatrix<f64>,
    |     ^ help: convert the identifier to snake case (notice the capitalization): `f`

warning: structure field `F_diag` should have a snake case name
   --> src/orchestration/optimization/geometric_manifold.rs:222:5
    |
222 |     F_diag: DVector<f64>,
    |     ^^^^^^ help: convert the identifier to snake case (notice the capitalization): `f_diag`

warning: structure field `A` should have a snake case name
   --> src/orchestration/optimization/geometric_manifold.rs:224:5
    |
224 |     A: Option<DMatrix<f64>>,
    |     ^ help: convert the identifier to snake case: `a`

warning: structure field `G` should have a snake case name
   --> src/orchestration/optimization/geometric_manifold.rs:225:5
    |
225 |     G: Option<DMatrix<f64>>,
    |     ^ help: convert the identifier to snake case: `g`

warning: variable `F` should have a snake case name
   --> src/orchestration/optimization/geometric_manifold.rs:899:13
    |
899 |         let F = &self.natural_gradient.fisher.F;
    |             ^ help: convert the identifier to snake case (notice the capitalization): `f`

warning: variable `F_reg` should have a snake case name
   --> src/orchestration/optimization/geometric_manifold.rs:900:13
    |
900 |         let F_reg = F + DMatrix::identity(F.nrows(), F.ncols()) * self.natural_gradient.damping;
    |             ^^^^^ help: convert the identifier to snake case (notice the capitalization): `f_reg`

warning: variable `F_inv` should have a snake case name
   --> src/orchestration/optimization/geometric_manifold.rs:902:21
    |
902 |         if let Some(F_inv) = F_reg.try_inverse() {
    |                     ^^^^^ help: convert the identifier to snake case (notice the capitalization): `f_inv`

warning: variable `F` should have a snake case name
   --> src/orchestration/optimization/geometric_manifold.rs:989:21
    |
989 |             let mut F = DMatrix::zeros(x.len(), x.len());
    |                     ^ help: convert the identifier to snake case (notice the capitalization): `f`

warning: structure field `I` should have a snake case name
  --> src/orchestration/neuromorphic/unified_neuromorphic.rs:63:5
   |
63 |     I: f64,
   |     ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: structure field `F` should have a snake case name
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:114:5
    |
114 |     F: f64,
    |     ^ help: convert the identifier to snake case (notice the capitalization): `f`

warning: structure field `D` should have a snake case name
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:116:5
    |
116 |     D: f64,
    |     ^ help: convert the identifier to snake case: `d`

warning: structure field `tau_F` should have a snake case name
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:118:5
    |
118 |     tau_F: f64,
    |     ^^^^^ help: convert the identifier to snake case (notice the capitalization): `tau_f`

warning: structure field `tau_D` should have a snake case name
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:119:5
    |
119 |     tau_D: f64,
    |     ^^^^^ help: convert the identifier to snake case: `tau_d`

warning: structure field `A_plus` should have a snake case name
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:147:5
    |
147 |     A_plus: f64,     // LTP amplitude
    |     ^^^^^^ help: convert the identifier to snake case: `a_plus`

warning: structure field `A_minus` should have a snake case name
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:148:5
    |
148 |     A_minus: f64,    // LTD amplitude
    |     ^^^^^^^ help: convert the identifier to snake case: `a_minus`

warning: structure field `A` should have a snake case name
  --> src/orchestration/inference/hierarchical_active_inference.rs:40:5
   |
40 |     A: DMatrix<f64>,             // Observation model
   |     ^ help: convert the identifier to snake case: `a`

warning: structure field `B` should have a snake case name
  --> src/orchestration/inference/hierarchical_active_inference.rs:41:5
   |
41 |     B: DMatrix<f64>,             // Transition model
   |     ^ help: convert the identifier to snake case: `b`

warning: structure field `C` should have a snake case name
  --> src/orchestration/inference/hierarchical_active_inference.rs:42:5
   |
42 |     C: DVector<f64>,             // Observation bias
   |     ^ help: convert the identifier to snake case (notice the capitalization): `c`

warning: structure field `D` should have a snake case name
  --> src/orchestration/inference/hierarchical_active_inference.rs:43:5
   |
43 |     D: DVector<f64>,             // Prior over initial states
   |     ^ help: convert the identifier to snake case: `d`

warning: structure field `F` should have a snake case name
  --> src/orchestration/inference/hierarchical_active_inference.rs:69:5
   |
69 |     F: f64,
   |     ^ help: convert the identifier to snake case (notice the capitalization): `f`

warning: structure field `G` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:114:5
    |
114 |     G: Vec<f64>,
    |     ^ help: convert the identifier to snake case: `g`

warning: variable `grad_F` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:443:13
    |
443 |         let grad_F = self.compute_free_energy_gradient(level_idx, &bottom_up_error)?;
    |             ^^^^^^ help: convert the identifier to snake case (notice the capitalization): `grad_f`

warning: variable `total_F` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:520:17
    |
520 |         let mut total_F = 0.0;
    |                 ^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `total_f`

warning: variable `G` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:569:17
    |
569 |             let G = self.evaluate_expected_free_energy(policy)?;
    |                 ^ help: convert the identifier to snake case: `g`

warning: variable `min_G` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:574:13
    |
574 |         let min_G = self.action_selection.G.iter().fold(f64::INFINITY, |a, &b| a.min(b));
    |             ^^^^^ help: convert the identifier to snake case: `min_g`

warning: variable `exp_neg_G` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:575:13
    |
575 |         let exp_neg_G: Vec<f64> = self.action_selection.G.iter()
    |             ^^^^^^^^^ help: convert the identifier to snake case: `exp_neg_g`

warning: variable `G` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:626:17
    |
626 |         let mut G = 0.0;
    |                 ^ help: convert the identifier to snake case: `g`

warning: variable `A_clone` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:707:17
    |
707 |             let A_clone = self.levels[level_idx].A.clone();
    |                 ^^^^^^^ help: convert the identifier to snake case: `a_clone`

warning: variable `B_clone` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:708:17
    |
708 |             let B_clone = self.levels[level_idx].B.clone();
    |                 ^^^^^^^ help: convert the identifier to snake case: `b_clone`

warning: variable `D_clone` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:709:17
    |
709 |             let D_clone = self.levels[level_idx].D.clone();
    |                 ^^^^^^^ help: convert the identifier to snake case: `d_clone`

warning: variable `dA` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:714:21
    |
714 |                 let dA = prediction_error * mu_clone.transpose() * learning_rate;
    |                     ^^ help: convert the identifier to snake case: `d_a`

warning: variable `dB` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:722:21
    |
722 |                 let dB = transition_error * mu_clone.transpose() * learning_rate;
    |                     ^^ help: convert the identifier to snake case: `d_b`

warning: variable `B_to_normalize` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:726:25
    |
726 |                 let mut B_to_normalize = self.levels[level_idx].B.clone();
    |                         ^^^^^^^^^^^^^^ help: convert the identifier to snake case: `b_to_normalize`

warning: variable `B` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:742:43
    |
742 |     fn normalize_transition_matrix(&self, B: &mut DMatrix<f64>) {
    |                                           ^ help: convert the identifier to snake case: `b`

warning: structure field `A` should have a snake case name
  --> src/orchestration/inference/joint_active_inference.rs:55:5
   |
55 |     A: DMatrix<f64>,
   |     ^ help: convert the identifier to snake case: `a`

warning: structure field `B` should have a snake case name
  --> src/orchestration/inference/joint_active_inference.rs:57:5
   |
57 |     B: DMatrix<f64>,
   |     ^ help: convert the identifier to snake case: `b`

warning: structure field `C` should have a snake case name
  --> src/orchestration/inference/joint_active_inference.rs:59:5
   |
59 |     C: DVector<f64>,
   |     ^ help: convert the identifier to snake case (notice the capitalization): `c`

warning: structure field `D` should have a snake case name
  --> src/orchestration/inference/joint_active_inference.rs:61:5
   |
61 |     D: DVector<f64>,
   |     ^ help: convert the identifier to snake case: `d`

warning: structure field `F` should have a snake case name
  --> src/orchestration/inference/joint_active_inference.rs:76:5
   |
76 |     F: f64,
   |     ^ help: convert the identifier to snake case (notice the capitalization): `f`

warning: structure field `G` should have a snake case name
  --> src/orchestration/inference/joint_active_inference.rs:78:5
   |
78 |     G: f64,
   |     ^ help: convert the identifier to snake case: `g`

warning: structure field `T` should have a snake case name
   --> src/orchestration/inference/joint_active_inference.rs:173:5
    |
173 |     T: DMatrix<f64>,
    |     ^ help: convert the identifier to snake case: `t`

warning: structure field `I` should have a snake case name
   --> src/orchestration/inference/joint_active_inference.rs:175:5
    |
175 |     I: DMatrix<f64>,
    |     ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: structure field `J` should have a snake case name
   --> src/orchestration/inference/joint_active_inference.rs:185:5
    |
185 |     J: DMatrix<f64>,
    |     ^ help: convert the identifier to snake case: `j`

warning: structure field `W` should have a snake case name
   --> src/orchestration/inference/joint_active_inference.rs:216:5
    |
216 |     W: DMatrix<f64>,
    |     ^ help: convert the identifier to snake case (notice the capitalization): `w`

warning: structure field `collective_F` should have a snake case name
   --> src/orchestration/inference/joint_active_inference.rs:349:5
    |
349 |     collective_F: f64,
    |     ^^^^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `collective_f`

warning: variable `E` should have a snake case name
   --> src/orchestration/causality/bidirectional_causality.rs:420:13
    |
420 |         let E = self.ccm_engine.embedding_dim;
    |             ^ help: convert the identifier to snake case: `e`

warning: variable `X_restricted` should have a snake case name
   --> src/orchestration/causality/bidirectional_causality.rs:786:17
    |
786 |         let mut X_restricted = DMatrix::zeros(n_samples, max_lag);
    |                 ^^^^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `x_restricted`

warning: variable `X_unrestricted` should have a snake case name
   --> src/orchestration/causality/bidirectional_causality.rs:797:17
    |
797 |         let mut X_unrestricted = DMatrix::zeros(n_samples, max_lag * 2);
    |                 ^^^^^^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `x_unrestricted`

warning: variable `X` should have a snake case name
   --> src/orchestration/causality/bidirectional_causality.rs:881:27
    |
881 |     fn compute_rss(&self, X: &DMatrix<f64>, y: &DVector<f64>) -> Result<f64, OrchestrationError> {
    |                           ^ help: convert the identifier to snake case (notice the capitalization): `x`

warning: variable `XtX` should have a snake case name
   --> src/orchestration/causality/bidirectional_causality.rs:883:13
    |
883 |         let XtX = X.transpose() * X;
    |             ^^^ help: convert the identifier to snake case: `xt_x`

warning: variable `Xty` should have a snake case name
   --> src/orchestration/causality/bidirectional_causality.rs:884:13
    |
884 |         let Xty = X.transpose() * y;
    |             ^^^ help: convert the identifier to snake case (notice the capitalization): `xty`

warning: variable `XtX_inv` should have a snake case name
   --> src/orchestration/causality/bidirectional_causality.rs:886:21
    |
886 |         if let Some(XtX_inv) = XtX.try_inverse() {
    |                     ^^^^^^^ help: convert the identifier to snake case: `xt_x_inv`

warning: variable `Z` should have a snake case name
    --> src/orchestration/causality/bidirectional_causality.rs:1070:17
     |
1070 |         let mut Z = DMatrix::zeros(n, k);
     |                 ^ help: convert the identifier to snake case (notice the capitalization): `z`

warning: variable `X` should have a snake case name
    --> src/orchestration/causality/bidirectional_causality.rs:1089:51
     |
1089 |     fn compute_residuals(&self, y: &DVector<f64>, X: &DMatrix<f64>) -> Result<DVector<f64>, OrchestrationError> {
     |                                                   ^ help: convert the identifier to snake case (notice the capitalization): `x`

warning: variable `XtX` should have a snake case name
    --> src/orchestration/causality/bidirectional_causality.rs:1090:13
     |
1090 |         let XtX = X.transpose() * X;
     |             ^^^ help: convert the identifier to snake case: `xt_x`

warning: variable `XtX_inv` should have a snake case name
    --> src/orchestration/causality/bidirectional_causality.rs:1091:21
     |
1091 |         if let Some(XtX_inv) = XtX.try_inverse() {
     |                     ^^^^^^^ help: convert the identifier to snake case: `xt_x_inv`

warning: variable `K_x` should have a snake case name
    --> src/orchestration/causality/bidirectional_causality.rs:1105:17
     |
1105 |         let mut K_x = DMatrix::zeros(n, n);
     |                 ^^^ help: convert the identifier to snake case (notice the capitalization): `k_x`

warning: variable `K_y` should have a snake case name
    --> src/orchestration/causality/bidirectional_causality.rs:1106:17
     |
1106 |         let mut K_y = DMatrix::zeros(n, n);
     |                 ^^^ help: convert the identifier to snake case (notice the capitalization): `k_y`

warning: variable `H` should have a snake case name
    --> src/orchestration/causality/bidirectional_causality.rs:1116:13
     |
1116 |         let H = DMatrix::identity(n, n) - DMatrix::from_element(n, n, 1.0 / n as f64);
     |             ^ help: convert the identifier to snake case: `h`

warning: variable `K_x_centered` should have a snake case name
    --> src/orchestration/causality/bidirectional_causality.rs:1117:13
     |
1117 |         let K_x_centered = &H * &K_x * &H;
     |             ^^^^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `k_x_centered`

warning: variable `K_y_centered` should have a snake case name
    --> src/orchestration/causality/bidirectional_causality.rs:1118:13
     |
1118 |         let K_y_centered = &H * &K_y * &H;
     |             ^^^^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `k_y_centered`

warning: structure field `W` should have a snake case name
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:222:5
    |
222 |     W: DMatrix<Complex64>,
    |     ^ help: convert the identifier to snake case (notice the capitalization): `w`

warning: structure field `W_opt` should have a snake case name
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:244:5
    |
244 |     W_opt: DMatrix<Complex64>,
    |     ^^^^^ help: convert the identifier to snake case (notice the capitalization): `w_opt`

warning: structure field `H` should have a snake case name
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:360:5
    |
360 |     H: DMatrix<Complex64>,
    |     ^ help: convert the identifier to snake case: `h`

warning: structure field `U` should have a snake case name
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:366:5
    |
366 |     U: Vec<DMatrix<Complex64>>,
    |     ^ help: convert the identifier to snake case (notice the capitalization): `u`

warning: calls to `std::mem::drop` with a reference instead of an owned value does nothing
   --> src/cma/conformal_prediction.rs:326:13
    |
326 |             drop(weights);  // Explicitly drop mutable borrow
    |             ^^^^^-------^
    |                  |
    |                  argument has type `&mut Vec<f64>`
    |
    = note: `#[warn(dropping_references)]` on by default
help: use `let _ = ...` to ignore the expression or result
    |
326 -             drop(weights);  // Explicitly drop mutable borrow
326 +             let _ = weights;  // Explicitly drop mutable borrow
    |

warning: variable `X_flat` should have a snake case name
   --> src/time_series/arima_gpu_optimized.rs:102:17
    |
102 |         let mut X_flat: Vec<f32> = Vec::with_capacity(num_samples * p);
    |                 ^^^^^^ help: convert the identifier to snake case (notice the capitalization): `x_flat`

warning: variable `X_transpose` should have a snake case name
   --> src/time_series/arima_gpu_optimized.rs:115:17
    |
115 |         let mut X_transpose: Vec<f32> = vec![0.0; p * num_samples];
    |                 ^^^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `x_transpose`

warning: variable `XtX` should have a snake case name
   --> src/time_series/arima_gpu_optimized.rs:125:13
    |
125 |         let XtX = executor.tensor_core_matmul_wmma(
    |             ^^^ help: convert the identifier to snake case: `xt_x`

warning: variable `Xty` should have a snake case name
   --> src/time_series/arima_gpu_optimized.rs:136:13
    |
136 |         let Xty = executor.tensor_core_matmul_wmma(
    |             ^^^ help: convert the identifier to snake case (notice the capitalization): `xty`

warning: variable `A` should have a snake case name
   --> src/time_series/arima_gpu_optimized.rs:169:39
    |
169 |     fn solve_linear_system_cpu(&self, A: &[f32], b: &[f32], n: usize) -> Result<Vec<f32>> {
    |                                       ^ help: convert the identifier to snake case: `a`

warning: variable `A_copy` should have a snake case name
   --> src/time_series/arima_gpu_optimized.rs:170:17
    |
170 |         let mut A_copy = A.to_vec();
    |                 ^^^^^^ help: convert the identifier to snake case: `a_copy`

warning: `prism-ai` (lib) generated 649 warnings (run `cargo fix --lib -p prism-ai` to apply 67 suggestions)
[CUBLAS Interposer] Loaded real CUBLAS: /usr/local/cuda-12.8/lib64/libcublas.so.12
[CUBLAS Interposer] Loaded real CUBLAS: /usr/local/cuda-12.8/lib64/libcublas.so.12
[CUBLAS Interposer] Loaded real CUBLAS: /usr/local/cuda-12.8/lib64/libcublas.so.12
[CUBLAS Interposer] Loaded real CUBLAS: /usr/local/cuda-12.8/lib64/libcublas.so.12
[CUBLAS Interposer] Loaded real CUBLAS: /usr/local/cuda-12.8/lib64/libcublas.so.12
[CUBLAS Interposer] Loaded real CUBLAS: /usr/local/cuda-12.8/lib64/libcublas.so.12
[CUBLAS Interposer] Loaded real CUBLAS: /usr/local/cuda-12.8/lib64/libcublas.so.12
    Finished `bench` profile [optimized] target(s) in 25.66s
     Running benches/tensor_core_benchmark.rs (target/release/deps/tensor_core_benchmark-2147621c8266e6af)
[CUBLAS Interposer] Loaded real CUBLAS: /usr/local/cuda-12.8/lib64/libcublas.so.12

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     GpuReservoirComputer::new(config, gpu_config)
    |                           ^^^
    |
    = note: `#[warn(deprecated)]` on by default

warning: unused import: `rayon::prelude`
  --> src/neuromorphic/src/gpu_reservoir.rs:15:5
   |
15 | use rayon::prelude::*;
   |     ^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` on by default

warning: unused variable: `reason`
   --> src/neuromorphic/src/pattern_detector.rs:357:30
    |
357 |     fn record_failure(&self, reason: &str) {
    |                              ^^^^^^ help: if this is intentional, prefix it with an underscore: `_reason`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `bin_source_past`
   --> src/neuromorphic/src/transfer_entropy.rs:109:17
    |
109 |             let bin_source_past = self.discretize_vector(&source_past);
    |                 ^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_bin_source_past`

warning: type `ReservoirStatistics` is more private than the item `ReservoirComputer::get_statistics`
   --> src/neuromorphic/src/reservoir.rs:224:5
    |
224 |     pub fn get_statistics(&self) -> &ReservoirStatistics {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method `ReservoirComputer::get_statistics` is reachable at visibility `pub`
    |
note: but type `ReservoirStatistics` is only usable at visibility `pub(self)`
   --> src/neuromorphic/src/reservoir.rs:108:1
    |
108 | struct ReservoirStatistics {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: `#[warn(private_interfaces)]` on by default

warning: fields `max_pool_size` and `total_allocated_bytes` are never read
  --> src/neuromorphic/src/gpu_memory.rs:17:5
   |
13 | pub struct GpuMemoryPool {
   |            ------------- fields in this struct
...
17 |     max_pool_size: usize,
   |     ^^^^^^^^^^^^^
18 |     total_allocated_bytes: Arc<Mutex<usize>>,
   |     ^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(dead_code)]` on by default

warning: hiding a lifetime that's elided elsewhere is confusing
   --> src/neuromorphic/src/gpu_memory.rs:302:29
    |
302 |     pub fn borrow_zero_copy(&mut self) -> Result<GpuBufferBorrow> {
    |                             ^^^^^^^^^            --------------- the same lifetime is hidden here
    |                             |
    |                             the lifetime is elided here
    |
    = help: the same lifetime is referred to in inconsistent ways, making the signature confusing
    = note: `#[warn(mismatched_lifetime_syntaxes)]` on by default
help: use `'_` for type paths
    |
302 |     pub fn borrow_zero_copy(&mut self) -> Result<GpuBufferBorrow<'_>> {
    |                                                                 ++++

warning: `neuromorphic-engine` (lib) generated 7 warnings
warning: unused import: `Array1`
  --> src/quantum/src/prct_coloring.rs:12:15
   |
12 | use ndarray::{Array1, Array2};
   |               ^^^^^^
   |
   = note: `#[warn(unused_imports)]` on by default

warning: unused import: `Context`
  --> src/quantum/src/prct_coloring.rs:14:22
   |
14 | use anyhow::{Result, Context};
   |                      ^^^^^^^

warning: unused import: `Hamiltonian`
  --> src/quantum/src/prct_coloring.rs:17:47
   |
17 | use crate::hamiltonian::{PhaseResonanceField, Hamiltonian};
   |                                               ^^^^^^^^^^^

warning: unused import: `HashMap`
  --> src/quantum/src/gpu_coloring.rs:10:24
   |
10 | use std::collections::{HashMap, HashSet};
   |                        ^^^^^^^

warning: unused import: `Context`
 --> src/quantum/src/prct_tsp.rs:8:22
  |
8 | use anyhow::{Result, Context};
  |                      ^^^^^^^

warning: unused import: `Context`
  --> src/quantum/src/qubo.rs:10:22
   |
10 | use anyhow::{anyhow, Context, Result};
   |                      ^^^^^^^

warning: unused import: `std::sync::Arc`
  --> src/quantum/src/qubo.rs:12:5
   |
12 | use std::sync::Arc;
   |     ^^^^^^^^^^^^^^

warning: variable does not need to be mutable
   --> src/quantum/src/gpu_coloring.rs:287:13
    |
287 |         let mut gpu_priorities = stream.alloc_zeros::<f32>(n)
    |             ----^^^^^^^^^^^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` on by default

warning: variable does not need to be mutable
   --> src/quantum/src/gpu_coloring.rs:289:13
    |
289 |         let mut gpu_colors = stream.alloc_zeros::<u32>(n)
    |             ----^^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
   --> src/quantum/src/gpu_coloring.rs:291:13
    |
291 |         let mut gpu_can_color = stream.alloc_zeros::<u32>(n)
    |             ----^^^^^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: value assigned to `current_energy` is never read
   --> src/quantum/src/qubo.rs:161:17
    |
161 |         let mut current_energy = self.best_energy;
    |                 ^^^^^^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?
    = note: `#[warn(unused_assignments)]` on by default

warning: variable `tour_gpu` is assigned to, but never used
  --> src/quantum/src/gpu_k_opt.rs:86:17
   |
86 |         let mut tour_gpu = stream.memcpy_stod(&tour_i32)?;
   |                 ^^^^^^^^
   |
   = note: consider using `_tour_gpu` instead
   = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `dist_gpu`
  --> src/quantum/src/gpu_k_opt.rs:89:13
   |
89 |         let dist_gpu = stream.memcpy_stod(&dist_flat)?;
   |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_dist_gpu`

warning: unused variable: `best_i_gpu`
  --> src/quantum/src/gpu_k_opt.rs:92:17
   |
92 |         let mut best_i_gpu = stream.alloc_zeros::<i32>(1)?;
   |                 ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_best_i_gpu`

warning: unused variable: `best_j_gpu`
  --> src/quantum/src/gpu_k_opt.rs:93:17
   |
93 |         let mut best_j_gpu = stream.alloc_zeros::<i32>(1)?;
   |                 ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_best_j_gpu`

warning: variable `best_delta_gpu` is assigned to, but never used
  --> src/quantum/src/gpu_k_opt.rs:94:17
   |
94 |         let mut best_delta_gpu = stream.memcpy_stod(&[f32::INFINITY])?;
   |                 ^^^^^^^^^^^^^^
   |
   = note: consider using `_best_delta_gpu` instead

warning: value assigned to `tour_gpu` is never read
   --> src/quantum/src/gpu_k_opt.rs:104:13
    |
104 |             tour_gpu = stream.memcpy_stod(&tour_i32)?;
    |             ^^^^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: value assigned to `best_delta_gpu` is never read
   --> src/quantum/src/gpu_k_opt.rs:108:13
    |
108 |             best_delta_gpu = stream.memcpy_stod(&[f32::INFINITY])?;
    |             ^^^^^^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: unused variable: `block_size`
   --> src/quantum/src/gpu_k_opt.rs:111:17
    |
111 |             let block_size = 16;
    |                 ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_block_size`

warning: unused variable: `cfg`
   --> src/quantum/src/gpu_k_opt.rs:112:17
    |
112 |             let cfg = LaunchConfig {
    |                 ^^^ help: if this is intentional, prefix it with an underscore: `_cfg`

warning: variable does not need to be mutable
  --> src/quantum/src/gpu_k_opt.rs:92:13
   |
92 |         let mut best_i_gpu = stream.alloc_zeros::<i32>(1)?;
   |             ----^^^^^^^^^^
   |             |
   |             help: remove this `mut`

warning: variable does not need to be mutable
  --> src/quantum/src/gpu_k_opt.rs:93:13
   |
93 |         let mut best_j_gpu = stream.alloc_zeros::<i32>(1)?;
   |             ----^^^^^^^^^^
   |             |
   |             help: remove this `mut`

warning: methods `generate_chromatic_coloring` and `optimize_tsp_ordering` are never used
   --> src/quantum/src/hamiltonian.rs:196:8
    |
137 | impl PhaseResonanceField {
    | ------------------------ methods in this implementation
...
196 |     fn generate_chromatic_coloring(&mut self, n_atoms: usize) {
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
220 |     fn optimize_tsp_ordering(&mut self, n_atoms: usize) {
    |        ^^^^^^^^^^^^^^^^^^^^^
    |
    = note: `#[warn(dead_code)]` on by default

warning: fields `masses`, `stencil_order`, and `energy_tolerance` are never read
   --> src/quantum/src/hamiltonian.rs:529:5
    |
522 | pub struct Hamiltonian {
    |            ----------- fields in this struct
...
529 |     masses: Array1<f64>,
    |     ^^^^^^
...
545 |     stencil_order: usize,   // Finite difference stencil order (9-point)
    |     ^^^^^^^^^^^^^
...
575 |     energy_tolerance: f64,
    |     ^^^^^^^^^^^^^^^^
    |
    = note: `Hamiltonian` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: methods `calculate_coupling_strength` and `pauli_dot_product` are never used
    --> src/quantum/src/hamiltonian.rs:1183:8
     |
 581 | impl Hamiltonian {
     | ---------------- methods in this implementation
...
1183 |     fn calculate_coupling_strength(&self, i: usize, j: usize, _t: f64) -> Complex64 {
     |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
1194 |     fn pauli_dot_product(&self, _i: usize, _j: usize) -> Complex64 {
     |        ^^^^^^^^^^^^^^^^^

warning: field `coupling` is never read
  --> src/quantum/src/prct_coloring.rs:33:5
   |
21 | pub struct ChromaticColoring {
   |            ----------------- field in this struct
...
33 |     coupling: Box<Array2<Complex64>>,
   |     ^^^^^^^^
   |
   = note: `ChromaticColoring` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `max_k` is never read
  --> src/quantum/src/gpu_k_opt.rs:14:5
   |
12 | pub struct GpuKOpt {
   |            ------- field in this struct
13 |     context: Arc<CudaContext>,
14 |     max_k: usize,
   |     ^^^^^

warning: `quantum-engine` (lib) generated 27 warnings (run `cargo fix --lib -p quantum-engine` to apply 12 suggestions)
warning: prism-ai@0.1.0: Compiling CUBLAS interposer library for CUDA 12.8 compatibility
warning: prism-ai@0.1.0: Successfully compiled CUBLAS interposer library
warning: prism-ai@0.1.0: Interposer library at: /home/diddy/Desktop/PRISM-AI-DoD/03-Source-Code/target/release/build/prism-ai-0a2a4a3f381a983c/out/libcublas_interposer.so
warning: prism-ai@0.1.0: Compiling CUDA kernels with nvcc: /usr/local/cuda/bin/nvcc
warning: prism-ai@0.1.0: Detected Compute 12.0, using sm_90
warning: prism-ai@0.1.0: Compiling for GPU architecture: sm_90
warning: prism-ai@0.1.0: Compiling cuda_kernels/tensor_core_matmul.cu
warning: prism-ai@0.1.0: Successfully compiled cuda_kernels/tensor_core_matmul.cu to PTX
warning: prism-ai@0.1.0: Compiling neuromorphic kernels to shared library
warning: prism-ai@0.1.0: Successfully compiled neuromorphic kernels to shared library
warning: prism-ai@0.1.0: Library: /home/diddy/Desktop/PRISM-AI-DoD/03-Source-Code/target/release/build/prism-ai-0a2a4a3f381a983c/out/libneuromorphic_kernels.so
warning: unused variable: `state`
   --> src/foundation/src/adp/decision_processor.rs:182:34
    |
182 |     fn generate_reasoning(&self, state: &State, action: Action, features: &[f64]) -> String {
    |                                  ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: field `quantum_hamiltonian` is never read
  --> src/foundation/src/platform.rs:33:5
   |
26 | pub struct NeuromorphicQuantumPlatform {
   |            --------------------------- field in this struct
...
33 |     quantum_hamiltonian: Arc<RwLock<Option<Hamiltonian>>>,
   |     ^^^^^^^^^^^^^^^^^^^
   |
   = note: `NeuromorphicQuantumPlatform` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` on by default

warning: field `state_to_reservoir` is never read
   --> src/foundation/src/platform.rs:101:5
    |
 95 | struct BidirectionalCoupling {
    |        --------------------- field in this struct
...
101 |     state_to_reservoir: f64,
    |     ^^^^^^^^^^^^^^^^^^
    |
    = note: `BidirectionalCoupling` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: methods `ensure_quantum_initialized`, `extract_quantum_features`, and `initialize_quantum_state` are never used
   --> src/foundation/src/platform.rs:758:14
    |
167 | impl NeuromorphicQuantumPlatform {
    | -------------------------------- methods in this implementation
...
758 |     async fn ensure_quantum_initialized(&self, input: &PlatformInput) -> Result<()> {
    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^
...
782 |     async fn extract_quantum_features(&self, _input: &PlatformInput, neuro_results: &NeuromorphicResults) -> Vec<f64> {
    |              ^^^^^^^^^^^^^^^^^^^^^^^^
...
822 |     async fn initialize_quantum_state(&self, hamiltonian: &mut Hamiltonian, features: &[f64]) -> Array1<Complex64> {
    |              ^^^^^^^^^^^^^^^^^^^^^^^^

warning: associated function `ingest_from_source` is never used
   --> src/foundation/src/ingestion/engine.rs:325:14
    |
 69 | impl IngestionEngine {
    | -------------------- associated function in this implementation
...
325 |     async fn ingest_from_source(
    |              ^^^^^^^^^^^^^^^^^^

warning: unused import: `HashMap`
  --> src/prct-core/src/coloring.rs:10:24
   |
10 | use std::collections::{HashMap, HashSet};
   |                        ^^^^^^^
   |
   = note: `#[warn(unused_imports)]` on by default

warning: unused import: `rayon::prelude`
 --> src/prct-core/src/coloring.rs:9:5
  |
9 | use rayon::prelude::*;
  |     ^^^^^^^^^^^^^^

warning: unused variable: `neuro_state`
   --> src/prct-core/src/drpp_algorithm.rs:194:9
    |
194 |         neuro_state: &NeuroState,
    |         ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_neuro_state`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `quantum_state`
   --> src/prct-core/src/drpp_algorithm.rs:195:9
    |
195 |         quantum_state: &QuantumState,
    |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_quantum_state`

warning: unused variable: `phase_field`
   --> src/prct-core/src/drpp_algorithm.rs:196:9
    |
196 |         phase_field: &mut PhaseField,
    |         ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_phase_field`

warning: unused variable: `n`
  --> src/prct-core/src/simulated_annealing.rs:31:9
   |
31 |     let n = graph.num_vertices;
   |         ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: `platform-foundation` (lib) generated 5 warnings
warning: `prct-core` (lib) generated 6 warnings (run `cargo fix --lib -p prct-core` to apply 1 suggestion)
[CUBLAS Interposer] Loaded real CUBLAS: /usr/local/cuda-12.8/lib64/libcublas.so.12
warning: unused import: `rand_distr::Normal`
 --> src/information_theory/advanced_transfer_entropy.rs:9:5
  |
9 | use rand_distr::Normal;
  |     ^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `std::collections::HashMap`
  --> src/information_theory/conditional_te.rs:24:5
   |
24 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> src/information_theory/multivariate_te.rs:24:5
   |
24 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> src/information_theory/time_delayed_te.rs:26:5
   |
26 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Context`
  --> src/orchestration/llm_clients/claude_client.rs:10:22
   |
10 | use anyhow::{Result, Context, bail};
   |                      ^^^^^^^

warning: unused import: `sleep`
 --> src/orchestration/llm_clients/gemini_client.rs:7:19
  |
7 | use tokio::time::{sleep, timeout, Duration, Instant};
  |                   ^^^^^

warning: unused import: `Context`
  --> src/orchestration/llm_clients/grok_client.rs:10:22
   |
10 | use anyhow::{Result, Context, bail};
   |                      ^^^^^^^

warning: unused import: `Duration`
  --> src/orchestration/llm_clients/ensemble.rs:16:28
   |
16 | use tokio::time::{Instant, Duration};
   |                            ^^^^^^^^

warning: unused import: `anyhow::Result`
  --> src/orchestration/thermodynamic/hamiltonian.rs:13:5
   |
13 | use anyhow::Result;
   |     ^^^^^^^^^^^^^^

warning: unused imports: `Array1` and `Array2`
  --> src/orchestration/thermodynamic/advanced_energy.rs:20:15
   |
20 | use ndarray::{Array1, Array2};
   |               ^^^^^^  ^^^^^^

warning: unused import: `Context`
  --> src/orchestration/thermodynamic/temperature_schedules.rs:17:22
   |
17 | use anyhow::{Result, Context};
   |                      ^^^^^^^

warning: unused import: `Context`
  --> src/orchestration/thermodynamic/replica_exchange.rs:15:22
   |
15 | use anyhow::{Result, Context};
   |                      ^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> src/orchestration/thermodynamic/replica_exchange.rs:16:5
   |
16 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Instant`
  --> src/orchestration/active_inference/hierarchical_client.rs:16:29
   |
16 | use tokio::time::{Duration, Instant};
   |                             ^^^^^^^

warning: unused import: `ThreatDetection`
  --> src/orchestration/integration/pwsa_llm_bridge.rs:11:77
   |
11 | use crate::api_server::routes::pwsa::{PwsaFusionPlatform, MissionAwareness, ThreatDetection, OctTelemetry, IrSensorFrame, GroundStationDa...
   |                                                                             ^^^^^^^^^^^^^^^

warning: unused import: `DMatrix`
  --> src/orchestration/integration/mission_charlie_integration.rs:20:25
   |
20 | use nalgebra::{DVector, DMatrix};
   |                         ^^^^^^^

warning: unused import: `parking_lot::RwLock`
  --> src/orchestration/integration/mission_charlie_integration.rs:23:5
   |
23 | use parking_lot::RwLock;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `nalgebra as na`
  --> src/orchestration/integration/prism_ai_integration.rs:14:5
   |
14 | use nalgebra as na;
   |     ^^^^^^^^^^^^^^

warning: unused import: `Array2`
  --> src/orchestration/integration/prism_ai_integration.rs:15:15
   |
15 | use ndarray::{Array2, Array1};
   |               ^^^^^^

warning: unused import: `std::time::SystemTime`
  --> src/orchestration/integration/prism_ai_integration.rs:17:5
   |
17 | use std::time::SystemTime;
   |     ^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `ActiveInferenceController`, `CausalDirection`, `CouplingStrength`, `EvolutionResult`, `ExecutionConfig`, `GenerativeModel`, `InformationChannel`, `PhaseSynchronizer`, `PolicySelector`, `SystemState`, `TransferEntropyResult`, `TransferEntropy`, `compile_and_execute`, and `detect_causal_direction`
  --> src/orchestration/integration/prism_ai_integration.rs:23:9
   |
23 |         GenerativeModel, HierarchicalModel, VariationalInference,
   |         ^^^^^^^^^^^^^^^
24 |         PolicySelector, ActiveInferenceController, FreeEnergyComponents,
   |         ^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^
...
29 |         ThermodynamicMetrics, EvolutionResult,
   |                               ^^^^^^^^^^^^^^^
...
33 |         TransferEntropy, TransferEntropyResult, CausalDirection,
   |         ^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^
34 |         detect_causal_direction,
   |         ^^^^^^^^^^^^^^^^^^^^^^^
...
38 |         CrossDomainBridge, DomainState, CouplingStrength,
   |                                         ^^^^^^^^^^^^^^^^
39 |         InformationChannel, PhaseSynchronizer, UnifiedPlatform,
   |         ^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^
...
44 |         HealthMonitor, ComponentHealth, HealthStatus, SystemState, SystemHealthState,
   |                                                       ^^^^^^^^^^^
...
50 |         compile_and_execute, ExecutionConfig,
   |         ^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^

warning: unused imports: `LLMResponse` and `OrchestrationError`
  --> src/orchestration/integration/prism_ai_integration.rs:77:32
   |
77 |     MissionCharlieIntegration, OrchestrationError, LLMResponse,
   |                                ^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^

warning: unused import: `anyhow::Result`
  --> src/orchestration/optimization/mdl_prompt_optimizer.rs:13:5
   |
13 | use anyhow::Result;
   |     ^^^^^^^^^^^^^^

warning: unused import: `std::io::Write`
  --> src/orchestration/optimization/mdl_prompt_optimizer.rs:51:13
   |
51 |         use std::io::Write;
   |             ^^^^^^^^^^^^^^

warning: unused import: `SymmetricEigen`
 --> src/orchestration/optimization/geometric_manifold.rs:8:39
  |
8 | use nalgebra::{DMatrix, DVector, SVD, SymmetricEigen};
  |                                       ^^^^^^^^^^^^^^

warning: unused import: `anyhow::Result`
  --> src/orchestration/caching/quantum_semantic_cache.rs:16:5
   |
16 | use anyhow::Result;
   |     ^^^^^^^^^^^^^^

warning: unused import: `Array1`
  --> src/orchestration/routing/te_embedding_gpu.rs:12:15
   |
12 | use ndarray::{Array1, Array2};
   |               ^^^^^^

warning: unused import: `Context as AnyhowContext`
  --> src/orchestration/routing/ksg_transfer_entropy_gpu.rs:17:22
   |
17 | use anyhow::{Result, Context as AnyhowContext};
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Array1`
  --> src/orchestration/routing/ksg_transfer_entropy_gpu.rs:18:15
   |
18 | use ndarray::{Array1, Array2, Axis};
   |               ^^^^^^

warning: unused import: `ndarray::Array1`
 --> src/orchestration/routing/te_validation.rs:7:5
  |
7 | use ndarray::Array1;
  |     ^^^^^^^^^^^^^^^

warning: unused import: `anyhow::Result`
  --> src/orchestration/validation/info_theoretic_validator.rs:12:5
   |
12 | use anyhow::Result;
   |     ^^^^^^^^^^^^^^

warning: unused imports: `Array1` and `Array2`
  --> src/orchestration/semantic_analysis/distance_metrics.rs:14:15
   |
14 | use ndarray::{Array1, Array2};
   |               ^^^^^^  ^^^^^^

warning: unused import: `Normal`
  --> src/orchestration/neuromorphic/unified_neuromorphic.rs:10:41
   |
10 | use rand_distr::{Distribution, Poisson, Normal};  // Fixed: rand_distr not rand
   |                                         ^^^^^^

warning: unused import: `ordered_float::OrderedFloat`
  --> src/orchestration/neuromorphic/unified_neuromorphic.rs:11:5
   |
11 | use ordered_float::OrderedFloat;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::gpu::GpuKernelExecutor`
 --> src/orchestration/neuromorphic/gpu_neuromorphic.rs:7:5
  |
7 | use crate::gpu::GpuKernelExecutor;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::gpu::neuromorphic_ffi::*`
 --> src/orchestration/neuromorphic/gpu_neuromorphic.rs:8:5
  |
8 | use crate::gpu::neuromorphic_ffi::*;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `CudaSlice`
 --> src/orchestration/neuromorphic/gpu_neuromorphic.rs:9:35
  |
9 | use cudarc::driver::{CudaContext, CudaSlice};
  |                                   ^^^^^^^^^

warning: unused imports: `DMatrix` and `DVector`
  --> src/orchestration/neuromorphic/gpu_neuromorphic.rs:10:16
   |
10 | use nalgebra::{DMatrix, DVector};
   |                ^^^^^^^  ^^^^^^^

warning: unused import: `std::sync::Arc`
  --> src/orchestration/local_llm/gpu_llm_inference.rs:15:5
   |
15 | use std::sync::Arc;
   |     ^^^^^^^^^^^^^^

warning: unused import: `cudarc::driver::CudaContext`
  --> src/orchestration/local_llm/gpu_llm_inference.rs:16:5
   |
16 | use cudarc::driver::CudaContext;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `GpuTransformerLayer`
  --> src/orchestration/local_llm/gpu_llm_inference.rs:18:30
   |
18 | use super::gpu_transformer::{GpuTransformerLayer, GpuLLMInference};
   |                              ^^^^^^^^^^^^^^^^^^^

warning: variant `Q2_K` should have an upper camel case name
  --> src/orchestration/local_llm/gguf_loader.rs:45:5
   |
45 |     Q2_K = 10,
   |     ^^^^ help: convert the identifier to upper camel case: `Q2K`
   |
   = note: `#[warn(non_camel_case_types)]` on by default

warning: variant `Q3_K` should have an upper camel case name
  --> src/orchestration/local_llm/gguf_loader.rs:46:5
   |
46 |     Q3_K = 11,
   |     ^^^^ help: convert the identifier to upper camel case: `Q3K`

warning: variant `Q4_K` should have an upper camel case name
  --> src/orchestration/local_llm/gguf_loader.rs:47:5
   |
47 |     Q4_K = 12,
   |     ^^^^ help: convert the identifier to upper camel case: `Q4K`

warning: variant `Q5_K` should have an upper camel case name
  --> src/orchestration/local_llm/gguf_loader.rs:48:5
   |
48 |     Q5_K = 13,
   |     ^^^^ help: convert the identifier to upper camel case: `Q5K`

warning: variant `Q6_K` should have an upper camel case name
  --> src/orchestration/local_llm/gguf_loader.rs:49:5
   |
49 |     Q6_K = 14,
   |     ^^^^ help: convert the identifier to upper camel case: `Q6K`

warning: variant `Q8_K` should have an upper camel case name
  --> src/orchestration/local_llm/gguf_loader.rs:50:5
   |
50 |     Q8_K = 15,
   |     ^^^^ help: convert the identifier to upper camel case: `Q8K`

warning: unused import: `anyhow::Result`
  --> src/orchestration/local_llm/attention_analyzer.rs:23:5
   |
23 | use anyhow::Result;
   |     ^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> src/orchestration/local_llm/transfer_entropy_llm.rs:31:5
   |
31 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `BTreeMap`
 --> src/orchestration/decomposition/pid_synergy.rs:9:42
  |
9 | use std::collections::{HashMap, HashSet, BTreeMap, BTreeSet};
  |                                          ^^^^^^^^

warning: unused import: `VecDeque`
 --> src/orchestration/inference/hierarchical_active_inference.rs:9:33
  |
9 | use std::collections::{HashMap, VecDeque};
  |                                 ^^^^^^^^

warning: unused import: `rand_distr::Normal`
  --> src/orchestration/inference/hierarchical_active_inference.rs:11:5
   |
11 | use rand_distr::Normal;
   |     ^^^^^^^^^^^^^^^^^^

warning: unused import: `SVD`
 --> src/orchestration/causality/bidirectional_causality.rs:8:34
  |
8 | use nalgebra::{DMatrix, DVector, SVD};
  |                                  ^^^

warning: unused import: `VecDeque`
 --> src/orchestration/causality/bidirectional_causality.rs:9:42
  |
9 | use std::collections::{HashMap, HashSet, VecDeque};
  |                                          ^^^^^^^^

warning: unused import: `rand_distr::Normal`
  --> src/orchestration/causality/bidirectional_causality.rs:12:5
   |
12 | use rand_distr::Normal;
   |     ^^^^^^^^^^^^^^^^^^

warning: unused import: `Complex`
 --> src/orchestration/quantum/quantum_entanglement_measures.rs:8:34
  |
8 | use nalgebra::{DMatrix, DVector, Complex, SymmetricEigen};
  |                                  ^^^^^^^

warning: unused import: `VecDeque`
  --> src/orchestration/quantum/quantum_entanglement_measures.rs:10:33
   |
10 | use std::collections::{HashMap, VecDeque};
   |                                 ^^^^^^^^

warning: unused import: `Context as AnyhowContext`
 --> src/gpu/gpu_enabled.rs:5:22
  |
5 | use anyhow::{Result, Context as AnyhowContext};
  |                      ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Arc`
 --> src/gpu/cublas_compat.rs:8:17
  |
8 | use std::sync::{Arc, OnceLock};
  |                 ^^^

warning: unused import: `Context`
 --> src/gpu/production_runtime.rs:9:22
  |
9 | use anyhow::{Result, Context};
  |                      ^^^^^^^

warning: unused import: `std::ffi::c_void`
   --> src/gpu/cudarc_replacement.rs:116:17
    |
116 |             use std::ffi::c_void;
    |                 ^^^^^^^^^^^^^^^^

warning: unused import: `cudarc::driver::sys`
   --> src/cma/gpu_integration.rs:159:21
    |
159 |                 use cudarc::driver::sys;
    |                     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::sync::Arc`
  --> src/assistant/local_llm/gpu_llm_inference.rs:15:5
   |
15 | use std::sync::Arc;
   |     ^^^^^^^^^^^^^^

warning: unused import: `cudarc::driver::CudaContext`
  --> src/assistant/local_llm/gpu_llm_inference.rs:16:5
   |
16 | use cudarc::driver::CudaContext;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `GpuTransformerLayer`
  --> src/assistant/local_llm/gpu_llm_inference.rs:18:56
   |
18 | use crate::orchestration::local_llm::gpu_transformer::{GpuTransformerLayer, GpuLLMInference};
   |                                                        ^^^^^^^^^^^^^^^^^^^

warning: variant `Q2_K` should have an upper camel case name
  --> src/assistant/local_llm/gguf_loader.rs:45:5
   |
45 |     Q2_K = 10,
   |     ^^^^ help: convert the identifier to upper camel case: `Q2K`

warning: variant `Q3_K` should have an upper camel case name
  --> src/assistant/local_llm/gguf_loader.rs:46:5
   |
46 |     Q3_K = 11,
   |     ^^^^ help: convert the identifier to upper camel case: `Q3K`

warning: variant `Q4_K` should have an upper camel case name
  --> src/assistant/local_llm/gguf_loader.rs:47:5
   |
47 |     Q4_K = 12,
   |     ^^^^ help: convert the identifier to upper camel case: `Q4K`

warning: variant `Q5_K` should have an upper camel case name
  --> src/assistant/local_llm/gguf_loader.rs:48:5
   |
48 |     Q5_K = 13,
   |     ^^^^ help: convert the identifier to upper camel case: `Q5K`

warning: variant `Q6_K` should have an upper camel case name
  --> src/assistant/local_llm/gguf_loader.rs:49:5
   |
49 |     Q6_K = 14,
   |     ^^^^ help: convert the identifier to upper camel case: `Q6K`

warning: variant `Q8_K` should have an upper camel case name
  --> src/assistant/local_llm/gguf_loader.rs:50:5
   |
50 |     Q8_K = 15,
   |     ^^^^ help: convert the identifier to upper camel case: `Q8K`

warning: unused variable: `input`
  --> src/api_server/graphql_schema.rs:55:9
   |
55 |         input: PortfolioOptimizationInput,
   |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_input`
   |
   = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `input`
  --> src/api_server/graphql_schema.rs:82:9
   |
82 |         input: MotionPlanInput,
   |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_input`

warning: unused variable: `input`
   --> src/api_server/graphql_schema.rs:127:9
    |
127 |         input: HealthcareRiskInput,
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_input`

warning: unused variable: `input`
   --> src/api_server/graphql_schema.rs:140:9
    |
140 |         input: EnergyForecastInput,
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_input`

warning: unused variable: `input`
   --> src/api_server/graphql_schema.rs:198:9
    |
198 |         input: PortfolioOptimizationInput,
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_input`

warning: unused variable: `input`
   --> src/api_server/graphql_schema.rs:216:9
    |
216 |         input: MotionPlanInput,
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_input`

warning: variable does not need to be mutable
   --> src/orchestration/llm_clients/openai_client.rs:126:13
    |
126 |         let mut last = self.last_request.lock().await;
    |             ----^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` on by default

warning: unused variable: `start`
   --> src/orchestration/llm_clients/ensemble.rs:129:13
    |
129 |         let start = Instant::now();
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_start`

warning: unused variable: `manifold_result`
   --> src/orchestration/integration/mission_charlie_integration.rs:260:13
    |
260 |         let manifold_result = self.manifold_optimizer.optimize_llm_responses(
    |             ^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_manifold_result`

warning: unused variable: `context`
   --> src/orchestration/integration/prism_ai_integration.rs:249:45
    |
249 |         let sensor_assessment = if let Some(context) = sensor_context {
    |                                             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_context`

warning: unused variable: `state`
   --> src/orchestration/integration/prism_ai_integration.rs:291:17
    |
291 |             let state = self.response_to_state(&charlie_response);
    |                 ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `bridged_result`
   --> src/orchestration/integration/prism_ai_integration.rs:296:13
    |
296 |         let bridged_result = {
    |             ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_bridged_result`

warning: variable does not need to be mutable
   --> src/orchestration/integration/prism_ai_integration.rs:327:17
    |
327 |             let mut health = self.health_monitor.write();
    |                 ----^^^^^^
    |                 |
    |                 help: remove this `mut`

warning: unused variable: `hamiltonian`
   --> src/phase6/integration.rs:240:9
    |
240 |         hamiltonian: &ModulatedHamiltonian,
    |         ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_hamiltonian`

warning: unused variable: `n`
   --> src/phase6/integration.rs:242:13
    |
242 |         let n = adjacency.nrows();
    |             ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: unused variable: `initial_state`
   --> src/phase6/integration.rs:267:9
    |
267 |         initial_state: &Array1<f64>,
    |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_initial_state`

warning: unused variable: `avg_temp`
   --> src/phase6/integration.rs:271:13
    |
271 |         let avg_temp = hamiltonian.local_temperature.mean().unwrap_or(1.0);
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_avg_temp`

warning: unused variable: `state`
  --> src/api_server/routes/pwsa.rs:95:11
   |
95 |     State(state): State<Arc<AppState>>,
   |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/pwsa.rs:140:11
    |
140 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/pwsa.rs:159:11
    |
159 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/pwsa.rs:179:11
    |
179 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/finance.rs:103:11
    |
103 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/finance.rs:195:11
    |
195 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/finance.rs:215:11
    |
215 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/finance.rs:233:11
    |
233 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/finance.rs:299:11
    |
299 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `request`
   --> src/api_server/routes/finance.rs:300:10
    |
300 |     Json(request): Json<BacktestRequest>,
    |          ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_request`

warning: unused variable: `req`
   --> src/api_server/routes/finance_advanced.rs:258:10
    |
258 |     Json(req): Json<GnnPortfolioPredictionRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/finance_advanced.rs:293:10
    |
293 |     Json(req): Json<TransferEntropyCausalityRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/finance_advanced.rs:321:10
    |
321 |     Json(req): Json<PortfolioRebalancingRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `state`
   --> src/api_server/routes/telecom.rs:101:11
    |
101 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/telecom.rs:122:11
    |
122 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/telecom.rs:142:11
    |
142 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/telecom.rs:157:11
    |
157 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
  --> src/api_server/routes/robotics.rs:83:11
   |
83 |     State(state): State<Arc<AppState>>,
   |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/robotics.rs:168:11
    |
168 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/robotics.rs:185:11
    |
185 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/robotics.rs:208:11
    |
208 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
  --> src/api_server/routes/llm.rs:85:11
   |
85 |     State(state): State<Arc<AppState>>,
   |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/llm.rs:105:11
    |
105 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/llm.rs:125:11
    |
125 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/llm.rs:161:11
    |
161 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/llm.rs:180:11
    |
180 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/time_series.rs:122:11
    |
122 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/time_series.rs:241:11
    |
241 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/time_series.rs:263:11
    |
263 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/time_series.rs:287:11
    |
287 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/time_series.rs:306:11
    |
306 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/pixels.rs:144:11
    |
144 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/pixels.rs:201:11
    |
201 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/pixels.rs:221:11
    |
221 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/pixels.rs:240:11
    |
240 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/pixels.rs:258:11
    |
258 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:296:10
    |
296 |     Json(req): Json<HealthcareRiskRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:329:10
    |
329 |     Json(req): Json<EnergyForecastRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:346:10
    |
346 |     Json(req): Json<ManufacturingMaintenanceRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:362:10
    |
362 |     Json(req): Json<SupplyChainDemandRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:377:10
    |
377 |     Json(req): Json<AgricultureYieldRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:394:10
    |
394 |     Json(req): Json<CybersecurityThreatRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:414:10
    |
414 |     Json(req): Json<ClimateForecastRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:427:10
    |
427 |     Json(req): Json<SmartCityOptimizationRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:443:10
    |
443 |     Json(req): Json<EducationPerformanceRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:468:10
    |
468 |     Json(req): Json<RetailInventoryRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:481:10
    |
481 |     Json(req): Json<ConstructionForecastRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `state`
  --> src/api_server/websocket.rs:76:43
   |
76 | async fn handle_socket(socket: WebSocket, state: Arc<AppState>) {
   |                                           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused import: `Context`
  --> src/statistical_mechanics/gpu.rs:15:30
   |
15 | use anyhow::{Result, anyhow, Context};
   |                              ^^^^^^^

warning: unused import: `Context`
  --> src/active_inference/gpu.rs:16:30
   |
16 | use anyhow::{Result, anyhow, Context};
   |                              ^^^^^^^

warning: unused import: `Read`
  --> src/resilience/checkpoint_manager.rs:38:15
   |
38 | use std::io::{Read, Write};
   |               ^^^^

warning: unused import: `Distribution`
  --> src/orchestration/neuromorphic/unified_neuromorphic.rs:10:18
   |
10 | use rand_distr::{Distribution, Poisson, Normal};  // Fixed: rand_distr not rand
   |                  ^^^^^^^^^^^^

warning: unused import: `rand::distributions::Distribution`
  --> src/orchestration/inference/hierarchical_active_inference.rs:10:5
   |
10 | use rand::distributions::Distribution;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rand::distributions::Distribution`
  --> src/orchestration/causality/bidirectional_causality.rs:11:5
   |
11 | use rand::distributions::Distribution;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Context`
 --> src/quantum_mlir/runtime.rs:6:22
  |
6 | use anyhow::{Result, Context};
  |                      ^^^^^^^

warning: unused import: `sha2::Digest`
  --> src/cma/guarantees/mod.rs:16:5
   |
16 | use sha2::Digest;
   |     ^^^^^^^^^^^^

warning: unused import: `gpu_integration::GpuSolvable`
   --> src/cma/mod.rs:127:13
    |
127 |         use gpu_integration::GpuSolvable;
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused variable: `psi_n`
   --> src/information_theory/transfer_entropy.rs:391:13
    |
391 |         let psi_n = digamma(n as f64);
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_psi_n`

warning: value assigned to `count_greater` is never read
   --> src/information_theory/transfer_entropy.rs:487:17
    |
487 |         let mut count_greater = 0;
    |                 ^^^^^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?
    = note: `#[warn(unused_assignments)]` on by default

warning: unused variable: `rng`
   --> src/information_theory/transfer_entropy.rs:491:17
    |
491 |             let rng = rand::thread_rng();
    |                 ^^^ help: if this is intentional, prefix it with an underscore: `_rng`

warning: unused variable: `lag_xy`
   --> src/information_theory/transfer_entropy.rs:672:10
    |
672 |     let (lag_xy, result_xy) = te_calc.find_optimal_lag(x, y, max_lag);
    |          ^^^^^^ help: if this is intentional, prefix it with an underscore: `_lag_xy`

warning: unused variable: `lag_yx`
   --> src/information_theory/transfer_entropy.rs:675:10
    |
675 |     let (lag_yx, result_yx) = te_calc.find_optimal_lag(y, x, max_lag);
    |          ^^^^^^ help: if this is intentional, prefix it with an underscore: `_lag_yx`

warning: unused variable: `source_i`
   --> src/information_theory/advanced_transfer_entropy.rs:614:38
    |
614 |     pub fn unique_information(&self, source_i: &Array1<f64>,
    |                                      ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_source_i`

warning: unused variable: `other_sources`
   --> src/information_theory/advanced_transfer_entropy.rs:615:30
    |
615 | ...                   other_sources: &[Array1<f64>],
    |                       ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_other_sources`

warning: unused variable: `target`
   --> src/information_theory/advanced_transfer_entropy.rs:616:30
    |
616 | ...                   target: &Array1<f64>) -> f64 {
    |                       ^^^^^^ help: if this is intentional, prefix it with an underscore: `_target`

warning: unused variable: `sources`
   --> src/information_theory/advanced_transfer_entropy.rs:640:43
    |
640 |     pub fn synergistic_information(&self, sources: &[Array1<f64>],
    |                                           ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_sources`

warning: unused variable: `target`
   --> src/information_theory/advanced_transfer_entropy.rs:641:35
    |
641 | ...                   target: &Array1<f64>) -> f64 {
    |                       ^^^^^^ help: if this is intentional, prefix it with an underscore: `_target`

warning: unused variable: `n`
  --> src/information_theory/ksg_estimator.rs:66:13
   |
66 |         let n = source.len();
   |             ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: unused variable: `tree_dim_plus`
   --> src/information_theory/ksg_estimator.rs:349:13
    |
349 |         let tree_dim_plus = KdTree::new(&points_dim_plus);
    |             ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_tree_dim_plus`

warning: unused variable: `dist_cond`
   --> src/information_theory/conditional_te.rs:250:17
    |
250 |             let dist_cond = self.find_kth_neighbor_distance_cond(emb, i)?;
    |                 ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_dist_cond`

warning: unused variable: `x_embed`
   --> src/information_theory/transfer_entropy_gpu.rs:161:26
    |
161 |     fn gpu_ksg_te(&self, x_embed: &[Vec<f64>], y_embed: &[Vec<f64>], y_future: &[f64]) -> Result<f64> {
    |                          ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_x_embed`

warning: unused variable: `y_embed`
   --> src/information_theory/transfer_entropy_gpu.rs:161:48
    |
161 |     fn gpu_ksg_te(&self, x_embed: &[Vec<f64>], y_embed: &[Vec<f64>], y_future: &[f64]) -> Result<f64> {
    |                                                ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_y_embed`

warning: unused variable: `y_future`
   --> src/information_theory/transfer_entropy_gpu.rs:161:70
    |
161 |     fn gpu_ksg_te(&self, x_embed: &[Vec<f64>], y_embed: &[Vec<f64>], y_future: &[f64]) -> Result<f64> {
    |                                                                      ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_y_future`

warning: unused variable: `source`
   --> src/information_theory/transfer_entropy_gpu.rs:168:36
    |
168 |     fn gpu_permutation_test(&self, source: &Array1<f64>, target: &Array1<f64>, observed_te: f64) -> Result<f64> {
    |                                    ^^^^^^ help: if this is intentional, prefix it with an underscore: `_source`

warning: unused variable: `target`
   --> src/information_theory/transfer_entropy_gpu.rs:168:58
    |
168 |     fn gpu_permutation_test(&self, source: &Array1<f64>, target: &Array1<f64>, observed_te: f64) -> Result<f64> {
    |                                                          ^^^^^^ help: if this is intentional, prefix it with an underscore: `_target`

warning: unused variable: `observed_te`
   --> src/information_theory/transfer_entropy_gpu.rs:168:80
    |
168 |     fn gpu_permutation_test(&self, source: &Array1<f64>, target: &Array1<f64>, observed_te: f64) -> Result<f64> {
    |                                                                                ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_observed_te`

warning: unused variable: `source`
   --> src/information_theory/transfer_entropy_gpu.rs:174:36
    |
174 |     fn gpu_ksg_significance(&self, source: &Array1<f64>, target: &Array1<f64>, observed_te: f64) -> Result<f64> {
    |                                    ^^^^^^ help: if this is intentional, prefix it with an underscore: `_source`

warning: unused variable: `target`
   --> src/information_theory/transfer_entropy_gpu.rs:174:58
    |
174 |     fn gpu_ksg_significance(&self, source: &Array1<f64>, target: &Array1<f64>, observed_te: f64) -> Result<f64> {
    |                                                          ^^^^^^ help: if this is intentional, prefix it with an underscore: `_target`

warning: unused variable: `observed_te`
   --> src/information_theory/transfer_entropy_gpu.rs:174:80
    |
174 |     fn gpu_ksg_significance(&self, source: &Array1<f64>, target: &Array1<f64>, observed_te: f64) -> Result<f64> {
    |                                                                                ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_observed_te`

warning: unused variable: `mi_y_x1`
   --> src/information_theory/pid.rs:227:13
    |
227 |         let mi_y_x1 = self.mutual_information(y, x1)?;
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_mi_y_x1`

warning: unused variable: `mi_y_x2`
   --> src/information_theory/pid.rs:228:13
    |
228 |         let mi_y_x2 = self.mutual_information(y, x2)?;
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_mi_y_x2`

warning: unused variable: `mi_y_x1x2`
   --> src/information_theory/pid.rs:229:13
    |
229 |         let mi_y_x1x2 = self.mutual_information_joint(y, x1, x2)?;
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_mi_y_x1x2`

warning: unused variable: `dtheta`
   --> src/statistical_mechanics/thermodynamic_network.rs:273:13
    |
273 |         let dtheta = 2.0 * PI / 10.0; // 10 bins in phase
    |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_dtheta`

warning: unused variable: `dv`
   --> src/statistical_mechanics/thermodynamic_network.rs:274:13
    |
274 |         let dv = (KB * temperature).sqrt() / 5.0; // 5 bins in velocity
    |             ^^ help: if this is intentional, prefix it with an underscore: `_dv`

warning: unused variable: `natural_frequencies`
   --> src/statistical_mechanics/thermodynamic_network.rs:296:9
    |
296 |         natural_frequencies: &[f64],
    |         ^^^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_natural_frequencies`

warning: unused variable: `initial_entropy`
   --> src/statistical_mechanics/thermodynamic_network.rs:416:13
    |
416 |         let initial_entropy = self.state.entropy;
    |             ^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_initial_entropy`

warning: unused variable: `order_r`
   --> src/statistical_mechanics/gpu.rs:266:13
    |
266 |         let order_r = (order_real_vec[0]*order_real_vec[0] + order_imag_vec[0]*order_imag_vec[0]).sqrt() / (n as f64);
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_order_r`

warning: unused variable: `horizon`
   --> src/active_inference/hierarchical_model.rs:434:31
    |
434 |     pub fn predict(&mut self, horizon: f64) {
    |                               ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_horizon`

warning: unused variable: `weighted_dynamical`
   --> src/active_inference/variational_inference.rs:225:13
    |
225 |         let weighted_dynamical = &dynamical_error * &model.level1.belief.precision;
    |             ^^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_weighted_dynamical`

warning: unused variable: `action`
  --> src/active_inference/controller.rs:43:17
   |
43 |             let action = self.controller.control(&test_model);
   |                 ^^^^^^ help: if this is intentional, prefix it with an underscore: `_action`

warning: unused variable: `obs`
  --> src/active_inference/controller.rs:46:17
   |
46 |             let obs = Array1::<f64>::ones(100);  // Simplified
   |                 ^^^ help: if this is intentional, prefix it with an underscore: `_obs`

warning: unused variable: `num_steps`
  --> src/active_inference/controller.rs:66:9
   |
66 |         num_steps: usize,
   |         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_num_steps`

warning: unused variable: `jacobian_f32`
   --> src/active_inference/gpu_inference.rs:172:13
    |
172 |         let jacobian_f32: Vec<f32> = jacobian.as_slice().unwrap()
    |             ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_jacobian_f32`

warning: unused variable: `error_f32`
   --> src/active_inference/gpu_inference.rs:174:13
    |
174 |         let error_f32: Vec<f32> = error.as_slice().unwrap()
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_error_f32`

warning: unused variable: `diffusion`
   --> src/active_inference/gpu_inference.rs:261:13
    |
261 |         let diffusion = level.diffusion;
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_diffusion`

warning: unused variable: `predicted`
   --> src/active_inference/gpu_inference.rs:326:17
    |
326 |             let predicted = self.predict_observations_gpu(
    |                 ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_predicted`

warning: unused variable: `model`
   --> src/active_inference/gpu_policy_eval.rs:684:42
    |
684 |     fn compute_efe_components(&mut self, model: &HierarchicalModel) -> Result<()> {
    |                                          ^^^^^ help: if this is intentional, prefix it with an underscore: `_model`

warning: unused variable: `t`
   --> src/active_inference/policy_search_gpu.rs:380:18
    |
380 |             for (t, base_action) in base_policy.actions.iter().enumerate() {
    |                  ^ help: if this is intentional, prefix it with an underscore: `_t`

warning: unused variable: `j`
  --> src/integration/information_channel.rs:60:22
   |
60 |                 for (j, &p_y_given_x) in self.transition_matrix.column(i).iter().enumerate() {
   |                      ^ help: if this is intentional, prefix it with an underscore: `_j`

warning: unused variable: `performance`
   --> src/integration/unified_platform.rs:101:13
    |
101 |         let performance = self.total_latency_ms < 500.0;
    |             ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_performance`

warning: unused variable: `exec`
   --> src/integration/multi_modal_reasoner.rs:216:13
    |
216 |         let exec = self.executor.lock().unwrap();
    |             ^^^^ help: if this is intentional, prefix it with an underscore: `_exec`

warning: unused variable: `conf_gpu`
   --> src/integration/multi_modal_reasoner.rs:220:13
    |
220 |         let conf_gpu = stream.memcpy_stod(&confidences)?;
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_conf_gpu`

warning: unused variable: `n`
  --> src/orchestration/llm_clients/ensemble.rs:68:13
   |
68 |         let n = llm_clients.len();
   |             ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: unused variable: `n`
   --> src/orchestration/thermodynamic/advanced_energy.rs:188:13
    |
188 |         let n = self.models.len();
    |             ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: unused variable: `kernel`
   --> src/orchestration/thermodynamic/advanced_energy.rs:244:13
    |
244 |         let kernel = executor_lock.get_kernel("weighted_energy_sum")?;
    |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_kernel`

warning: unused variable: `costs_dev`
   --> src/orchestration/thermodynamic/advanced_energy.rs:249:13
    |
249 |         let costs_dev = stream.memcpy_stod(costs)?;
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_costs_dev`

warning: unused variable: `qualities_dev`
   --> src/orchestration/thermodynamic/advanced_energy.rs:250:13
    |
250 |         let qualities_dev = stream.memcpy_stod(qualities)?;
    |             ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_qualities_dev`

warning: unused variable: `latencies_dev`
   --> src/orchestration/thermodynamic/advanced_energy.rs:251:13
    |
251 |         let latencies_dev = stream.memcpy_stod(latencies)?;
    |             ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_latencies_dev`

warning: unused variable: `uncertainties_dev`
   --> src/orchestration/thermodynamic/advanced_energy.rs:252:13
    |
252 |         let uncertainties_dev = stream.memcpy_stod(uncertainties)?;
    |             ^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_uncertainties_dev`

warning: unused variable: `cfg`
   --> src/orchestration/thermodynamic/advanced_energy.rs:265:13
    |
265 |         let cfg = cudarc::driver::LaunchConfig {
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_cfg`

warning: unused variable: `energies_f32`
   --> src/orchestration/thermodynamic/advanced_energy.rs:279:13
    |
279 |         let energies_f32: Vec<f32> = costs.iter().zip(qualities.iter()).zip(latencies.iter()).zip(uncertainties.iter())
    |             ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_energies_f32`

warning: unnecessary `unsafe` block
   --> src/orchestration/thermodynamic/advanced_energy.rs:271:9
    |
271 |         unsafe {
    |         ^^^^^^ unnecessary `unsafe` block
    |
    = note: `#[warn(unused_unsafe)]` on by default

warning: variable does not need to be mutable
   --> src/orchestration/thermodynamic/advanced_energy.rs:253:13
    |
253 |         let mut energies_dev = stream.alloc_zeros::<f32>(n)?;
    |             ----^^^^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `n_accepted`
   --> src/orchestration/thermodynamic/replica_exchange.rs:145:13
    |
145 |         let n_accepted = self.exchange_manager.exchange_round();
    |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_n_accepted`

warning: unused variable: `g`
   --> src/orchestration/optimization/geometric_manifold.rs:960:13
    |
960 |         let g = (self.manifold.metric.g)(x);
    |             ^ help: if this is intentional, prefix it with an underscore: `_g`

warning: unused variable: `tangent`
    --> src/orchestration/optimization/geometric_manifold.rs:1365:17
     |
1365 |             let tangent = &geodesic.tangents[i];
     |                 ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_tangent`

warning: unused variable: `g0_inv`
    --> src/orchestration/optimization/geometric_manifold.rs:1371:26
     |
1371 |             if let (Some(g0_inv), Some(g1_inv)) = (g0.clone().try_inverse(), g1.try_inverse()) {
     |                          ^^^^^^ help: if this is intentional, prefix it with an underscore: `_g0_inv`

warning: unused variable: `manifold_dimension`
    --> src/orchestration/optimization/geometric_manifold.rs:1396:13
     |
1396 |         let manifold_dimension = self.manifold.dimension;
     |             ^^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_manifold_dimension`

warning: unused variable: `kernel`
  --> src/orchestration/routing/te_embedding_gpu.rs:93:13
   |
93 |         let kernel = executor_lock.get_kernel("time_delayed_embedding")?;
   |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_kernel`

warning: unused variable: `ts_dev`
  --> src/orchestration/routing/te_embedding_gpu.rs:97:13
   |
97 |         let ts_dev = stream.memcpy_stod(&time_series_f32)?;
   |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_ts_dev`

warning: value assigned to `embedded_dev` is never read
  --> src/orchestration/routing/te_embedding_gpu.rs:98:17
   |
98 |         let mut embedded_dev = stream.alloc_zeros::<f32>(n_embedded * embedding_dim)?;
   |                 ^^^^^^^^^^^^
   |
   = help: maybe it is overwritten before being read?

warning: unused variable: `cfg`
   --> src/orchestration/routing/te_embedding_gpu.rs:104:13
    |
104 |         let cfg = LaunchConfig {
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_cfg`

warning: unnecessary `unsafe` block
   --> src/orchestration/routing/te_embedding_gpu.rs:110:9
    |
110 |         unsafe {
    |         ^^^^^^ unnecessary `unsafe` block

warning: unused variable: `kernel`
   --> src/orchestration/routing/gpu_kdtree.rs:170:13
    |
170 |         let kernel = executor_lock.get_kernel("compute_distances")?;
    |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_kernel`

warning: unused variable: `dataset_dev`
   --> src/orchestration/routing/gpu_kdtree.rs:174:13
    |
174 |         let dataset_dev = stream.memcpy_stod(&dataset_f32)?;
    |             ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_dataset_dev`

warning: unused variable: `query_dev`
   --> src/orchestration/routing/gpu_kdtree.rs:175:13
    |
175 |         let query_dev = stream.memcpy_stod(&query_f32)?;
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_query_dev`

warning: value assigned to `distances_dev` is never read
   --> src/orchestration/routing/gpu_kdtree.rs:176:17
    |
176 |         let mut distances_dev = stream.alloc_zeros::<f32>(n_points)?;
    |                 ^^^^^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: unused variable: `cfg`
   --> src/orchestration/routing/gpu_kdtree.rs:182:13
    |
182 |         let cfg = LaunchConfig {
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_cfg`

warning: unnecessary `unsafe` block
   --> src/orchestration/routing/gpu_kdtree.rs:188:9
    |
188 |         unsafe {
    |         ^^^^^^ unnecessary `unsafe` block

warning: variable does not need to be mutable
   --> src/orchestration/routing/te_validation.rs:367:13
    |
367 |         let mut total = results.len();
    |             ----^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `dim`
    --> src/orchestration/neuromorphic/unified_neuromorphic.rs:1054:13
     |
1054 |         for dim in 0..input_dim {
     |             ^^^ help: if this is intentional, prefix it with an underscore: `_dim`

warning: unused variable: `poisson`
    --> src/orchestration/neuromorphic/unified_neuromorphic.rs:1109:17
     |
1109 |             let poisson = Poisson::new((modulated_rate * 0.05).max(0.1)).unwrap();  // Scale for 50ms window
     |                 ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_poisson`

warning: unused variable: `weights`
  --> src/orchestration/neuromorphic/gpu_neuromorphic.rs:53:9
   |
53 |         weights: Option<&[f32]>,
   |         ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_weights`

warning: unused variable: `params`
  --> src/orchestration/neuromorphic/gpu_neuromorphic.rs:78:9
   |
78 |         params: &[(f32, f32, f32, f32)], // (a, b, c, d)
   |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_params`

warning: unused variable: `currents`
  --> src/orchestration/neuromorphic/gpu_neuromorphic.rs:96:61
   |
96 |     pub fn apply_input(&mut self, neuron_indices: &[usize], currents: &[f32]) -> Result<(), OrchestrationError> {
   |                                                             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_currents`

warning: unused variable: `batch_size`
   --> src/orchestration/local_llm/gpu_transformer.rs:254:13
    |
254 |         let batch_size = 1;  // For simplicity, batch_size = 1
    |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_batch_size`

warning: unused variable: `hidden_activated`
   --> src/orchestration/local_llm/gpu_transformer.rs:370:17
    |
370 |         let mut hidden_activated = hidden.clone();
    |                 ^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_hidden_activated`

warning: variable does not need to be mutable
   --> src/orchestration/local_llm/gpu_transformer.rs:370:13
    |
370 |         let mut hidden_activated = hidden.clone();
    |             ----^^^^^^^^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `tda`
   --> src/orchestration/local_llm/attention_analyzer.rs:315:58
    |
315 |         let topology_suggests_collapse = if let Some(ref tda) = self.tda_analyzer {
    |                                                          ^^^ help: if this is intentional, prefix it with an underscore: `_tda`

warning: unused variable: `y`
   --> src/orchestration/local_llm/transfer_entropy_llm.rs:340:35
    |
340 |     fn conditional_entropy(&self, y: usize, x_seq: &[usize]) -> Result<f32> {
    |                                   ^ help: if this is intentional, prefix it with an underscore: `_y`

warning: unused variable: `data`
  --> src/orchestration/local_llm/tda_topology_adapter.rs:23:32
   |
23 |     fn analyze_topology(&self, data: &[f64]) -> Result<TopologyAnalysis> {
   |                                ^^^^ help: if this is intentional, prefix it with an underscore: `_data`

warning: unused variable: `edges`
   --> src/orchestration/decomposition/pid_synergy.rs:846:46
    |
846 |     fn compute_mobius(nodes: &[LatticeNode], edges: &HashMap<usize, Vec<usize>>) -> HashMap<(usize, usize), f64> {
    |                                              ^^^^^ help: if this is intentional, prefix it with an underscore: `_edges`

warning: unused variable: `n_levels`
   --> src/orchestration/inference/hierarchical_active_inference.rs:200:13
    |
200 |         let n_levels = level_dims.len();
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_n_levels`

warning: unused variable: `iteration`
   --> src/orchestration/inference/hierarchical_active_inference.rs:286:13
    |
286 |         for iteration in 0..10 {  // Fixed iterations for now
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_iteration`

warning: value assigned to `total_F` is never read
   --> src/orchestration/inference/hierarchical_active_inference.rs:520:17
    |
520 |         let mut total_F = 0.0;
    |                 ^^^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: unused variable: `i`
   --> src/orchestration/inference/hierarchical_active_inference.rs:568:14
    |
568 |         for (i, policy) in self.action_selection.policies.iter().enumerate() {
    |              ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `state`
   --> src/orchestration/inference/hierarchical_active_inference.rs:664:49
    |
664 |     fn compute_expected_information_gain(&self, state: &DVector<f64>) -> Result<f64, OrchestrationError> {
    |                                                 ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `query`
   --> src/orchestration/inference/hierarchical_active_inference.rs:817:30
    |
817 | ...                   query: &str,
    |                       ^^^^^ help: if this is intentional, prefix it with an underscore: `_query`

warning: unused variable: `i`
   --> src/orchestration/inference/hierarchical_active_inference.rs:862:14
    |
862 |         for (i, response) in responses.iter().enumerate() {
    |              ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `delay`
   --> src/orchestration/inference/joint_active_inference.rs:604:21
    |
604 |                 let delay = match self.communication.bandwidth.delay_dist {
    |                     ^^^^^ help: if this is intentional, prefix it with an underscore: `_delay`

warning: unused variable: `i`
   --> src/orchestration/inference/joint_active_inference.rs:765:17
    |
765 |             for i in 0..n {
    |                 ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: variable does not need to be mutable
   --> src/orchestration/inference/joint_active_inference.rs:767:21
    |
767 |                 let mut received = proposals.clone();
    |                     ----^^^^^^^^
    |                     |
    |                     help: remove this `mut`

warning: unused variable: `agent`
   --> src/orchestration/inference/joint_active_inference.rs:982:14
    |
982 |         for (agent, agent_policy) in self.agents.iter().zip(&policy.agent_policies) {
    |              ^^^^^ help: if this is intentional, prefix it with an underscore: `_agent`

warning: unused variable: `constraint`
    --> src/orchestration/inference/joint_active_inference.rs:1030:32
     |
1030 |     fn check_constraint(&self, constraint: &CoordinationConstraint, policies: &[AgentPolicy]) -> bool {
     |                                ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_constraint`

warning: unused variable: `policies`
    --> src/orchestration/inference/joint_active_inference.rs:1030:69
     |
1030 |     fn check_constraint(&self, constraint: &CoordinationConstraint, policies: &[AgentPolicy]) -> bool {
     |                                                                     ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_policies`

warning: unused variable: `agent`
    --> src/orchestration/inference/joint_active_inference.rs:1217:13
     |
1217 |         for agent in &self.agents {
     |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_agent`

warning: variable does not need to be mutable
   --> src/orchestration/causality/bidirectional_causality.rs:321:13
    |
321 |         let mut ccm_result = self.convergent_cross_mapping(x_data, y_data)?;
    |             ----^^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `x_curr`
   --> src/orchestration/causality/bidirectional_causality.rs:738:31
    |
738 |         for ((y_next, y_curr, x_curr), p_joint) in &joint_prob {
    |                               ^^^^^^ help: if this is intentional, prefix it with an underscore: `_x_curr`

warning: unused variable: `query`
    --> src/orchestration/causality/bidirectional_causality.rs:1525:67
     |
1525 |     pub fn analyze_llm_causality(&mut self, responses: &[String], query: &str) -> Result<LLMCausalityAnalysis, OrchestrationError> {
     |                                                                   ^^^^^ help: if this is intentional, prefix it with an underscore: `_query`

warning: unused variable: `basis`
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:970:46
    |
970 |     fn compute_classical_correlations(&self, basis: &DMatrix<Complex64>) -> Result<f64, OrchestrationError> {
    |                                              ^^^^^ help: if this is intentional, prefix it with an underscore: `_basis`

warning: unused variable: `op`
   --> src/quantum_mlir/dialect.rs:117:42
    |
117 |             verification: Some(Box::new(|op| {
    |                                          ^^ help: if this is intentional, prefix it with an underscore: `_op`

warning: unused variable: `op`
   --> src/quantum_mlir/dialect.rs:166:42
    |
166 |             verification: Some(Box::new(|op| {
    |                                          ^^ help: if this is intentional, prefix it with an underscore: `_op`

warning: unused variable: `block_size`
  --> src/gpu/gpu_tensor_optimized.rs:69:13
   |
69 |         let block_size = 16;
   |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_block_size`

warning: unused variable: `lda`
  --> src/gpu/production_runtime.rs:59:17
   |
59 |         a: u64, lda: usize,
   |                 ^^^ help: if this is intentional, prefix it with an underscore: `_lda`

warning: unused variable: `ldb`
  --> src/gpu/production_runtime.rs:60:17
   |
60 |         b: u64, ldb: usize,
   |                 ^^^ help: if this is intentional, prefix it with an underscore: `_ldb`

warning: unused variable: `ldc`
  --> src/gpu/production_runtime.rs:62:17
   |
62 |         c: u64, ldc: usize,
   |                 ^^^ help: if this is intentional, prefix it with an underscore: `_ldc`

warning: unnecessary `unsafe` block
  --> src/gpu/cudarc_replacement.rs:45:9
   |
45 |         unsafe {
   |         ^^^^^^ unnecessary `unsafe` block

warning: unnecessary `unsafe` block
  --> src/gpu/cudarc_replacement.rs:63:9
   |
63 |         unsafe {
   |         ^^^^^^ unnecessary `unsafe` block

warning: unnecessary `unsafe` block
  --> src/gpu/cudarc_replacement.rs:78:9
   |
78 |         unsafe {
   |         ^^^^^^ unnecessary `unsafe` block

warning: unused variable: `transa`
   --> src/gpu/cudarc_replacement.rs:162:13
    |
162 |             transa: bool,
    |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_transa`

warning: unused variable: `transb`
   --> src/gpu/cudarc_replacement.rs:163:13
    |
163 |             transb: bool,
    |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_transb`

warning: unused variable: `incx`
   --> src/gpu/cudarc_replacement.rs:194:13
    |
194 |             incx: i32,
    |             ^^^^ help: if this is intentional, prefix it with an underscore: `_incx`

warning: unused variable: `incy`
   --> src/gpu/cudarc_replacement.rs:196:13
    |
196 |             incy: i32,
    |             ^^^^ help: if this is intentional, prefix it with an underscore: `_incy`

warning: unused variable: `regulated`
   --> src/phase6/predictive_neuro.rs:510:13
    |
510 |         let regulated = matrix + reg * Array2::eye(n);
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_regulated`

warning: unused variable: `block_size`
   --> src/phase6/gpu_tda.rs:179:13
    |
179 |         let block_size = 16;
    |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_block_size`

warning: unused variable: `delay`
   --> src/cma/causal_discovery.rs:131:13
    |
131 |         let delay = 1;
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_delay`

warning: unused variable: `beta`
   --> src/cma/quantum/path_integral.rs:143:9
    |
143 |         beta: f64,
    |         ^^^^ help: if this is intentional, prefix it with an underscore: `_beta`

warning: unused variable: `hamiltonian`
   --> src/cma/quantum/pimc_gpu.rs:168:37
    |
168 |     fn hamiltonian_to_matrix(&self, hamiltonian: &ProblemHamiltonian, n_dim: usize) -> Vec<f32> {
    |                                     ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_hamiltonian`

warning: unused variable: `hamiltonian`
   --> src/cma/neural/neural_quantum.rs:511:9
    |
511 |         hamiltonian: &ProblemHamiltonian,
    |         ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_hamiltonian`

warning: unused variable: `hamiltonian`
   --> src/cma/neural/neural_quantum.rs:526:9
    |
526 |         hamiltonian: &ProblemHamiltonian,
    |         ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_hamiltonian`

warning: unused variable: `batch_size`
   --> src/cma/neural/gnn_training.rs:296:9
    |
296 |         batch_size: usize,
    |         ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_batch_size`

warning: unused variable: `learning_rate`
   --> src/cma/neural/gnn_training.rs:777:9
    |
777 |         learning_rate: f64,
    |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_learning_rate`

warning: unused variable: `source_model`
   --> src/cma/neural/gnn_transfer_learning.rs:434:9
    |
434 |         source_model: &E3EquivariantGNN,
    |         ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_source_model`

warning: unused variable: `trained_model`
   --> src/cma/neural/gnn_transfer_learning.rs:518:13
    |
518 |         let trained_model = trainer.get_model();
    |             ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_trained_model`

warning: unused variable: `ensembles`
   --> src/cma/neural/gnn_transfer_learning.rs:702:9
    |
702 |         ensembles: &[Ensemble],
    |         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ensembles`

warning: unused variable: `manifolds`
   --> src/cma/neural/gnn_transfer_learning.rs:703:9
    |
703 |         manifolds: &[CausalManifold],
    |         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_manifolds`

warning: unused variable: `model`
   --> src/cma/neural/gnn_training_pipeline.rs:478:9
    |
478 |         model: &E3EquivariantGNN,
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_model`

warning: unused variable: `i`
   --> src/cma/neural/gnn_training_pipeline.rs:674:14
    |
674 |         for (i, metric) in metrics.iter().enumerate() {
    |              ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `rng`
  --> src/cma/gpu_integration.rs:76:13
   |
76 |         let rng = ChaCha20Rng::seed_from_u64(seed);
   |             ^^^ help: if this is intentional, prefix it with an underscore: `_rng`

warning: unnecessary `unsafe` block
   --> src/cma/gpu_integration.rs:158:13
    |
158 |             unsafe {
    |             ^^^^^^ unnecessary `unsafe` block

warning: unused variable: `n`
  --> src/cma/transfer_entropy_gpu.rs:63:13
   |
63 |         let n = source.len();
   |             ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: unused variable: `psi`
   --> src/cma/pac_bayes.rs:208:13
    |
208 |         let psi = |x: f64| -> f64 {
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_psi`

warning: unused variable: `train_data`
   --> src/cma/conformal_prediction.rs:210:14
    |
210 |         let (train_data, calib_data) = proper_training_data.split_at(split_point);
    |              ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_train_data`

warning: unused variable: `candidates`
   --> src/cma/conformal_prediction.rs:389:58
    |
389 |     fn compute_efficiency(&self, prediction_set: &[f64], candidates: &[f64]) -> f64 {
    |                                                          ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_candidates`

warning: unused variable: `x`
   --> src/cma/conformal_prediction.rs:474:35
    |
474 |     fn predict_uncertainty(&self, x: &Array1<f64>) -> Result<f64> {
    |                                   ^ help: if this is intentional, prefix it with an underscore: `_x`

warning: unused variable: `history`
   --> src/applications/robotics/trajectory_forecasting.rs:253:17
    |
253 |             let history = vec![TrajectoryPoint {
    |                 ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_history`

warning: unused variable: `historical_interactions`
   --> src/applications/robotics/trajectory_forecasting.rs:240:9
    |
240 |         historical_interactions: &[InteractionHistory],
    |         ^^^^^^^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_historical_interactions`

warning: unused variable: `protein_smiles`
  --> src/chemistry/gpu_docking.rs:35:9
   |
35 |         protein_smiles: &str,
   |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_protein_smiles`

warning: unused variable: `x_arr`
   --> src/time_series/lstm_forecaster.rs:362:13
    |
362 |         let x_arr = Array1::from(input_vec);
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_x_arr`

warning: unused variable: `variance`
   --> src/finance/portfolio_optimizer.rs:288:17
    |
288 |             let variance = self.compute_portfolio_variance(&weights, covariance);
    |                 ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_variance`

warning: value assigned to `temperature` is never read
   --> src/finance/thermodynamic_consensus.rs:190:17
    |
190 |         let mut temperature = self.config.temperature;
    |                 ^^^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: unused variable: `key`
   --> src/api_server/advanced_info_theory.rs:140:13
    |
140 |         let key = (hash_sequence(&x_history), hash_sequence(&y_prev_history), y_current);
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_key`

warning: unused variable: `y_recent`
   --> src/api_server/advanced_info_theory.rs:350:9
    |
350 |     let y_recent = if y_history.is_empty() {
    |         ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_y_recent`

warning: unused variable: `sharpe`
  --> src/api_server/portfolio.rs:86:17
   |
86 |             let sharpe = (portfolio_return - self.risk_free_rate) / portfolio_risk;
   |                 ^^^^^^ help: if this is intentional, prefix it with an underscore: `_sharpe`

warning: unused variable: `params`
   --> src/assistant/autonomous_agent.rs:220:55
    |
220 |     pub fn call_robotics_tool(&self, operation: &str, params: serde_json::Value) -> Result<ToolResult> {
    |                                                       ^^^^^^ help: if this is intentional, prefix it with an underscore: `_params`

warning: unused variable: `params`
   --> src/assistant/autonomous_agent.rs:243:58
    |
243 |     pub fn call_time_series_tool(&self, operation: &str, params: serde_json::Value) -> Result<ToolResult> {
    |                                                          ^^^^^^ help: if this is intentional, prefix it with an underscore: `_params`

warning: unused variable: `batch_size`
   --> src/assistant/local_llm/gpu_transformer.rs:254:13
    |
254 |         let batch_size = 1;  // For simplicity, batch_size = 1
    |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_batch_size`

warning: unused variable: `hidden_activated`
   --> src/assistant/local_llm/gpu_transformer.rs:370:17
    |
370 |         let mut hidden_activated = hidden.clone();
    |                 ^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_hidden_activated`

warning: variable does not need to be mutable
   --> src/assistant/local_llm/gpu_transformer.rs:370:13
    |
370 |         let mut hidden_activated = hidden.clone();
    |             ----^^^^^^^^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: type `LLMStatistics` is more private than the item `BanditLLMEnsemble::get_statistics`
   --> src/orchestration/llm_clients/ensemble.rs:207:5
    |
207 |     pub fn get_statistics(&self) -> Vec<LLMStatistics> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method `BanditLLMEnsemble::get_statistics` is reachable at visibility `pub`
    |
note: but type `LLMStatistics` is only usable at visibility `pub(self)`
   --> src/orchestration/llm_clients/ensemble.rs:45:1
    |
 45 | struct LLMStatistics {
    | ^^^^^^^^^^^^^^^^^^^^
    = note: `#[warn(private_interfaces)]` on by default

warning: type `mission_charlie_integration::IntegrationMetrics` is more private than the item `DiagnosticReport::performance_metrics`
   --> src/orchestration/integration/mission_charlie_integration.rs:578:5
    |
578 |     pub performance_metrics: IntegrationMetrics,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ field `DiagnosticReport::performance_metrics` is reachable at visibility `pub`
    |
note: but type `mission_charlie_integration::IntegrationMetrics` is only usable at visibility `pub(self)`
   --> src/orchestration/integration/mission_charlie_integration.rs:73:1
    |
 73 | struct IntegrationMetrics {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: type `Geodesic` is more private than the item `GeometricManifoldOptimizer::compute_geodesic`
    --> src/orchestration/optimization/geometric_manifold.rs:1148:5
     |
1148 |     pub fn compute_geodesic(&mut self, start: &DVector<f64>, end: &DVector<f64>) -> Result<Geodesic, OrchestrationError> {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method `GeometricManifoldOptimizer::compute_geodesic` is reachable at visibility `pub`
     |
note: but type `Geodesic` is only usable at visibility `pub(self)`
    --> src/orchestration/optimization/geometric_manifold.rs:286:1
     |
 286 | struct Geodesic {
     | ^^^^^^^^^^^^^^^

warning: type `Geodesic` is more private than the item `GeometricManifoldOptimizer::parallel_transport`
    --> src/orchestration/optimization/geometric_manifold.rs:1327:5
     |
1327 |     pub fn parallel_transport(&mut self, vector: &DVector<f64>, geodesic: &Geodesic) -> Result<DVector<f64>, OrchestrationError> {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method `GeometricManifoldOptimizer::parallel_transport` is reachable at visibility `pub`
     |
note: but type `Geodesic` is only usable at visibility `pub(self)`
    --> src/orchestration/optimization/geometric_manifold.rs:286:1
     |
 286 | struct Geodesic {
     | ^^^^^^^^^^^^^^^

warning: type `GpuEmbeddings` is more private than the item `GpuKSGEstimator::create_embeddings`
   --> src/cma/transfer_entropy_gpu.rs:223:5
    |
223 |     pub fn create_embeddings(&self, source: &TimeSeries, target: &TimeSeries) -> Result<GpuEmbeddings> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method `GpuKSGEstimator::create_embeddings` is reachable at visibility `pub`
    |
note: but type `GpuEmbeddings` is only usable at visibility `pub(self)`
   --> src/cma/transfer_entropy_gpu.rs:303:1
    |
303 | struct GpuEmbeddings {
    | ^^^^^^^^^^^^^^^^^^^^

warning: field `n_conditioning` is never read
  --> src/information_theory/conditional_te.rs:54:5
   |
46 | pub struct ConditionalTE {
   |            ------------- field in this struct
...
54 |     n_conditioning: usize,
   |     ^^^^^^^^^^^^^^
   |
   = note: `ConditionalTE` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` on by default

warning: field `dimensions` is never read
  --> src/information_theory/memory_efficient.rs:32:5
   |
26 | pub struct SparseHistogram {
   |            --------------- field in this struct
...
32 |     dimensions: usize,
   |     ^^^^^^^^^^
   |
   = note: `SparseHistogram` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `dimensions` is never read
   --> src/information_theory/memory_efficient.rs:264:5
    |
258 | pub struct CompressedHistogram {
    |            ------------------- field in this struct
...
264 |     dimensions: usize,
    |     ^^^^^^^^^^

warning: field `config` is never read
  --> src/information_theory/gpu_transfer_entropy.rs:17:5
   |
16 | pub struct GpuTransferEntropy {
   |            ------------------ field in this struct
17 |     config: TransferEntropy,
   |     ^^^^^^

warning: field `n_sources` is never read
   --> src/information_theory/multivariate_te.rs:422:5
    |
414 | struct MultivariateEmbeddings {
    |        ---------------------- field in this struct
...
422 |     n_sources: usize,
    |     ^^^^^^^^^
    |
    = note: `MultivariateEmbeddings` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `init_kernel` is never read
  --> src/statistical_mechanics/gpu.rs:27:5
   |
23 | pub struct ThermodynamicGpu {
   |            ---------------- field in this struct
...
27 |     init_kernel: Arc<CudaFunction>,
   |     ^^^^^^^^^^^

warning: fields `precision_weight_kernel`, `axpby_kernel`, `velocity_update_kernel`, and `hierarchical_project_kernel` are never read
  --> src/active_inference/gpu.rs:31:5
   |
24 | pub struct ActiveInferenceGpu {
   |            ------------------ fields in this struct
...
31 |     precision_weight_kernel: Arc<CudaFunction>,
   |     ^^^^^^^^^^^^^^^^^^^^^^^
...
35 |     axpby_kernel: Arc<CudaFunction>,
   |     ^^^^^^^^^^^^
36 |     velocity_update_kernel: Arc<CudaFunction>,
   |     ^^^^^^^^^^^^^^^^^^^^^^
37 |     hierarchical_project_kernel: Arc<CudaFunction>,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: field `rng_init_kernel` is never read
   --> src/active_inference/gpu_policy_eval.rs:105:5
    |
 96 | pub struct GpuPolicyEvaluator {
    |            ------------------ field in this struct
...
105 |     rng_init_kernel: Arc<CudaFunction>,
    |     ^^^^^^^^^^^^^^^
    |
    = note: `GpuPolicyEvaluator` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: field `config` is never read
   --> src/active_inference/hierarchical_inference_gpu.rs:111:5
    |
107 | pub struct HierarchicalActiveInferenceGpu {
    |            ------------------------------ field in this struct
...
111 |     config: HierarchicalConfig,
    |     ^^^^^^

warning: field `cuda_context` is never read
   --> src/integration/unified_platform.rs:162:5
    |
160 | pub struct UnifiedPlatform {
    |            --------------- field in this struct
161 |     /// Shared CUDA context (GPU resources)
162 |     cuda_context: Arc<CudaContext>,
    |     ^^^^^^^^^^^^

warning: field `num_qubits` is never read
  --> src/integration/quantum_mlir_integration.rs:24:5
   |
18 | pub struct QuantumMlirIntegration {
   |            ---------------------- field in this struct
...
24 |     num_qubits: usize,
   |     ^^^^^^^^^^

warning: method `calculate_coherence` is never used
   --> src/integration/quantum_mlir_integration.rs:204:8
    |
 37 | impl QuantumMlirIntegration {
    | --------------------------- method in this implementation
...
204 |     fn calculate_coherence(&self, state: &QuantumState) -> f64 {
    |        ^^^^^^^^^^^^^^^^^^^

warning: fields `constraint_weights_gpu`, `gnn_weights_gpu`, and `hamiltonian_gpu` are never read
  --> src/integration/multi_modal_reasoner.rs:49:5
   |
44 | pub struct MultiModalReasoner {
   |            ------------------ fields in this struct
...
49 |     constraint_weights_gpu: Option<CudaSlice<f32>>,
   |     ^^^^^^^^^^^^^^^^^^^^^^
...
52 |     gnn_weights_gpu: Option<Vec<CudaSlice<f32>>>,
   |     ^^^^^^^^^^^^^^^
...
55 |     hamiltonian_gpu: Option<CudaSlice<f32>>,
   |     ^^^^^^^^^^^^^^^

warning: field `id` is never read
  --> src/optimization/memory_optimizer.rs:48:5
   |
42 | pub struct PinnedBuffer {
   |            ------------ field in this struct
...
48 |     id: usize,
   |     ^^

warning: fields `buffer_size` and `num_buffers` are never read
  --> src/optimization/memory_optimizer.rs:92:5
   |
86 | pub struct PinnedMemoryPool {
   |            ---------------- fields in this struct
...
92 |     buffer_size: usize,
   |     ^^^^^^^^^^^
93 |     /// Total number of buffers
94 |     num_buffers: usize,
   |     ^^^^^^^^^^^

warning: field `id` is never read
  --> src/orchestration/llm_clients/openai_client.rs:62:5
   |
61 | struct OpenAIResponse {
   |        -------------- field in this struct
62 |     id: String,
   |     ^^
   |
   = note: `OpenAIResponse` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `id` is never read
  --> src/orchestration/llm_clients/claude_client.rs:43:5
   |
42 | struct ClaudeResponse {
   |        -------------- field in this struct
43 |     id: String,
   |     ^^
   |
   = note: `ClaudeResponse` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: field `timestamp` is never read
  --> src/orchestration/llm_clients/claude_client.rs:64:5
   |
62 | struct CachedResponse {
   |        -------------- field in this struct
63 |     response: LLMResponse,
64 |     timestamp: SystemTime,
   |     ^^^^^^^^^
   |
   = note: `CachedResponse` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: field `timestamp` is never read
  --> src/orchestration/llm_clients/gemini_client.rs:84:5
   |
82 | struct CachedResponse {
   |        -------------- field in this struct
83 |     response: LLMResponse,
84 |     timestamp: SystemTime,
   |     ^^^^^^^^^
   |
   = note: `CachedResponse` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: field `timestamp` is never read
  --> src/orchestration/llm_clients/grok_client.rs:61:5
   |
59 | struct CachedResponse {
   |        -------------- field in this struct
60 |     response: LLMResponse,
61 |     timestamp: SystemTime,
   |     ^^^^^^^^^
   |
   = note: `CachedResponse` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: field `model_name` is never read
  --> src/orchestration/llm_clients/ensemble.rs:46:5
   |
45 | struct LLMStatistics {
   |        ------------- field in this struct
46 |     model_name: String,
   |     ^^^^^^^^^^
   |
   = note: `LLMStatistics` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: field `model_priors` is never read
   --> src/orchestration/llm_clients/ensemble.rs:235:5
    |
228 | pub struct BayesianLLMEnsemble {
    |            ------------------- field in this struct
...
235 |     model_priors: Array1<f64>,
    |     ^^^^^^^^^^^^

warning: field `uncertainty_threshold` is never read
   --> src/orchestration/llm_clients/ensemble.rs:413:5
    |
405 | pub struct LLMOrchestrator {
    |            --------------- field in this struct
...
413 |     uncertainty_threshold: f64,
    |     ^^^^^^^^^^^^^^^^^^^^^

warning: field `cuda_context` is never read
  --> src/orchestration/thermodynamic/gpu_thermodynamic_consensus.rs:47:5
   |
45 | pub struct GpuThermodynamicConsensus {
   |            ------------------------- field in this struct
46 |     gpu_executor: Arc<std::sync::Mutex<GpuKernelExecutor>>,
47 |     cuda_context: Arc<CudaContext>,
   |     ^^^^^^^^^^^^

warning: field `timestamp` is never read
   --> src/orchestration/thermodynamic/advanced_energy.rs:154:5
    |
149 | struct EnergyRecord {
    |        ------------ field in this struct
...
154 |     timestamp: std::time::Instant,
    |     ^^^^^^^^^
    |
    = note: `EnergyRecord` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `token_predictor` is never read
  --> src/orchestration/active_inference/hierarchical_client.rs:34:5
   |
26 | pub struct HierarchicalActiveInferenceClient {
   |            --------------------------------- field in this struct
...
34 |     token_predictor: Option<TokenPredictor>,
   |     ^^^^^^^^^^^^^^^

warning: field `predicted_tokens` is never read
  --> src/orchestration/active_inference/hierarchical_client.rs:56:5
   |
55 | struct TokenPredictor {
   |        -------------- field in this struct
56 |     predicted_tokens: Vec<String>,
   |     ^^^^^^^^^^^^^^^^

warning: fields `mdl_optimizer` and `pwsa_bridge` are never read
  --> src/orchestration/integration/mission_charlie_integration.rs:39:5
   |
33 | pub struct MissionCharlieIntegration {
   |            ------------------------- fields in this struct
...
39 |     mdl_optimizer: MDLPromptOptimizer,
   |     ^^^^^^^^^^^^^
...
43 |     pwsa_bridge: PWSAIntegrationBridge,
   |     ^^^^^^^^^^^

warning: field `synergy` is never read
  --> src/orchestration/integration/mission_charlie_integration.rs:79:5
   |
73 | struct IntegrationMetrics {
   |        ------------------ field in this struct
...
79 |     synergy: HashMap<(String, String), f64>,
   |     ^^^^^^^
   |
   = note: `IntegrationMetrics` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `gpu_backend` is never read
   --> src/orchestration/integration/prism_ai_integration.rs:109:5
    |
 88 | pub struct PrismAIOrchestrator {
    |            ------------------- field in this struct
...
109 |     gpu_backend: Arc<RwLock<GpuBackend>>,
    |     ^^^^^^^^^^^

warning: field `feature_importance` is never read
  --> src/orchestration/optimization/mdl_prompt_optimizer.rs:18:5
   |
16 | pub struct MDLPromptOptimizer {
   |            ------------------ field in this struct
17 |     /// Feature importance (learned from historical queries)
18 |     feature_importance: HashMap<String, f64>,
   |     ^^^^^^^^^^^^^^^^^^

warning: field `curvature` is never read
  --> src/orchestration/optimization/geometric_manifold.rs:25:5
   |
13 | pub struct GeometricManifoldOptimizer {
   |            -------------------------- field in this struct
...
25 |     curvature: CurvatureAnalyzer,
   |     ^^^^^^^^^

warning: field `chart` is never read
  --> src/orchestration/optimization/geometric_manifold.rs:44:5
   |
32 | struct RiemannianManifold {
   |        ------------------ field in this struct
...
44 |     chart: LocalChart,
   |     ^^^^^
   |
   = note: `RiemannianManifold` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: fields `g_inv` and `det_g` are never read
  --> src/orchestration/optimization/geometric_manifold.rs:64:5
   |
60 | struct MetricTensor {
   |        ------------ fields in this struct
...
64 |     g_inv: Box<dyn Fn(&DVector<f64>) -> DMatrix<f64> + Send + Sync>,
   |     ^^^^^
65 |     /// Determinant of metric
66 |     det_g: Box<dyn Fn(&DVector<f64>) -> f64 + Send + Sync>,
   |     ^^^^^

warning: fields `grad_h` and `hess_h` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:103:5
    |
 99 | struct ManifoldConstraint {
    |        ------------------ fields in this struct
...
103 |     grad_h: fn(&DVector<f64>) -> DVector<f64>,
    |     ^^^^^^
104 |     /// Hessian of constraint
105 |     hess_h: fn(&DVector<f64>) -> DMatrix<f64>,
    |     ^^^^^^
    |
    = note: `ManifoldConstraint` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `domain`, `phi`, `phi_inv`, and `d_phi` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:112:5
    |
110 | struct LocalChart {
    |        ---------- fields in this struct
111 |     /// Chart domain
112 |     domain: Domain,
    |     ^^^^^^
113 |     /// Coordinate map
114 |     phi: fn(&DVector<f64>) -> DVector<f64>,
    |     ^^^
115 |     /// Inverse map
116 |     phi_inv: fn(&DVector<f64>) -> DVector<f64>,
    |     ^^^^^^^
117 |     /// Jacobian of coordinate map
118 |     d_phi: fn(&DVector<f64>) -> DMatrix<f64>,
    |     ^^^^^
    |
    = note: `LocalChart` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `lower` and `upper` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:124:5
    |
122 | struct Domain {
    |        ------ fields in this struct
123 |     /// Lower bounds
124 |     lower: DVector<f64>,
    |     ^^^^^
125 |     /// Upper bounds
126 |     upper: DVector<f64>,
    |     ^^^^^
    |
    = note: `Domain` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `line_search` and `trust_region` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:139:5
    |
131 | struct ManifoldOptimizer {
    |        ----------------- fields in this struct
...
139 |     line_search: LineSearchMethod,
    |     ^^^^^^^^^^^
140 |     /// Trust region parameters
141 |     trust_region: TrustRegionParams,
    |     ^^^^^^^^^^^^
    |
    = note: `ManifoldOptimizer` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: multiple variants are never constructed
   --> src/orchestration/optimization/geometric_manifold.rs:146:5
    |
145 | enum OptimizationAlgorithm {
    |      --------------------- variants in this enum
146 |     RiemannianGradientDescent,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
147 |     RiemannianConjugateGradient,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
148 |     RiemannianNewton,
    |     ^^^^^^^^^^^^^^^^
149 |     RiemannianQuasiNewton,
    |     ^^^^^^^^^^^^^^^^^^^^^
150 |     RiemannianTrustRegion,
    |     ^^^^^^^^^^^^^^^^^^^^^
151 |     NaturalGradientDescent,
    |     ^^^^^^^^^^^^^^^^^^^^^^
152 |     RiemannianAdam,
153 |     RiemannianLBFGS,
    |     ^^^^^^^^^^^^^^^
    |
    = note: `OptimizationAlgorithm` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Fixed`, `LineSearch`, and `Armijo` are never constructed
   --> src/orchestration/optimization/geometric_manifold.rs:158:5
    |
157 | enum StepSizeSchedule {
    |      ---------------- variants in this enum
158 |     Fixed(f64),
    |     ^^^^^
159 |     Adaptive(AdaptiveSchedule),
160 |     LineSearch,
    |     ^^^^^^^^^^
161 |     Armijo,
    |     ^^^^^^
    |
    = note: `StepSizeSchedule` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `min_step` is never read
   --> src/orchestration/optimization/geometric_manifold.rs:168:5
    |
165 | struct AdaptiveSchedule {
    |        ---------------- field in this struct
...
168 |     min_step: f64,
    |     ^^^^^^^^
    |
    = note: `AdaptiveSchedule` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `f_tol` and `x_tol` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:178:5
    |
172 | struct ConvergenceCriteria {
    |        ------------------- fields in this struct
...
178 |     f_tol: f64,
    |     ^^^^^
179 |     /// Step size tolerance
180 |     x_tol: f64,
    |     ^^^^^
    |
    = note: `ConvergenceCriteria` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Backtracking`, `WolfeConditions`, and `NonmonotoneLineSearch` are never constructed
   --> src/orchestration/optimization/geometric_manifold.rs:185:5
    |
184 | enum LineSearchMethod {
    |      ---------------- variants in this enum
185 |     Backtracking,
    |     ^^^^^^^^^^^^
186 |     WolfeConditions,
    |     ^^^^^^^^^^^^^^^
187 |     StrongWolfe,
188 |     NonmonotoneLineSearch,
    |     ^^^^^^^^^^^^^^^^^^^^^
    |
    = note: `LineSearchMethod` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `delta`, `delta_max`, `eta_1`, and `eta_2` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:194:5
    |
192 | struct TrustRegionParams {
    |        ----------------- fields in this struct
193 |     /// Initial trust region radius
194 |     delta: f64,
    |     ^^^^^
195 |     /// Maximum radius
196 |     delta_max: f64,
    |     ^^^^^^^^^
197 |     /// Radius update parameters
198 |     eta_1: f64,
    |     ^^^^^
199 |     eta_2: f64,
    |     ^^^^^
    |
    = note: `TrustRegionParams` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `lambda`, `diagonal`, and `kfac` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:208:5
    |
204 | struct NaturalGradient {
    |        --------------- fields in this struct
...
208 |     lambda: f64,
    |     ^^^^^^
209 |     /// Use diagonal approximation
210 |     diagonal: bool,
    |     ^^^^^^^^
211 |     /// Use KFAC approximation
212 |     kfac: bool,
    |     ^^^^
    |
    = note: `NaturalGradient` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `F_diag`, `A`, and `G` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:222:5
    |
218 | struct FisherInformation {
    |        ----------------- fields in this struct
...
222 |     F_diag: DVector<f64>,
    |     ^^^^^^
223 |     /// KFAC factors
224 |     A: Option<DMatrix<f64>>,
    |     ^
225 |     G: Option<DMatrix<f64>>,
    |     ^
    |
    = note: `FisherInformation` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `integration` is never read
   --> src/orchestration/optimization/geometric_manifold.rs:234:5
    |
232 | struct GeodesicSolver {
    |        -------------- field in this struct
233 |     /// Integration method
234 |     integration: IntegrationMethod,
    |     ^^^^^^^^^^^
    |
    = note: `GeodesicSolver` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `DormandPrince`, `SymplecticEuler`, and `Verlet` are never constructed
   --> src/orchestration/optimization/geometric_manifold.rs:246:5
    |
244 | enum IntegrationMethod {
    |      ----------------- variants in this enum
245 |     RungeKutta4,
246 |     DormandPrince,
    |     ^^^^^^^^^^^^^
247 |     SymplecticEuler,
    |     ^^^^^^^^^^^^^^^
248 |     Verlet,
    |     ^^^^^^
    |
    = note: `IntegrationMethod` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `max_iter` is never read
   --> src/orchestration/optimization/geometric_manifold.rs:258:5
    |
252 | struct BVPSolver {
    |        --------- field in this struct
...
258 |     max_iter: usize,
    |     ^^^^^^^^
    |
    = note: `BVPSolver` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `FiniteDifference` and `Collocation` are never constructed
   --> src/orchestration/optimization/geometric_manifold.rs:264:5
    |
262 | enum BVPMethod {
    |      --------- variants in this enum
263 |     Shooting,
264 |     FiniteDifference,
    |     ^^^^^^^^^^^^^^^^
265 |     Collocation,
    |     ^^^^^^^^^^^
    |
    = note: `BVPMethod` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `velocity_search` and `newton_tol` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:271:5
    |
269 | struct ShootingMethod {
    |        -------------- fields in this struct
270 |     /// Initial velocity search
271 |     velocity_search: VelocitySearch,
    |     ^^^^^^^^^^^^^^^
272 |     /// Newton iterations
273 |     newton_tol: f64,
    |     ^^^^^^^^^^
    |
    = note: `ShootingMethod` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `GradientDescent` and `ParticleSwarm` are never constructed
   --> src/orchestration/optimization/geometric_manifold.rs:281:5
    |
279 | enum VelocitySearch {
    |      -------------- variants in this enum
280 |     Newton,
281 |     GradientDescent,
    |     ^^^^^^^^^^^^^^^
282 |     ParticleSwarm,
    |     ^^^^^^^^^^^^^
    |
    = note: `VelocitySearch` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `start` is never read
   --> src/orchestration/optimization/geometric_manifold.rs:288:5
    |
286 | struct Geodesic {
    |        -------- field in this struct
287 |     /// Starting point
288 |     start: DVector<f64>,
    |     ^^^^^
    |
    = note: `Geodesic` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `pole_params` and `cache` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:307:5
    |
301 | struct ParallelTransport {
    |        ----------------- fields in this struct
...
307 |     pole_params: PoleLadder,
    |     ^^^^^^^^^^^
308 |     /// Transport cache
309 |     cache: HashMap<u64, DMatrix<f64>>,
    |     ^^^^^
    |
    = note: `ParallelTransport` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `PoleLadder`, `FermiWalker`, and `LieTransport` are never constructed
   --> src/orchestration/optimization/geometric_manifold.rs:315:5
    |
313 | enum TransportMethod {
    |      --------------- variants in this enum
314 |     SchildLadder,
315 |     PoleLadder,
    |     ^^^^^^^^^^
316 |     FermiWalker,
    |     ^^^^^^^^^^^
317 |     LieTransport,
    |     ^^^^^^^^^^^^
    |
    = note: `TransportMethod` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `order` is never read
   --> src/orchestration/optimization/geometric_manifold.rs:325:5
    |
321 | struct SchildLadder {
    |        ------------ field in this struct
...
325 |     order: usize,
    |     ^^^^^
    |
    = note: `SchildLadder` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `pole` and `retraction` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:331:5
    |
329 | struct PoleLadder {
    |        ---------- fields in this struct
330 |     /// Pole point
331 |     pole: Option<DVector<f64>>,
    |     ^^^^
332 |     /// Retraction type
333 |     retraction: RetractionType,
    |     ^^^^^^^^^^
    |
    = note: `PoleLadder` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Cayley` and `Projection` are never constructed
   --> src/orchestration/optimization/geometric_manifold.rs:339:5
    |
337 | enum RetractionType {
    |      -------------- variants in this enum
338 |     Exponential,
339 |     Cayley,
    |     ^^^^^^
340 |     Projection,
    |     ^^^^^^^^^^
    |
    = note: `RetractionType` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `riemann`, `ricci`, `scalar`, and `sectional` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:347:5
    |
345 | struct CurvatureAnalyzer {
    |        ----------------- fields in this struct
346 |     /// Riemann curvature tensor
347 |     riemann: RiemannTensor,
    |     ^^^^^^^
348 |     /// Ricci curvature
349 |     ricci: RicciCurvature,
    |     ^^^^^
350 |     /// Scalar curvature
351 |     scalar: ScalarCurvature,
    |     ^^^^^^
352 |     /// Sectional curvatures
353 |     sectional: SectionalCurvatures,
    |     ^^^^^^^^^
    |
    = note: `CurvatureAnalyzer` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `components` and `symmetries` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:359:5
    |
357 | struct RiemannTensor {
    |        ------------- fields in this struct
358 |     /// R^l_ijk components
359 |     components: HashMap<(usize, usize, usize, usize), f64>,
    |     ^^^^^^^^^^
360 |     /// Symmetries
361 |     symmetries: TensorSymmetries,
    |     ^^^^^^^^^^
    |
    = note: `RiemannTensor` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `antisym_12`, `antisym_34`, `interchange`, and `bianchi` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:366:5
    |
365 | struct TensorSymmetries {
    |        ---------------- fields in this struct
366 |     antisym_12: bool,
    |     ^^^^^^^^^^
367 |     antisym_34: bool,
    |     ^^^^^^^^^^
368 |     interchange: bool,
    |     ^^^^^^^^^^^
369 |     bianchi: bool,
    |     ^^^^^^^
    |
    = note: `TensorSymmetries` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `tensor` and `eigenvalues` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:375:5
    |
373 | struct RicciCurvature {
    |        -------------- fields in this struct
374 |     /// Ricci tensor R_ij
375 |     tensor: DMatrix<f64>,
    |     ^^^^^^
376 |     /// Eigenvalues
377 |     eigenvalues: DVector<f64>,
    |     ^^^^^^^^^^^
    |
    = note: `RicciCurvature` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `value` and `gradient` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:383:5
    |
381 | struct ScalarCurvature {
    |        --------------- fields in this struct
382 |     /// Scalar curvature value
383 |     value: f64,
    |     ^^^^^
384 |     /// Gradient of scalar curvature
385 |     gradient: DVector<f64>,
    |     ^^^^^^^^
    |
    = note: `ScalarCurvature` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `curvatures` and `principal` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:391:5
    |
389 | struct SectionalCurvatures {
    |        ------------------- fields in this struct
390 |     /// Sectional curvatures for 2-planes
391 |     curvatures: HashMap<(usize, usize), f64>,
    |     ^^^^^^^^^^
392 |     /// Principal curvatures
393 |     principal: Vec<f64>,
    |     ^^^^^^^^^
    |
    = note: `SectionalCurvatures` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `f_decrease`, `step_norm`, and `constraint_violation` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:416:5
    |
412 | struct ConvergenceMetrics {
    |        ------------------ fields in this struct
...
416 |     f_decrease: f64,
    |     ^^^^^^^^^^
417 |     /// Step norm
418 |     step_norm: f64,
    |     ^^^^^^^^^
419 |     /// Constraint violation
420 |     constraint_violation: f64,
    |     ^^^^^^^^^^^^^^^^^^^^
    |
    = note: `ConvergenceMetrics` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `timestamp` is never read
  --> src/orchestration/caching/quantum_semantic_cache.rs:43:5
   |
39 | struct CachedEntry {
   |        ----------- field in this struct
...
43 |     timestamp: SystemTime,
   |     ^^^^^^^^^
   |
   = note: `CachedEntry` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: field `model_name` is never read
  --> src/orchestration/routing/thermodynamic_balancer.rs:30:5
   |
29 | struct LLMPerformanceProfile {
   |        --------------------- field in this struct
30 |     model_name: String,
   |     ^^^^^^^^^^
   |
   = note: `LLMPerformanceProfile` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: method `extract_core_concept` is never used
   --> src/orchestration/routing/thermodynamic_balancer.rs:296:8
    |
164 | impl QuantumVotingConsensus {
    | --------------------------- method in this implementation
...
296 |     fn extract_core_concept(&self, response: &str) -> String {
    |        ^^^^^^^^^^^^^^^^^^^^

warning: field `timestamp` is never read
  --> src/orchestration/routing/transfer_entropy_router.rs:62:5
   |
56 | struct RoutingHistory {
   |        -------------- field in this struct
...
62 |     timestamp: u64,
   |     ^^^^^^^^^

warning: field `enable_domain` is never read
  --> src/orchestration/routing/transfer_entropy_router.rs:86:5
   |
84 | struct FeatureConfig {
   |        ------------- field in this struct
85 |     /// Enable domain detection
86 |     enable_domain: bool,
   |     ^^^^^^^^^^^^^
   |
   = note: `FeatureConfig` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `cuda_context` is never read
  --> src/orchestration/routing/gpu_transfer_entropy_router.rs:93:5
   |
91 | pub struct GpuTransferEntropyRouter {
   |            ------------------------ field in this struct
92 |     gpu_executor: Arc<std::sync::Mutex<GpuKernelExecutor>>,
93 |     cuda_context: Arc<CudaContext>,
   |     ^^^^^^^^^^^^

warning: fields `time` and `amplitude` are never read
   --> src/orchestration/neuromorphic/spike_consensus.rs:108:5
    |
107 | struct Spike {
    |        ----- fields in this struct
108 |     time: f64,
    |     ^^^^
109 |     amplitude: f64,
    |     ^^^^^^^^^

warning: field `neuron_type` is never read
  --> src/orchestration/neuromorphic/unified_neuromorphic.rs:61:5
   |
50 | struct IzhikevichNeuron {
   |        ---------------- field in this struct
...
61 |     neuron_type: NeuronType,
   |     ^^^^^^^^^^^
   |
   = note: `IzhikevichNeuron` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `LowThreshold` and `Resonator` are never constructed
  --> src/orchestration/neuromorphic/unified_neuromorphic.rs:75:5
   |
71 | enum NeuronType {
   |      ---------- variants in this enum
...
75 |     LowThreshold,        // LTS interneurons
   |     ^^^^^^^^^^^^
76 |     Resonator,           // Resonator neurons
   |     ^^^^^^^^^
   |
   = note: `NeuronType` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `delay` is never read
  --> src/orchestration/neuromorphic/unified_neuromorphic.rs:90:5
   |
82 | struct Synapse {
   |        ------- field in this struct
...
90 |     delay: f64,
   |     ^^^^^
   |
   = note: `Synapse` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Static`, `ShortTerm`, `Homeostatic`, and `Neuromodulated` are never constructed
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:103:5
    |
102 | enum PlasticityType {
    |      -------------- variants in this enum
103 |     Static,
    |     ^^^^^^
104 |     STDP,
105 |     ShortTerm,
    |     ^^^^^^^^^
106 |     Homeostatic,
    |     ^^^^^^^^^^^
107 |     Neuromodulated,
    |     ^^^^^^^^^^^^^^
    |
    = note: `PlasticityType` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `tau_F` and `tau_D` are never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:118:5
    |
112 | struct STPState {
    |        -------- fields in this struct
...
118 |     tau_F: f64,
    |     ^^^^^
119 |     tau_D: f64,
    |     ^^^^^
    |
    = note: `STPState` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `layer_type` is never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:128:5
    |
124 | struct Layer {
    |        ----- field in this struct
...
128 |     layer_type: LayerType,
    |     ^^^^^^^^^^
    |
    = note: `Layer` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variant `Reservoir` is never constructed
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:138:5
    |
134 | enum LayerType {
    |      --------- variant in this enum
...
138 |     Reservoir,  // For liquid state machine
    |     ^^^^^^^^^
    |
    = note: `LayerType` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `tau_plus` and `tau_minus` are never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:145:5
    |
143 | struct STDPEngine {
    |        ---------- fields in this struct
144 |     /// STDP window parameters
145 |     tau_plus: f64,   // LTP time constant (ms)
    |     ^^^^^^^^
146 |     tau_minus: f64,  // LTD time constant (ms)
    |     ^^^^^^^^^
    |
    = note: `STDPEngine` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `neurons_per_dim`, `tuning_curves`, `decoding_matrix`, `sparsity`, and `lambda_sparse` are never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:170:5
    |
168 | struct PopulationCoder {
    |        --------------- fields in this struct
169 |     /// Number of neurons per dimension
170 |     neurons_per_dim: usize,
    |     ^^^^^^^^^^^^^^^
171 |     /// Tuning curves for each neuron
172 |     tuning_curves: Vec<TuningCurve>,
    |     ^^^^^^^^^^^^^
173 |     /// Decoding weights
174 |     decoding_matrix: DMatrix<f64>,
    |     ^^^^^^^^^^^^^^^
175 |     /// Sparse coding parameters
176 |     sparsity: f64,
    |     ^^^^^^^^
177 |     lambda_sparse: f64,
    |     ^^^^^^^^^^^^^
    |
    = note: `PopulationCoder` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `preferred`, `sigma`, `max_rate`, and `baseline` are never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:183:5
    |
181 | struct TuningCurve {
    |        ----------- fields in this struct
182 |     /// Preferred value
183 |     preferred: f64,
    |     ^^^^^^^^^
184 |     /// Tuning width
185 |     sigma: f64,
    |     ^^^^^
186 |     /// Maximum firing rate
187 |     max_rate: f64,
    |     ^^^^^^^^
188 |     /// Baseline rate
189 |     baseline: f64,
    |     ^^^^^^^^
    |
    = note: `TuningCurve` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `temporal_kernel` and `sequence_memory` are never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:198:5
    |
194 | struct TemporalProcessor {
    |        ----------------- fields in this struct
...
198 |     temporal_kernel: Vec<f64>,
    |     ^^^^^^^^^^^^^^^
...
202 |     sequence_memory: SequenceMemory,
    |     ^^^^^^^^^^^^^^^
    |
    = note: `TemporalProcessor` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `spectral_radius` is never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:210:5
    |
206 | struct ReservoirState {
    |        -------------- field in this struct
...
210 |     spectral_radius: f64,
    |     ^^^^^^^^^^^^^^^
    |
    = note: `ReservoirState` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `sequences`, `similarity_threshold`, and `max_length` are never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:230:5
    |
228 | struct SequenceMemory {
    |        -------------- fields in this struct
229 |     /// Stored sequences
230 |     sequences: Vec<Vec<DVector<f64>>>,
    |     ^^^^^^^^^
231 |     /// Sequence similarity threshold
232 |     similarity_threshold: f64,
    |     ^^^^^^^^^^^^^^^^^^^^
233 |     /// Maximum sequence length
234 |     max_length: usize,
    |     ^^^^^^^^^^
    |
    = note: `SequenceMemory` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `tau_homeostatic` is never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:245:5
    |
239 | struct HomeostaticController {
    |        --------------------- field in this struct
...
245 |     tau_homeostatic: f64,
    |     ^^^^^^^^^^^^^^^
    |
    = note: `HomeostaticController` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `routing_table` and `pattern_threshold` are never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:256:5
    |
254 | struct SpikeRouter {
    |        ----------- fields in this struct
255 |     /// Routing table based on spike patterns
256 |     routing_table: HashMap<SpikePattern, usize>,
    |     ^^^^^^^^^^^^^
...
262 |     pattern_threshold: f64,
    |     ^^^^^^^^^^^^^^^^^
    |
    = note: `SpikeRouter` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `source`, `target`, and `weight` are never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:276:5
    |
274 | struct Route {
    |        ----- fields in this struct
275 |     /// Source layer
276 |     source: usize,
    |     ^^^^^^
277 |     /// Target layer
278 |     target: usize,
    |     ^^^^^^
279 |     /// Routing weight
280 |     weight: f64,
    |     ^^^^^^
    |
    = note: `Route` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `device` is never read
   --> src/orchestration/production/gpu_monitoring.rs:111:5
    |
105 | pub struct GpuMonitor {
    |            ---------- field in this struct
...
111 |     device: Option<Arc<CudaContext>>,
    |     ^^^^^^

warning: fields `wq`, `wk`, `wv`, and `wo` are never read
  --> src/orchestration/local_llm/gpu_transformer.rs:22:5
   |
17 | pub struct GpuTransformerLayer {
   |            ------------------- fields in this struct
...
22 |     wq: CudaSlice<f32>,  // Query projection weights
   |     ^^
23 |     wk: CudaSlice<f32>,  // Key projection weights
   |     ^^
24 |     wv: CudaSlice<f32>,  // Value projection weights
   |     ^^
25 |     wo: CudaSlice<f32>,  // Output projection weights
   |     ^^

warning: fields `metrics`, `attention_analyzer`, `transfer_entropy`, and `n_heads` are never read
   --> src/orchestration/local_llm/gpu_transformer.rs:416:5
    |
396 | pub struct GpuLLMInference {
    |            --------------- fields in this struct
...
416 |     metrics: Option<LLMMetrics>,
    |     ^^^^^^^
417 |     attention_analyzer: Option<AttentionAnalyzer>,
    |     ^^^^^^^^^^^^^^^^^^
418 |     transfer_entropy: Option<TransferEntropyLLM>,
    |     ^^^^^^^^^^^^^^^^
...
424 |     n_heads: usize,
    |     ^^^^^^^

warning: field `alignment` is never read
   --> src/orchestration/local_llm/gguf_loader.rs:199:5
    |
185 | pub struct GgufLoader {
    |            ---------- field in this struct
...
199 |     alignment: u64,
    |     ^^^^^^^^^

warning: field `timestamp` is never read
  --> src/orchestration/cache/quantum_cache.rs:43:5
   |
39 | struct CachedEntry {
   |        ----------- field in this struct
...
43 |     timestamp: SystemTime,
   |     ^^^^^^^^^
   |
   = note: `CachedEntry` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: field `temperature` is never read
 --> src/orchestration/consensus/hamiltonian.rs:7:5
  |
5 | pub struct InformationHamiltonian {
  |            ---------------------- field in this struct
6 |     n_llms: usize,
7 |     temperature: f64,
  |     ^^^^^^^^^^^

warning: fields `edges` and `mobius` are never read
  --> src/orchestration/decomposition/pid_synergy.rs:32:5
   |
28 | struct InformationLattice {
   |        ------------------ fields in this struct
...
32 |     edges: HashMap<usize, Vec<usize>>,
   |     ^^^^^
33 |     /// Möbius function values for inclusion-exclusion
34 |     mobius: HashMap<(usize, usize), f64>,
   |     ^^^^^^
   |
   = note: `InformationLattice` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `pi_value` and `cumulative_info` are never read
  --> src/orchestration/decomposition/pid_synergy.rs:42:5
   |
38 | struct LatticeNode {
   |        ----------- fields in this struct
...
42 |     pi_value: f64,
   |     ^^^^^^^^
43 |     /// Cumulative information (PI + all descendants)
44 |     cumulative_info: f64,
   |     ^^^^^^^^^^^^^^^
   |
   = note: `LatticeNode` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `use_gpu` and `parallel_threshold` are never read
  --> src/orchestration/decomposition/pid_synergy.rs:71:5
   |
65 | struct OptimizationConfig {
   |        ------------------ fields in this struct
...
71 |     use_gpu: bool,
   |     ^^^^^^^
72 |     /// Parallel decomposition for large systems
73 |     parallel_threshold: usize,
   |     ^^^^^^^^^^^^^^^^^^
   |
   = note: `OptimizationConfig` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `pi_a` is never read
  --> src/orchestration/inference/hierarchical_active_inference.rs:58:5
   |
52 | struct PrecisionMatrix {
   |        --------------- field in this struct
...
58 |     pi_a: DMatrix<f64>,
   |     ^^^^
   |
   = note: `PrecisionMatrix` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `kl_divergence` is never read
  --> src/orchestration/inference/hierarchical_active_inference.rs:75:5
   |
67 | struct VariationalParameters {
   |        --------------------- field in this struct
...
75 |     kl_divergence: f64,
   |     ^^^^^^^^^^^^^
   |
   = note: `VariationalParameters` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `eta_pi` and `eta_a` are never read
  --> src/orchestration/inference/hierarchical_active_inference.rs:86:5
   |
82 | struct LearningRates {
   |        ------------- fields in this struct
...
86 |     eta_pi: f64,
   |     ^^^^^^
...
90 |     eta_a: f64,
   |     ^^^^^
   |
   = note: `LearningRates` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `habits` is never read
   --> src/orchestration/inference/hierarchical_active_inference.rs:120:5
    |
110 | struct ActionSelection {
    |        --------------- field in this struct
...
120 |     habits: DVector<f64>,
    |     ^^^^^^
    |
    = note: `ActionSelection` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `probability` and `expected_outcomes` are never read
   --> src/orchestration/inference/hierarchical_active_inference.rs:128:5
    |
124 | struct Policy {
    |        ------ fields in this struct
...
128 |     probability: f64,
    |     ^^^^^^^^^^^
129 |     /// Expected outcomes under this policy
130 |     expected_outcomes: Vec<DVector<f64>>,
    |     ^^^^^^^^^^^^^^^^^
    |
    = note: `Policy` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `id` is never read
  --> src/orchestration/inference/joint_active_inference.rs:34:5
   |
32 | struct ActiveInferenceAgent {
   |        -------------------- field in this struct
33 |     /// Agent ID
34 |     id: usize,
   |     ^^
   |
   = note: `ActiveInferenceAgent` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `B`, `C`, `D`, `theta`, and `depth` are never read
  --> src/orchestration/inference/joint_active_inference.rs:57:5
   |
53 | struct LocalGenerativeModel {
   |        -------------------- fields in this struct
...
57 |     B: DMatrix<f64>,
   |     ^
58 |     /// Prior preferences C
59 |     C: DVector<f64>,
   |     ^
60 |     /// Initial state prior D
61 |     D: DVector<f64>,
   |     ^
62 |     /// Model parameters θ
63 |     theta: DVector<f64>,
   |     ^^^^^
64 |     /// Hierarchical depth
65 |     depth: usize,
   |     ^^^^^
   |
   = note: `LocalGenerativeModel` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `sigma` and `info_gain` are never read
  --> src/orchestration/inference/joint_active_inference.rs:74:5
   |
70 | struct BeliefState {
   |        ----------- fields in this struct
...
74 |     sigma: DMatrix<f64>,
   |     ^^^^^
...
80 |     info_gain: f64,
   |     ^^^^^^^^^
   |
   = note: `BeliefState` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `pi_w`, `pi_gamma`, `attention`, and `adaptive` are never read
  --> src/orchestration/inference/joint_active_inference.rs:91:5
   |
87 | struct PrecisionWeights {
   |        ---------------- fields in this struct
...
91 |     pi_w: f64,
   |     ^^^^
92 |     /// Policy precision
93 |     pi_gamma: f64,
   |     ^^^^^^^^
94 |     /// Attention weights
95 |     attention: DVector<f64>,
   |     ^^^^^^^^^
96 |     /// Adaptive precision
97 |     adaptive: bool,
   |     ^^^^^^^^
   |
   = note: `PrecisionWeights` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `eta_theta`, `eta_pi`, `temperature`, and `gamma` are never read
   --> src/orchestration/inference/joint_active_inference.rs:106:5
    |
102 | struct LearningParameters {
    |        ------------------ fields in this struct
...
106 |     eta_theta: f64,
    |     ^^^^^^^^^
107 |     /// Learning rate for precision
108 |     eta_pi: f64,
    |     ^^^^^^
109 |     /// Exploration temperature
110 |     temperature: f64,
    |     ^^^^^^^^^^^
111 |     /// Discount factor
112 |     gamma: f64,
    |     ^^^^^
    |
    = note: `LearningParameters` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `from`, `msg_type`, and `timestamp` are never read
   --> src/orchestration/inference/joint_active_inference.rs:119:5
    |
117 | struct Message {
    |        ------- fields in this struct
118 |     /// Sender ID
119 |     from: usize,
    |     ^^^^
...
123 |     msg_type: MessageType,
    |     ^^^^^^^^
...
127 |     timestamp: f64,
    |     ^^^^^^^^^
    |
    = note: `Message` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `PolicyProposal`, `ObservationReport`, `CoordinationRequest`, and `ConsensusVote` are never constructed
   --> src/orchestration/inference/joint_active_inference.rs:133:5
    |
131 | enum MessageType {
    |      ----------- variants in this enum
132 |     BeliefUpdate,
133 |     PolicyProposal,
    |     ^^^^^^^^^^^^^^
134 |     ObservationReport,
    |     ^^^^^^^^^^^^^^^^^
135 |     CoordinationRequest,
    |     ^^^^^^^^^^^^^^^^^^^
136 |     ConsensusVote,
    |     ^^^^^^^^^^^^^
    |
    = note: `MessageType` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Policy`, `Observation`, `Coordination`, and `Vote` are never constructed
   --> src/orchestration/inference/joint_active_inference.rs:142:5
    |
140 | enum MessageContent {
    |      -------------- variants in this enum
141 |     Belief(DVector<f64>),
142 |     Policy(Vec<f64>),
    |     ^^^^^^
143 |     Observation(DVector<f64>),
    |     ^^^^^^^^^^^
144 |     Coordination(CoordinationData),
    |     ^^^^^^^^^^^^
145 |     Vote(f64),
    |     ^^^^
    |
    = note: `MessageContent` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `action_proposal`, `expected_outcome`, and `confidence` are never read
   --> src/orchestration/inference/joint_active_inference.rs:150:5
    |
149 | struct CoordinationData {
    |        ---------------- fields in this struct
150 |     action_proposal: DVector<f64>,
    |     ^^^^^^^^^^^^^^^
151 |     expected_outcome: DVector<f64>,
    |     ^^^^^^^^^^^^^^^^
152 |     confidence: f64,
    |     ^^^^^^^^^^
    |
    = note: `CoordinationData` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `global_states`, `joint_dynamics`, and `shared_priors` are never read
   --> src/orchestration/inference/joint_active_inference.rs:159:5
    |
157 | struct SharedGenerativeModel {
    |        --------------------- fields in this struct
158 |     /// Global state space
159 |     global_states: DMatrix<f64>,
    |     ^^^^^^^^^^^^^
160 |     /// Joint transition dynamics
161 |     joint_dynamics: JointDynamics,
    |     ^^^^^^^^^^^^^^
162 |     /// Shared priors
163 |     shared_priors: SharedPriors,
    |     ^^^^^^^^^^^^^
    |
    = note: `SharedGenerativeModel` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `T`, `I`, and `nonlinear` are never read
   --> src/orchestration/inference/joint_active_inference.rs:173:5
    |
171 | struct JointDynamics {
    |        ------------- fields in this struct
172 |     /// Joint state transition
173 |     T: DMatrix<f64>,
    |     ^
174 |     /// Interaction terms
175 |     I: DMatrix<f64>,
    |     ^
176 |     /// Nonlinear coupling
177 |     nonlinear: NonlinearCoupling,
    |     ^^^^^^^^^
    |
    = note: `JointDynamics` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `f` and `J` are never read
   --> src/orchestration/inference/joint_active_inference.rs:183:5
    |
181 | struct NonlinearCoupling {
    |        ----------------- fields in this struct
182 |     /// Coupling function
183 |     f: fn(&DVector<f64>, &DVector<f64>) -> DVector<f64>,
    |     ^
184 |     /// Jacobian
185 |     J: DMatrix<f64>,
    |     ^
    |
    = note: `NonlinearCoupling` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `goals`, `constraints`, and `prior_cov` are never read
   --> src/orchestration/inference/joint_active_inference.rs:191:5
    |
189 | struct SharedPriors {
    |        ------------ fields in this struct
190 |     /// Shared goals
191 |     goals: DVector<f64>,
    |     ^^^^^
192 |     /// Common constraints
193 |     constraints: Vec<Constraint>,
    |     ^^^^^^^^^^^
194 |     /// Prior covariance
195 |     prior_cov: DMatrix<f64>,
    |     ^^^^^^^^^
    |
    = note: `SharedPriors` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `constraint_type` and `value` are never read
   --> src/orchestration/inference/joint_active_inference.rs:201:5
    |
199 | struct Constraint {
    |        ---------- fields in this struct
200 |     /// Constraint type
201 |     constraint_type: ConstraintType,
    |     ^^^^^^^^^^^^^^^
202 |     /// Constraint value
203 |     value: f64,
    |     ^^^^^
    |
    = note: `Constraint` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Equality`, `Inequality`, and `Boundary` are never constructed
   --> src/orchestration/inference/joint_active_inference.rs:208:5
    |
207 | enum ConstraintType {
    |      -------------- variants in this enum
208 |     Equality,
    |     ^^^^^^^^
209 |     Inequality,
    |     ^^^^^^^^^^
210 |     Boundary,
    |     ^^^^^^^^
    |
    = note: `ConstraintType` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `delays` and `adaptive` are never read
   --> src/orchestration/inference/joint_active_inference.rs:218:5
    |
214 | struct CouplingMatrix {
    |        -------------- fields in this struct
...
218 |     delays: DMatrix<usize>,
    |     ^^^^^^
219 |     /// Adaptive coupling
220 |     adaptive: bool,
    |     ^^^^^^^^
    |
    = note: `CouplingMatrix` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `state`, `emergence`, and `stability` are never read
   --> src/orchestration/inference/joint_active_inference.rs:226:5
    |
224 | struct EmergentState {
    |        ------------- fields in this struct
225 |     /// State vector
226 |     state: DVector<f64>,
    |     ^^^^^
227 |     /// Emergence measure
228 |     emergence: f64,
    |     ^^^^^^^^^
229 |     /// Stability
230 |     stability: f64,
    |     ^^^^^^^^^
    |
    = note: `EmergentState` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `encoding` is never read
   --> src/orchestration/inference/joint_active_inference.rs:241:5
    |
235 | struct CommunicationProtocol {
    |        --------------------- field in this struct
...
241 |     encoding: MessageEncoding,
    |     ^^^^^^^^
    |
    = note: `CommunicationProtocol` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Ring`, `Star`, `Hierarchical`, `SmallWorld`, and `Dynamic` are never constructed
   --> src/orchestration/inference/joint_active_inference.rs:249:5
    |
247 | enum CommunicationTopology {
    |      --------------------- variants in this enum
248 |     FullyConnected,
249 |     Ring,
    |     ^^^^
250 |     Star,
    |     ^^^^
251 |     Hierarchical,
    |     ^^^^^^^^^^^^
252 |     SmallWorld,
    |     ^^^^^^^^^^
253 |     Dynamic,
    |     ^^^^^^^
    |
    = note: `CommunicationTopology` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `max_size` is never read
   --> src/orchestration/inference/joint_active_inference.rs:261:5
    |
257 | struct BandwidthLimits {
    |        --------------- field in this struct
...
261 |     max_size: usize,
    |     ^^^^^^^^
    |
    = note: `BandwidthLimits` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Uniform` and `Exponential` are never constructed
   --> src/orchestration/inference/joint_active_inference.rs:269:5
    |
267 | enum DelayDistribution {
    |      ----------------- variants in this enum
268 |     Constant(f64),
269 |     Uniform(f64, f64),
    |     ^^^^^^^
270 |     Exponential(f64),
    |     ^^^^^^^^^^^
    |
    = note: `DelayDistribution` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Sparse`, `Compressed`, and `Hierarchical` are never constructed
   --> src/orchestration/inference/joint_active_inference.rs:276:5
    |
274 | enum MessageEncoding {
    |      --------------- variants in this enum
275 |     Dense,
276 |     Sparse,
    |     ^^^^^^
277 |     Compressed,
    |     ^^^^^^^^^^
278 |     Hierarchical,
    |     ^^^^^^^^^^^^
    |
    = note: `MessageEncoding` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `max_retries` is never read
   --> src/orchestration/inference/joint_active_inference.rs:288:5
    |
282 | struct ReliabilityParams {
    |        ----------------- field in this struct
...
288 |     max_retries: usize,
    |     ^^^^^^^^^^^
    |
    = note: `ReliabilityParams` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `synchronization` and `commitment` are never read
   --> src/orchestration/inference/joint_active_inference.rs:297:5
    |
293 | struct CoordinationMechanism {
    |        --------------------- fields in this struct
...
297 |     synchronization: SynchronizationMethod,
    |     ^^^^^^^^^^^^^^^
...
301 |     commitment: CommitmentProtocol,
    |     ^^^^^^^^^^
    |
    = note: `CoordinationMechanism` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Averaging`, `Voting`, `Raft`, and `PBFT` are never constructed
   --> src/orchestration/inference/joint_active_inference.rs:306:5
    |
305 | enum ConsensusAlgorithm {
    |      ------------------ variants in this enum
306 |     Averaging,
    |     ^^^^^^^^^
307 |     Voting,
    |     ^^^^^^
308 |     ByzantineAgreement,
309 |     Raft,
    |     ^^^^
310 |     PBFT,
    |     ^^^^
    |
    = note: `ConsensusAlgorithm` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Synchronous`, `Asynchronous`, and `EventDriven` are never constructed
   --> src/orchestration/inference/joint_active_inference.rs:315:5
    |
314 | enum SynchronizationMethod {
    |      --------------------- variants in this enum
315 |     Synchronous,
    |     ^^^^^^^^^^^
316 |     Asynchronous,
    |     ^^^^^^^^^^^^
317 |     PartiallySynchronous,
318 |     EventDriven,
    |     ^^^^^^^^^^^
    |
    = note: `SynchronizationMethod` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Priority`, `Arbitration`, and `RandomSelection` are never constructed
   --> src/orchestration/inference/joint_active_inference.rs:323:5
    |
322 | enum ConflictResolution {
    |      ------------------ variants in this enum
323 |     Priority,
    |     ^^^^^^^^
324 |     Negotiation,
325 |     Arbitration,
    |     ^^^^^^^^^^^
326 |     RandomSelection,
    |     ^^^^^^^^^^^^^^^
    |
    = note: `ConflictResolution` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `two_phase`, `timeout`, and `rollback` are never read
   --> src/orchestration/inference/joint_active_inference.rs:332:5
    |
330 | struct CommitmentProtocol {
    |        ------------------ fields in this struct
331 |     /// Two-phase commit
332 |     two_phase: bool,
    |     ^^^^^^^^^
333 |     /// Timeout for commitment
334 |     timeout: f64,
    |     ^^^^^^^
335 |     /// Rollback mechanism
336 |     rollback: bool,
    |     ^^^^^^^^
    |
    = note: `CommitmentProtocol` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `time`, `order_before`, and `critical_point` are never read
   --> src/orchestration/inference/joint_active_inference.rs:372:5
    |
370 | struct PhaseTransition {
    |        --------------- fields in this struct
371 |     /// Time of transition
372 |     time: f64,
    |     ^^^^
373 |     /// Order parameter before
374 |     order_before: f64,
    |     ^^^^^^^^^^^^
...
378 |     critical_point: f64,
    |     ^^^^^^^^^^^^^^
    |
    = note: `PhaseTransition` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `pattern_type`, `spatial`, `temporal`, and `stability` are never read
   --> src/orchestration/inference/joint_active_inference.rs:384:5
    |
382 | struct EmergentPattern {
    |        --------------- fields in this struct
383 |     /// Pattern type
384 |     pattern_type: PatternType,
    |     ^^^^^^^^^^^^
385 |     /// Spatial configuration
386 |     spatial: DMatrix<f64>,
    |     ^^^^^^^
387 |     /// Temporal dynamics
388 |     temporal: Vec<f64>,
    |     ^^^^^^^^
389 |     /// Stability measure
390 |     stability: f64,
    |     ^^^^^^^^^
    |
    = note: `EmergentPattern` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Clustering`, `WaveFormation`, and `Differentiation` are never constructed
   --> src/orchestration/inference/joint_active_inference.rs:396:5
    |
394 | enum PatternType {
    |      ----------- variants in this enum
395 |     Synchronization,
396 |     Clustering,
    |     ^^^^^^^^^^
397 |     WaveFormation,
    |     ^^^^^^^^^^^^^
398 |     Consensus,
399 |     Differentiation,
    |     ^^^^^^^^^^^^^^^
    |
    = note: `PatternType` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `individual_spaces`, `joint_actions`, and `pareto_frontier` are never read
   --> src/orchestration/inference/joint_active_inference.rs:406:5
    |
404 | struct JointActionSpace {
    |        ---------------- fields in this struct
405 |     /// Individual action spaces
406 |     individual_spaces: Vec<ActionSpace>,
    |     ^^^^^^^^^^^^^^^^^
407 |     /// Joint action combinations
408 |     joint_actions: Vec<JointAction>,
    |     ^^^^^^^^^^^^^
...
412 |     pareto_frontier: Vec<JointAction>,
    |     ^^^^^^^^^^^^^^^
    |
    = note: `JointActionSpace` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `discrete`, `continuous`, and `mixed` are never read
   --> src/orchestration/inference/joint_active_inference.rs:418:5
    |
416 | struct ActionSpace {
    |        ----------- fields in this struct
417 |     /// Discrete actions
418 |     discrete: Vec<usize>,
    |     ^^^^^^^^
419 |     /// Continuous actions
420 |     continuous: DVector<f64>,
    |     ^^^^^^^^^^
421 |     /// Mixed actions
422 |     mixed: MixedAction,
    |     ^^^^^
    |
    = note: `ActionSpace` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `discrete_part` and `continuous_part` are never read
   --> src/orchestration/inference/joint_active_inference.rs:427:5
    |
426 | struct MixedAction {
    |        ----------- fields in this struct
427 |     discrete_part: usize,
    |     ^^^^^^^^^^^^^
428 |     continuous_part: DVector<f64>,
    |     ^^^^^^^^^^^^^^^
    |
    = note: `MixedAction` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `actions`, `expected_outcome`, `utility`, and `feasible` are never read
   --> src/orchestration/inference/joint_active_inference.rs:434:5
    |
432 | struct JointAction {
    |        ----------- fields in this struct
433 |     /// Actions for each agent
434 |     actions: Vec<DVector<f64>>,
    |     ^^^^^^^
435 |     /// Expected joint outcome
436 |     expected_outcome: DVector<f64>,
    |     ^^^^^^^^^^^^^^^^
437 |     /// Joint utility
438 |     utility: f64,
    |     ^^^^^^^
439 |     /// Feasibility
440 |     feasible: bool,
    |     ^^^^^^^^
    |
    = note: `JointAction` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `agents` and `constraint_fn` are never read
   --> src/orchestration/inference/joint_active_inference.rs:446:5
    |
444 | struct CoordinationConstraint {
    |        ---------------------- fields in this struct
445 |     /// Agents involved
446 |     agents: Vec<usize>,
    |     ^^^^^^
447 |     /// Constraint function
448 |     constraint_fn: fn(&[DVector<f64>]) -> bool,
    |     ^^^^^^^^^^^^^
    |
    = note: `CoordinationConstraint` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `expected_value` and `coordination_cost` are never read
    --> src/orchestration/inference/joint_active_inference.rs:1534:5
     |
1532 | struct JointPolicy {
     |        ----------- fields in this struct
1533 |     agent_policies: Vec<AgentPolicy>,
1534 |     expected_value: f64,
     |     ^^^^^^^^^^^^^^
1535 |     coordination_cost: f64,
     |     ^^^^^^^^^^^^^^^^^
     |
     = note: `JointPolicy` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `original` is never read
  --> src/orchestration/causality/bidirectional_causality.rs:54:5
   |
50 | struct ShadowManifold {
   |        -------------- field in this struct
...
54 |     original: DVector<f64>,
   |     ^^^^^^^^
   |
   = note: `ShadowManifold` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `FixedWidth`, `KernelDensity`, and `Symbolic` are never constructed
  --> src/orchestration/causality/bidirectional_causality.rs:80:5
   |
79 | enum BinningMethod {
   |      ------------- variants in this enum
80 |     FixedWidth(usize),
   |     ^^^^^^^^^^
81 |     Adaptive,
82 |     KernelDensity,
   |     ^^^^^^^^^^^^^
83 |     Symbolic,
   |     ^^^^^^^^
   |
   = note: `BinningMethod` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `alpha`, `use_var`, `spectral`, and `conditional_vars` are never read
   --> src/orchestration/causality/bidirectional_causality.rs:92:5
    |
 88 | struct GrangerCausalityTester {
    |        ---------------------- fields in this struct
...
 92 |     alpha: f64,
    |     ^^^^^
 93 |     /// Use VAR model
 94 |     use_var: bool,
    |     ^^^^^^^
...
 98 |     spectral: bool,
    |     ^^^^^^^^
 99 |     /// Conditional Granger causality
100 |     conditional_vars: Vec<String>,
    |     ^^^^^^^^^^^^^^^^
    |
    = note: `GrangerCausalityTester` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `d_separation_cache` and `backdoor_paths` are never read
   --> src/orchestration/causality/bidirectional_causality.rs:113:5
    |
105 | struct CausalGraph {
    |        ----------- fields in this struct
...
113 |     d_separation_cache: HashMap<(usize, usize, HashSet<usize>), bool>,
    |     ^^^^^^^^^^^^^^^^^^
114 |     /// Backdoor paths
115 |     backdoor_paths: HashMap<(usize, usize), Vec<Vec<usize>>>,
    |     ^^^^^^^^^^^^^^
    |
    = note: `CausalGraph` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `node_type`, `observed`, and `intervened` are never read
   --> src/orchestration/causality/bidirectional_causality.rs:123:5
    |
119 | struct CausalNode {
    |        ---------- fields in this struct
...
123 |     node_type: NodeType,
    |     ^^^^^^^^^
124 |     /// Is observed
125 |     observed: bool,
    |     ^^^^^^^^
126 |     /// Intervention state
127 |     intervened: Option<f64>,
    |     ^^^^^^^^^^
    |
    = note: `CausalNode` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Latent`, `Confounder`, `Mediator`, and `Collider` are never constructed
   --> src/orchestration/causality/bidirectional_causality.rs:133:5
    |
131 | enum NodeType {
    |      -------- variants in this enum
132 |     Observed,
133 |     Latent,
    |     ^^^^^^
134 |     Confounder,
    |     ^^^^^^^^^^
135 |     Mediator,
    |     ^^^^^^^^
136 |     Collider,
    |     ^^^^^^^^
    |
    = note: `NodeType` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `strength`, `edge_type`, and `lag` are never read
   --> src/orchestration/causality/bidirectional_causality.rs:142:5
    |
140 | struct CausalEdge {
    |        ---------- fields in this struct
141 |     /// Edge strength
142 |     strength: f64,
    |     ^^^^^^^^
143 |     /// Edge type
144 |     edge_type: EdgeType,
    |     ^^^^^^^^^
145 |     /// Time lag
146 |     lag: usize,
    |     ^^^
    |
    = note: `CausalEdge` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variant `TimeDelayed` is never constructed
   --> src/orchestration/causality/bidirectional_causality.rs:154:5
    |
150 | enum EdgeType {
    |      -------- variant in this enum
...
154 |     TimeDelayed,
    |     ^^^^^^^^^^^
    |
    = note: `EdgeType` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `conflict_resolution` is never read
   --> src/orchestration/causality/bidirectional_causality.rs:169:5
    |
159 | struct PCAlgorithm {
    |        ----------- field in this struct
...
169 |     conflict_resolution: ConflictResolution,
    |     ^^^^^^^^^^^^^^^^^^^
    |
    = note: `PCAlgorithm` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `PartialCorrelation`, `MutualInformation`, and `KernelCIT` are never constructed
   --> src/orchestration/causality/bidirectional_causality.rs:174:5
    |
173 | enum IndependenceTest {
    |      ---------------- variants in this enum
174 |     PartialCorrelation,
    |     ^^^^^^^^^^^^^^^^^^
175 |     MutualInformation,
    |     ^^^^^^^^^^^^^^^^^
176 |     HSIC,  // Hilbert-Schmidt Independence Criterion
177 |     KernelCIT,  // Kernel Conditional Independence Test
    |     ^^^^^^^^^
    |
    = note: `IndependenceTest` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variant `ConservativeOrientation` is never constructed
   --> src/orchestration/causality/bidirectional_causality.rs:184:5
    |
181 | enum OrientationRule {
    |      --------------- variant in this enum
...
184 |     ConservativeOrientation,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: `OrientationRule` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Conservative`, `Majority`, and `MaxStrength` are never constructed
   --> src/orchestration/causality/bidirectional_causality.rs:190:5
    |
189 | enum ConflictResolution {
    |      ------------------ variants in this enum
190 |     Conservative,
    |     ^^^^^^^^^^^^
191 |     Majority,
    |     ^^^^^^^^
192 |     MaxStrength,
    |     ^^^^^^^^^^^
    |
    = note: `ConflictResolution` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `RandomShuffle`, `PhaseRandomization`, and `TwinSurrogates` are never constructed
   --> src/orchestration/causality/bidirectional_causality.rs:215:5
    |
214 | enum SurrogateMethod {
    |      --------------- variants in this enum
215 |     RandomShuffle,
    |     ^^^^^^^^^^^^^
216 |     PhaseRandomization,
    |     ^^^^^^^^^^^^^^^^^^
217 |     IAAFT,  // Iterative Amplitude Adjusted Fourier Transform
218 |     TwinSurrogates,
    |     ^^^^^^^^^^^^^^
    |
    = note: `SurrogateMethod` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `None`, `Bonferroni`, and `BenjaminiYekutieli` are never constructed
   --> src/orchestration/causality/bidirectional_causality.rs:223:5
    |
222 | enum MultipleTestingCorrection {
    |      ------------------------- variants in this enum
223 |     None,
    |     ^^^^
224 |     Bonferroni,
    |     ^^^^^^^^^^
225 |     BenjaminiHochberg,
226 |     BenjaminiYekutieli,
    |     ^^^^^^^^^^^^^^^^^^
    |
    = note: `MultipleTestingCorrection` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `sampling_rate` and `capacity` are never read
   --> src/orchestration/causality/bidirectional_causality.rs:235:5
    |
231 | struct TimeSeriesBuffer {
    |        ---------------- fields in this struct
...
235 |     sampling_rate: f64,
    |     ^^^^^^^^^^^^^
236 |     /// Buffer capacity
237 |     capacity: usize,
    |     ^^^^^^^^
    |
    = note: `TimeSeriesBuffer` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `p_value`, `adjusted_p`, and `significant` are never read
    --> src/orchestration/causality/bidirectional_causality.rs:1788:5
     |
1787 | struct SignificanceResult {
     |        ------------------ fields in this struct
1788 |     p_value: f64,
     |     ^^^^^^^
1789 |     adjusted_p: f64,
     |     ^^^^^^^^^^
1790 |     significant: bool,
     |     ^^^^^^^^^^^
     |
     = note: `SignificanceResult` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `channels` and `multipartite` are never read
  --> src/orchestration/quantum/quantum_entanglement_measures.rs:24:5
   |
14 | pub struct QuantumEntanglementAnalyzer {
   |            --------------------------- fields in this struct
...
24 |     channels: QuantumChannels,
   |     ^^^^^^^^
...
28 |     multipartite: MultipartiteEntanglement,
   |     ^^^^^^^^^^^^

warning: field `eigenvectors` is never read
  --> src/orchestration/quantum/quantum_entanglement_measures.rs:45:5
   |
33 | struct DensityMatrixHandler {
   |        -------------------- field in this struct
...
45 |     eigenvectors: DMatrix<Complex64>,
   |     ^^^^^^^^^^^^
   |
   = note: `DensityMatrixHandler` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `squashed`, `formation`, and `distillable` are never read
  --> src/orchestration/quantum/quantum_entanglement_measures.rs:58:5
   |
50 | struct EntanglementMeasures {
   |        -------------------- fields in this struct
...
58 |     squashed: SquashedEntanglement,
   |     ^^^^^^^^
59 |     /// Entanglement of formation
60 |     formation: EntanglementOfFormation,
   |     ^^^^^^^^^
61 |     /// Distillable entanglement
62 |     distillable: DistillableEntanglement,
   |     ^^^^^^^^^^^
   |
   = note: `EntanglementMeasures` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `magic_basis` is never read
  --> src/orchestration/quantum/quantum_entanglement_measures.rs:74:5
   |
68 | struct ConcurrenceMeasure {
   |        ------------------ field in this struct
...
74 |     magic_basis: DMatrix<Complex64>,
   |     ^^^^^^^^^^^
   |
   = note: `ConcurrenceMeasure` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `iterations` is never read
  --> src/orchestration/quantum/quantum_entanglement_measures.rs:96:5
   |
90 | struct RelativeEntropyMeasure {
   |        ---------------------- field in this struct
...
96 |     iterations: usize,
   |     ^^^^^^^^^^
   |
   = note: `RelativeEntropyMeasure` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `value`, `cmi`, and `extension_dim` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:102:5
    |
100 | struct SquashedEntanglement {
    |        -------------------- fields in this struct
101 |     /// Squashed entanglement value
102 |     value: f64,
    |     ^^^^^
103 |     /// Conditional mutual information
104 |     cmi: f64,
    |     ^^^
105 |     /// Extension dimension
106 |     extension_dim: usize,
    |     ^^^^^^^^^^^^^
    |
    = note: `SquashedEntanglement` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `value`, `decomposition`, and `convex_roof` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:112:5
    |
110 | struct EntanglementOfFormation {
    |        ----------------------- fields in this struct
111 |     /// EOF value
112 |     value: f64,
    |     ^^^^^
113 |     /// Optimal decomposition
114 |     decomposition: Vec<(f64, DMatrix<Complex64>)>,
    |     ^^^^^^^^^^^^^
115 |     /// Convex roof
116 |     convex_roof: f64,
    |     ^^^^^^^^^^^
    |
    = note: `EntanglementOfFormation` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `rate`, `efficiency`, and `fidelity` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:122:5
    |
120 | struct DistillableEntanglement {
    |        ----------------------- fields in this struct
121 |     /// Distillable entanglement rate
122 |     rate: f64,
    |     ^^^^
123 |     /// Protocol efficiency
124 |     efficiency: f64,
    |     ^^^^^^^^^^
125 |     /// Fidelity after distillation
126 |     fidelity: f64,
    |     ^^^^^^^^
    |
    = note: `DistillableEntanglement` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `monotone` and `additive` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:134:5
    |
130 | struct LogarithmicNegativity {
    |        --------------------- fields in this struct
...
134 |     monotone: bool,
    |     ^^^^^^^^
135 |     /// Additivity satisfied
136 |     additive: bool,
    |     ^^^^^^^^
    |
    = note: `LogarithmicNegativity` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `geometric_discord`, `mid`, `deficit`, and `work_deficit` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:145:5
    |
141 | struct QuantumCorrelations {
    |        ------------------- fields in this struct
...
145 |     geometric_discord: GeometricDiscord,
    |     ^^^^^^^^^^^^^^^^^
146 |     /// Measurement-induced disturbance
147 |     mid: MeasurementInducedDisturbance,
    |     ^^^
148 |     /// Quantum deficit
149 |     deficit: QuantumDeficit,
    |     ^^^^^^^
150 |     /// One-way work deficit
151 |     work_deficit: OneWayWorkDeficit,
    |     ^^^^^^^^^^^^
    |
    = note: `QuantumCorrelations` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `value`, `closest_classical`, and `hs_distance` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:169:5
    |
167 | struct GeometricDiscord {
    |        ---------------- fields in this struct
168 |     /// Geometric discord value
169 |     value: f64,
    |     ^^^^^
170 |     /// Closest classical state
171 |     closest_classical: DMatrix<Complex64>,
    |     ^^^^^^^^^^^^^^^^^
172 |     /// Hilbert-Schmidt distance
173 |     hs_distance: f64,
    |     ^^^^^^^^^^^
    |
    = note: `GeometricDiscord` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `value`, `pre_state`, and `post_state` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:179:5
    |
177 | struct MeasurementInducedDisturbance {
    |        ----------------------------- fields in this struct
178 |     /// MID value
179 |     value: f64,
    |     ^^^^^
180 |     /// Pre-measurement state
181 |     pre_state: DMatrix<Complex64>,
    |     ^^^^^^^^^
182 |     /// Post-measurement state
183 |     post_state: DMatrix<Complex64>,
    |     ^^^^^^^^^^
    |
    = note: `MeasurementInducedDisturbance` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `value`, `zero_way`, and `one_way` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:189:5
    |
187 | struct QuantumDeficit {
    |        -------------- fields in this struct
188 |     /// Deficit value
189 |     value: f64,
    |     ^^^^^
190 |     /// Zero-way deficit
191 |     zero_way: f64,
    |     ^^^^^^^^
192 |     /// One-way deficit
193 |     one_way: f64,
    |     ^^^^^^^
    |
    = note: `QuantumDeficit` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `value`, `extractable_work`, and `thermal_state` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:199:5
    |
197 | struct OneWayWorkDeficit {
    |        ----------------- fields in this struct
198 |     /// Work deficit value
199 |     value: f64,
    |     ^^^^^
200 |     /// Extractable work
201 |     extractable_work: f64,
    |     ^^^^^^^^^^^^^^^^
202 |     /// Thermal state
203 |     thermal_state: DMatrix<Complex64>,
    |     ^^^^^^^^^^^^^
    |
    = note: `OneWayWorkDeficit` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `nonlinear`, `optimal`, and `decomposition` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:212:5
    |
208 | struct EntanglementWitnesses {
    |        --------------------- fields in this struct
...
212 |     nonlinear: Vec<NonlinearWitness>,
    |     ^^^^^^^^^
213 |     /// Optimal witness
214 |     optimal: OptimalWitness,
    |     ^^^^^^^
215 |     /// Witness decomposition
216 |     decomposition: WitnessDecomposition,
    |     ^^^^^^^^^^^^^
    |
    = note: `EntanglementWitnesses` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `W`, `expectation`, `threshold`, and `detected` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:222:5
    |
220 | struct LinearWitness {
    |        ------------- fields in this struct
221 |     /// Witness operator
222 |     W: DMatrix<Complex64>,
    |     ^
223 |     /// Expectation value
224 |     expectation: f64,
    |     ^^^^^^^^^^^
225 |     /// Detection threshold
226 |     threshold: f64,
    |     ^^^^^^^^^
227 |     /// Detected entanglement
228 |     detected: bool,
    |     ^^^^^^^^
    |
    = note: `LinearWitness` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `witness_fn`, `value`, and `separable_bound` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:234:5
    |
232 | struct NonlinearWitness {
    |        ---------------- fields in this struct
233 |     /// Witness function
234 |     witness_fn: fn(&DMatrix<Complex64>) -> f64,
    |     ^^^^^^^^^^
235 |     /// Value for current state
236 |     value: f64,
    |     ^^^^^
237 |     /// Separable bound
238 |     separable_bound: f64,
    |     ^^^^^^^^^^^^^^^
    |
    = note: `NonlinearWitness` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `W_opt`, `method`, and `strength` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:244:5
    |
242 | struct OptimalWitness {
    |        -------------- fields in this struct
243 |     /// Optimal witness operator
244 |     W_opt: DMatrix<Complex64>,
    |     ^^^^^
245 |     /// Optimization method used
246 |     method: OptimizationMethod,
    |     ^^^^^^
247 |     /// Witness strength
248 |     strength: f64,
    |     ^^^^^^^^
    |
    = note: `OptimalWitness` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `GradientDescent`, `GeneticAlgorithm`, and `ConvexOptimization` are never constructed
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:254:5
    |
252 | enum OptimizationMethod {
    |      ------------------ variants in this enum
253 |     SDP,  // Semidefinite programming
254 |     GradientDescent,
    |     ^^^^^^^^^^^^^^^
255 |     GeneticAlgorithm,
    |     ^^^^^^^^^^^^^^^^
256 |     ConvexOptimization,
    |     ^^^^^^^^^^^^^^^^^^
    |
    = note: `OptimizationMethod` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `positive`, `negative`, and `error` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:262:5
    |
260 | struct WitnessDecomposition {
    |        -------------------- fields in this struct
261 |     /// Positive part
262 |     positive: DMatrix<Complex64>,
    |     ^^^^^^^^
263 |     /// Negative part
264 |     negative: DMatrix<Complex64>,
    |     ^^^^^^^^
265 |     /// Decomposition error
266 |     error: f64,
    |     ^^^^^
    |
    = note: `WitnessDecomposition` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `depolarizing`, `amplitude_damping`, `phase_damping`, `entanglement_breaking`, and `locc` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:273:5
    |
271 | struct QuantumChannels {
    |        --------------- fields in this struct
272 |     /// Depolarizing channel
273 |     depolarizing: DepolarizingChannel,
    |     ^^^^^^^^^^^^
274 |     /// Amplitude damping
275 |     amplitude_damping: AmplitudeDampingChannel,
    |     ^^^^^^^^^^^^^^^^^
276 |     /// Phase damping
277 |     phase_damping: PhaseDampingChannel,
    |     ^^^^^^^^^^^^^
278 |     /// Entanglement breaking channels
279 |     entanglement_breaking: EntanglementBreakingChannel,
    |     ^^^^^^^^^^^^^^^^^^^^^
280 |     /// LOCC operations
281 |     locc: LOCCOperations,
    |     ^^^^
    |
    = note: `QuantumChannels` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `p`, `kraus`, and `capacity` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:287:5
    |
285 | struct DepolarizingChannel {
    |        ------------------- fields in this struct
286 |     /// Depolarizing probability
287 |     p: f64,
    |     ^
288 |     /// Kraus operators
289 |     kraus: Vec<DMatrix<Complex64>>,
    |     ^^^^^
290 |     /// Channel capacity
291 |     capacity: f64,
    |     ^^^^^^^^
    |
    = note: `DepolarizingChannel` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `gamma`, `kraus`, and `steady_state` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:297:5
    |
295 | struct AmplitudeDampingChannel {
    |        ----------------------- fields in this struct
296 |     /// Damping parameter
297 |     gamma: f64,
    |     ^^^^^
298 |     /// Kraus operators
299 |     kraus: Vec<DMatrix<Complex64>>,
    |     ^^^^^
300 |     /// Steady state
301 |     steady_state: DMatrix<Complex64>,
    |     ^^^^^^^^^^^^
    |
    = note: `AmplitudeDampingChannel` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `lambda`, `kraus`, and `t2` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:307:5
    |
305 | struct PhaseDampingChannel {
    |        ------------------- fields in this struct
306 |     /// Dephasing rate
307 |     lambda: f64,
    |     ^^^^^^
308 |     /// Kraus operators
309 |     kraus: Vec<DMatrix<Complex64>>,
    |     ^^^^^
310 |     /// Decoherence time
311 |     t2: f64,
    |     ^^
    |
    = note: `PhaseDampingChannel` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `p_break`, `measurement_basis`, and `preparation_states` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:317:5
    |
315 | struct EntanglementBreakingChannel {
    |        --------------------------- fields in this struct
316 |     /// Breaking probability
317 |     p_break: f64,
    |     ^^^^^^^
318 |     /// Measurement basis
319 |     measurement_basis: DMatrix<Complex64>,
    |     ^^^^^^^^^^^^^^^^^
320 |     /// Preparation states
321 |     preparation_states: Vec<DMatrix<Complex64>>,
    |     ^^^^^^^^^^^^^^^^^^
    |
    = note: `EntanglementBreakingChannel` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `local_ops`, `comm_rounds`, and `success_prob` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:327:5
    |
325 | struct LOCCOperations {
    |        -------------- fields in this struct
326 |     /// Local operations
327 |     local_ops: Vec<LocalOperation>,
    |     ^^^^^^^^^
328 |     /// Classical communication rounds
329 |     comm_rounds: usize,
    |     ^^^^^^^^^^^
330 |     /// Success probability
331 |     success_prob: f64,
    |     ^^^^^^^^^^^^
    |
    = note: `LOCCOperations` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `party`, `operation`, and `probability` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:337:5
    |
335 | struct LocalOperation {
    |        -------------- fields in this struct
336 |     /// Party index
337 |     party: usize,
    |     ^^^^^
338 |     /// Operation
339 |     operation: DMatrix<Complex64>,
    |     ^^^^^^^^^
340 |     /// Probability
341 |     probability: f64,
    |     ^^^^^^^^^^^
    |
    = note: `LocalOperation` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `sudden_death`, `oscillations`, and `asymptotic` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:350:5
    |
346 | struct EntanglementDynamics {
    |        -------------------- fields in this struct
...
350 |     sudden_death: SuddenDeathBirth,
    |     ^^^^^^^^^^^^
351 |     /// Entanglement oscillations
352 |     oscillations: EntanglementOscillations,
    |     ^^^^^^^^^^^^
353 |     /// Asymptotic entanglement
354 |     asymptotic: AsymptoticEntanglement,
    |     ^^^^^^^^^^
    |
    = note: `EntanglementDynamics` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `H` is never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:360:5
    |
358 | struct TimeEvolution {
    |        ------------- field in this struct
359 |     /// Hamiltonian
360 |     H: DMatrix<Complex64>,
    |     ^
    |
    = note: `TimeEvolution` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `death_times`, `birth_times`, `dark_periods`, and `revival_amplitude` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:372:5
    |
370 | struct SuddenDeathBirth {
    |        ---------------- fields in this struct
371 |     /// Death times
372 |     death_times: Vec<f64>,
    |     ^^^^^^^^^^^
373 |     /// Birth times
374 |     birth_times: Vec<f64>,
    |     ^^^^^^^^^^^
375 |     /// Dark periods
376 |     dark_periods: Vec<(f64, f64)>,
    |     ^^^^^^^^^^^^
377 |     /// Revival amplitude
378 |     revival_amplitude: f64,
    |     ^^^^^^^^^^^^^^^^^
    |
    = note: `SuddenDeathBirth` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `frequency`, `amplitude`, `phase`, and `damping` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:384:5
    |
382 | struct EntanglementOscillations {
    |        ------------------------ fields in this struct
383 |     /// Oscillation frequency
384 |     frequency: f64,
    |     ^^^^^^^^^
385 |     /// Amplitude
386 |     amplitude: f64,
    |     ^^^^^^^^^
387 |     /// Phase
388 |     phase: f64,
    |     ^^^^^
389 |     /// Damping rate
390 |     damping: f64,
    |     ^^^^^^^
    |
    = note: `EntanglementOscillations` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `steady_state`, `convergence_rate`, and `equilibrium_time` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:396:5
    |
394 | struct AsymptoticEntanglement {
    |        ---------------------- fields in this struct
395 |     /// Steady state entanglement
396 |     steady_state: f64,
    |     ^^^^^^^^^^^^
397 |     /// Convergence rate
398 |     convergence_rate: f64,
    |     ^^^^^^^^^^^^^^^^
399 |     /// Equilibrium time
400 |     equilibrium_time: f64,
    |     ^^^^^^^^^^^^^^^^
    |
    = note: `AsymptoticEntanglement` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `ghz`, `w_state`, `cluster`, `graph`, and `gme` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:407:5
    |
405 | struct MultipartiteEntanglement {
    |        ------------------------ fields in this struct
406 |     /// GHZ state fidelity
407 |     ghz: GHZEntanglement,
    |     ^^^
408 |     /// W state entanglement
409 |     w_state: WStateEntanglement,
    |     ^^^^^^^
410 |     /// Cluster state entanglement
411 |     cluster: ClusterEntanglement,
    |     ^^^^^^^
412 |     /// Graph state entanglement
413 |     graph: GraphStateEntanglement,
    |     ^^^^^
414 |     /// Genuine multipartite entanglement
415 |     gme: GenuineMultipartiteEntanglement,
    |     ^^^
    |
    = note: `MultipartiteEntanglement` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `ghz_state`, `fidelity`, and `three_tangle` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:421:5
    |
419 | struct GHZEntanglement {
    |        --------------- fields in this struct
420 |     /// GHZ state
421 |     ghz_state: DMatrix<Complex64>,
    |     ^^^^^^^^^
422 |     /// Fidelity with ideal GHZ
423 |     fidelity: f64,
    |     ^^^^^^^^
424 |     /// Three-tangle
425 |     three_tangle: f64,
    |     ^^^^^^^^^^^^
    |
    = note: `GHZEntanglement` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `w_state`, `fidelity`, and `robustness` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:431:5
    |
429 | struct WStateEntanglement {
    |        ------------------ fields in this struct
430 |     /// W state
431 |     w_state: DMatrix<Complex64>,
    |     ^^^^^^^
432 |     /// Fidelity with ideal W
433 |     fidelity: f64,
    |     ^^^^^^^^
434 |     /// Robustness
435 |     robustness: f64,
    |     ^^^^^^^^^^
    |
    = note: `WStateEntanglement` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `cluster_state`, `stabilizers`, and `connectivity` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:441:5
    |
439 | struct ClusterEntanglement {
    |        ------------------- fields in this struct
440 |     /// Cluster state
441 |     cluster_state: DMatrix<Complex64>,
    |     ^^^^^^^^^^^^^
442 |     /// Stabilizers
443 |     stabilizers: Vec<DMatrix<Complex64>>,
    |     ^^^^^^^^^^^
444 |     /// Graph connectivity
445 |     connectivity: f64,
    |     ^^^^^^^^^^^^
    |
    = note: `ClusterEntanglement` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `adjacency`, `graph_state`, and `lc_equivalence` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:451:5
    |
449 | struct GraphStateEntanglement {
    |        ---------------------- fields in this struct
450 |     /// Graph adjacency matrix
451 |     adjacency: DMatrix<f64>,
    |     ^^^^^^^^^
452 |     /// Graph state
453 |     graph_state: DMatrix<Complex64>,
    |     ^^^^^^^^^^^
454 |     /// Local complementation equivalence
455 |     lc_equivalence: Vec<usize>,
    |     ^^^^^^^^^^^^^^
    |
    = note: `GraphStateEntanglement` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `gme_measure`, `biseparable`, and `k_separability` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:461:5
    |
459 | struct GenuineMultipartiteEntanglement {
    |        ------------------------------- fields in this struct
460 |     /// GME measure
461 |     gme_measure: f64,
    |     ^^^^^^^^^^^
462 |     /// Biseparability test
463 |     biseparable: bool,
    |     ^^^^^^^^^^^
464 |     /// k-separability
465 |     k_separability: usize,
    |     ^^^^^^^^^^^^^^
    |
    = note: `GenuineMultipartiteEntanglement` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `optimization_level` and `target_arch` are never read
  --> src/quantum_mlir/mod.rs:31:5
   |
27 | pub struct QuantumCompiler {
   |            --------------- fields in this struct
...
31 |     optimization_level: OptimizationLevel,
   |     ^^^^^^^^^^^^^^^^^^
32 |     /// Target GPU architecture
33 |     target_arch: GpuArchitecture,
   |     ^^^^^^^^^^^

warning: methods `build_mlir_module`, `optimize_module`, `lower_to_gpu`, and `generate_ptx` are never used
   --> src/quantum_mlir/mod.rs:127:8
    |
 66 | impl QuantumCompiler {
    | -------------------- methods in this implementation
...
127 |     fn build_mlir_module(&self, operations: &[QuantumOp]) -> Result<mlir::Module> {
    |        ^^^^^^^^^^^^^^^^^
...
156 |     fn optimize_module(&self, module: mlir::Module) -> Result<mlir::Module> {
    |        ^^^^^^^^^^^^^^^
...
193 |     fn lower_to_gpu(&self, module: mlir::Module) -> Result<mlir::Module> {
    |        ^^^^^^^^^^^^
...
200 |     fn generate_ptx(&self, module: mlir::Module) -> Result<String> {
    |        ^^^^^^^^^^^^

warning: field `high_precision` is never read
   --> src/quantum_mlir/mod.rs:283:5
    |
279 | pub struct CompiledQuantumKernel {
    |            --------------------- field in this struct
...
283 |     high_precision: bool,
    |     ^^^^^^^^^^^^^^

warning: methods `size`, `as_ptr`, and `as_mut_ptr` are never used
   --> src/quantum_mlir/mod.rs:345:8
    |
344 | impl QuantumState {
    | ----------------- methods in this implementation
345 |     fn size(&self) -> usize {
    |        ^^^^
...
349 |     fn as_ptr(&self) -> *const u8 {
    |        ^^^^^^
...
353 |     fn as_mut_ptr(&mut self) -> *mut u8 {
    |        ^^^^^^^^^^

warning: field `namespace` is never read
  --> src/quantum_mlir/dialect.rs:21:5
   |
19 | pub struct QuantumDialect {
   |            -------------- field in this struct
20 |     /// Dialect namespace
21 |     namespace: &'static str,
   |     ^^^^^^^^^

warning: fields `name`, `qubit`, and `target` are never read
  --> src/quantum_mlir/ops.rs:24:5
   |
23 | pub struct Operation {
   |            --------- fields in this struct
24 |     name: &'static str,
   |     ^^^^
25 |     qubit: usize,
   |     ^^^^^
26 |     target: Option<usize>,
   |     ^^^^^^

warning: field `target_arch` is never read
   --> src/quantum_mlir/passes.rs:136:5
    |
135 | pub struct LowerQuantumToGpu {
    |            ----------------- field in this struct
136 |     target_arch: super::GpuArchitecture,
    |     ^^^^^^^^^^^

warning: field `cuda_context` is never read
  --> src/gpu/gpu_enabled.rs:14:5
   |
13 | struct GpuState {
   |        -------- field in this struct
14 |     cuda_context: Option<Arc<CudaCompatContext>>,
   |     ^^^^^^^^^^^^

warning: fields `in_features` and `out_features` are never read
   --> src/gpu/gpu_enabled.rs:355:5
    |
352 | pub struct GpuLinear {
    |            --------- fields in this struct
...
355 |     in_features: usize,
    |     ^^^^^^^^^^^
356 |     out_features: usize,
    |     ^^^^^^^^^^^^

warning: method `convert_f16_to_f32_gpu` is never used
    --> src/gpu/kernel_executor.rs:3198:8
     |
1975 | impl GpuKernelExecutor {
     | ---------------------- method in this implementation
...
3198 |     fn convert_f16_to_f32_gpu(&self, data: &[u16]) -> Result<Vec<f32>> {
     |        ^^^^^^^^^^^^^^^^^^^^^^

warning: fields `size_bytes` and `timestamp_ns` are never read
   --> src/gpu/memory_pool.rs:154:5
    |
153 | struct AllocationRecord {
    |        ---------------- fields in this struct
154 |     size_bytes: usize,
    |     ^^^^^^^^^^
155 |     timestamp_ns: u64,
    |     ^^^^^^^^^^^^
    |
    = note: `AllocationRecord` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: fields `allocated_at` and `last_used` are never read
  --> src/gpu/active_memory_pool.rs:90:5
   |
87 | struct BufferMetadata {
   |        -------------- fields in this struct
...
90 |     allocated_at: u64,
   |     ^^^^^^^^^^^^
91 |     last_used: u64,
   |     ^^^^^^^^^
   |
   = note: `BufferMetadata` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `config` is never read
  --> src/gpu/kernel_autotuner.rs:44:5
   |
43 | struct ConfigPerformance {
   |        ----------------- field in this struct
44 |     config: LaunchConfig,
   |     ^^^^^^
   |
   = note: `ConfigPerformance` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: fields `context` and `device` are never read
   --> src/gpu/production_runtime.rs:137:5
    |
136 | pub struct ProductionGpuRuntime {
    |            -------------------- fields in this struct
137 |     context: usize,  // Store as usize for Send/Sync
    |     ^^^^^^^
138 |     device: i32,
    |     ^^^^^^

warning: function `cuDeviceGetCount` is never used
  --> src/gpu/production_runtime.rs:16:8
   |
16 |     fn cuDeviceGetCount(count: *mut i32) -> i32;
   |        ^^^^^^^^^^^^^^^^

warning: function `cuCtxSetCurrent` is never used
  --> src/gpu/production_runtime.rs:19:8
   |
19 |     fn cuCtxSetCurrent(ctx: *mut c_void) -> i32;
   |        ^^^^^^^^^^^^^^^

warning: function `cuMemcpyDtoD_v2` is never used
  --> src/gpu/production_runtime.rs:26:8
   |
26 |     fn cuMemcpyDtoD_v2(dst: u64, src: u64, bytesize: usize) -> i32;
   |        ^^^^^^^^^^^^^^^

warning: function `cuStreamCreate` is never used
  --> src/gpu/production_runtime.rs:46:8
   |
46 |     fn cuStreamCreate(stream: *mut *mut c_void, flags: u32) -> i32;
   |        ^^^^^^^^^^^^^^

warning: function `cuStreamSynchronize` is never used
  --> src/gpu/production_runtime.rs:47:8
   |
47 |     fn cuStreamSynchronize(stream: *mut c_void) -> i32;
   |        ^^^^^^^^^^^^^^^^^^^

warning: fields `device` and `max_simplices` are never read
   --> src/phase6/tda.rs:113:5
    |
110 | pub struct TdaAdapter {
    |            ---------- fields in this struct
...
113 |     device: Arc<()>,
    |     ^^^^^^
...
117 |     max_simplices: usize,
    |     ^^^^^^^^^^^^^

warning: field `max_dimension` is never read
   --> src/phase6/tda.rs:557:5
    |
554 | struct VietorisRipsComplex {
    |        ------------------- field in this struct
...
557 |     max_dimension: usize,
    |     ^^^^^^^^^^^^^

warning: fields `spectral_radius`, `generative_model`, and `prediction_history` are never read
   --> src/phase6/predictive_neuro.rs:87:5
    |
 83 | pub struct PredictiveNeuromorphic {
    |            ---------------------- fields in this struct
...
 87 |     spectral_radius: f64,
    |     ^^^^^^^^^^^^^^^
...
101 |     generative_model: GenerativeModel,
    |     ^^^^^^^^^^^^^^^^
...
105 |     prediction_history: Vec<Array1<f64>>,
    |     ^^^^^^^^^^^^^^^^^^

warning: field `gnn` is never read
   --> src/phase6/meta_learning.rs:126:5
    |
121 | pub struct MetaLearningCoordinator {
    |            ----------------------- field in this struct
...
126 |     gnn: Arc<RwLock<E3EquivariantGNN>>,
    |     ^^^

warning: fields `active_inference` and `health_monitor` are never read
  --> src/phase6/integration.rs:28:5
   |
23 | pub struct Phase6Integration {
   |            ----------------- fields in this struct
...
28 |     active_inference: Arc<RwLock<HierarchicalModel>>,
   |     ^^^^^^^^^^^^^^^^
...
37 |     health_monitor: Arc<RwLock<HealthMonitor>>,
   |     ^^^^^^^^^^^^^^

warning: field `free_energy` is never read
   --> src/phase6/integration.rs:415:5
    |
413 | struct InferenceResult {
    |        --------------- field in this struct
414 |     state: Array1<f64>,
415 |     free_energy: f64,
    |     ^^^^^^^^^^^

warning: field `energy` is never read
   --> src/phase6/integration.rs:420:5
    |
418 | struct ThermoResult {
    |        ------------ field in this struct
419 |     state: Array1<f64>,
420 |     energy: f64,
    |     ^^^^^^

warning: field `max_dimension` is never read
  --> src/phase6/gpu_tda.rs:16:5
   |
13 | pub struct GpuTDA {
   |            ------ field in this struct
...
16 |     max_dimension: usize,
   |     ^^^^^^^^^^^^^

warning: fields `transfer_entropy` and `active_inference` are never read
  --> src/cma/mod.rs:56:5
   |
39 | pub struct CausalManifoldAnnealing {
   |            ----------------------- fields in this struct
...
56 |     transfer_entropy: Arc<crate::information_theory::transfer_entropy::TransferEntropy>,
   |     ^^^^^^^^^^^^^^^^
57 |     active_inference: Arc<crate::active_inference::ActiveInferenceController>,
   |     ^^^^^^^^^^^^^^^^

warning: field `ksg_neighbors` is never read
  --> src/cma/causal_discovery.rs:20:5
   |
18 | pub struct CausalManifoldDiscovery {
   |            ----------------------- field in this struct
19 |     fdr_threshold: f64,
20 |     ksg_neighbors: usize,
   |     ^^^^^^^^^^^^^

warning: multiple methods are never used
   --> src/cma/causal_discovery.rs:121:8
    |
 28 | impl CausalManifoldDiscovery {
    | ---------------------------- methods in this implementation
...
121 |     fn ksg_transfer_entropy(&self, source: &[f64], target: &[f64]) -> (f64, f64) {
    |        ^^^^^^^^^^^^^^^^^^^^
...
285 |     fn compute_distance(
    |        ^^^^^^^^^^^^^^^^
...
304 |     fn count_neighbors_marginal(
    |        ^^^^^^^^^^^^^^^^^^^^^^^^
...
328 |     fn count_neighbors_joint(
    |        ^^^^^^^^^^^^^^^^^^^^^
...
353 |     fn count_neighbors_marginal_past(
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
376 |     fn digamma(&self, x: f64) -> f64 {
    |        ^^^^^^^
...
385 |     fn bootstrap_p_value(&self, source: &[f64], target: &[f64], observed_te: f64) -> f64 {
    |        ^^^^^^^^^^^^^^^^^

warning: fields `initial_temp` and `final_temp` are never read
  --> src/cma/quantum_annealer.rs:19:5
   |
17 | pub struct GeometricQuantumAnnealer {
   |            ------------------------ fields in this struct
18 |     n_steps: usize,
19 |     initial_temp: f64,
   |     ^^^^^^^^^^^^
20 |     final_temp: f64,
   |     ^^^^^^^^^^

warning: field `dimension` is never read
   --> src/cma/quantum_annealer.rs:479:5
    |
477 | struct QuantumState {
    |        ------------ field in this struct
478 |     amplitudes: Vec<Complex64>,
479 |     dimension: usize,
    |     ^^^^^^^^^

warning: field `manifold_penalty` is never read
   --> src/cma/quantum_annealer.rs:486:5
    |
483 | struct QuantumHamiltonian {
    |        ------------------ field in this struct
...
486 |     manifold_penalty: f64,
    |     ^^^^^^^^^^^^^^^^

warning: field `device` is never read
  --> src/cma/neural/mod.rs:75:5
   |
73 | pub struct GeometricManifoldLearner {
   |            ------------------------ field in this struct
74 |     gnn: E3EquivariantGNN,
75 |     device: Device,
   |     ^^^^^^

warning: field `solution_dim` is never read
   --> src/cma/neural/mod.rs:155:5
    |
153 | pub struct DiffusionRefinement {
    |            ------------------- field in this struct
154 |     diffusion: ConsistencyDiffusion,
155 |     solution_dim: usize,
    |     ^^^^^^^^^^^^

warning: field `solution_dim` is never read
   --> src/cma/neural/mod.rs:206:5
    |
204 | pub struct NeuralQuantumState {
    |            ------------------ field in this struct
205 |     vmc: VariationalMonteCarlo,
206 |     solution_dim: usize,
    |     ^^^^^^^^^^^^

warning: fields `device`, `embed_dim`, and `num_heads` are never read
   --> src/cma/neural/mod.rs:254:5
    |
253 | pub struct MetaOptimizationTransformer {
    |            --------------------------- fields in this struct
254 |     device: Device,
    |     ^^^^^^
255 |     embed_dim: usize,
    |     ^^^^^^^^^
256 |     num_heads: usize,
    |     ^^^^^^^^^

warning: fields `device`, `node_dim`, `edge_dim`, `hidden_dim`, and `num_layers` are never read
  --> src/cma/neural/gnn_integration.rs:14:5
   |
13 | pub struct E3EquivariantGNN {
   |            ---------------- fields in this struct
14 |     device: Device,
   |     ^^^^^^
15 |     node_dim: usize,
   |     ^^^^^^^^
16 |     edge_dim: usize,
   |     ^^^^^^^^
17 |     hidden_dim: usize,
   |     ^^^^^^^^^^
18 |     num_layers: usize,
   |     ^^^^^^^^^^

warning: fields `solution_dim`, `hidden_dim`, `num_steps`, and `device` are never read
  --> src/cma/neural/diffusion.rs:13:5
   |
12 | pub struct ConsistencyDiffusion {
   |            -------------------- fields in this struct
13 |     solution_dim: usize,
   |     ^^^^^^^^^^^^
14 |     hidden_dim: usize,
   |     ^^^^^^^^^^
15 |     num_steps: usize,
   |     ^^^^^^^^^
16 |     device: Device,
   |     ^^^^^^

warning: field `normalized_shape` is never read
   --> src/cma/neural/neural_quantum.rs:138:5
    |
137 | pub struct LayerNorm {
    |            --------- field in this struct
138 |     normalized_shape: usize,
    |     ^^^^^^^^^^^^^^^^

warning: fields `device`, `hidden_dim`, and `num_layers` are never read
   --> src/cma/neural/neural_quantum.rs:161:5
    |
159 | pub struct NeuralQuantumState {
    |            ------------------ fields in this struct
160 |     network: ResNet,
161 |     device: Device,
    |     ^^^^^^
162 |     hidden_dim: usize,
    |     ^^^^^^^^^^
163 |     num_layers: usize,
    |     ^^^^^^^^^^

warning: fields `input_dim`, `hidden_dim`, `num_layers`, and `device` are never read
   --> src/cma/neural/neural_quantum.rs:370:5
    |
369 | pub struct ResNet {
    |            ------ fields in this struct
370 |     input_dim: usize,
    |     ^^^^^^^^^
371 |     hidden_dim: usize,
    |     ^^^^^^^^^^
372 |     num_layers: usize,
    |     ^^^^^^^^^^
373 |     device: Device,
    |     ^^^^^^

warning: fields `hidden_dim` and `device` are never read
   --> src/cma/neural/neural_quantum.rs:438:5
    |
437 | struct ResidualLayer {
    |        ------------- fields in this struct
438 |     hidden_dim: usize,
    |     ^^^^^^^^^^
439 |     device: Device,
    |     ^^^^^^

warning: field `num_iterations` is never read
   --> src/cma/neural/neural_quantum.rs:484:5
    |
481 | pub struct VariationalMonteCarlo {
    |            --------------------- field in this struct
...
484 |     num_iterations: usize,
    |     ^^^^^^^^^^^^^^

warning: fields `optimizer` and `device` are never read
   --> src/cma/neural/gnn_training.rs:665:5
    |
663 | pub struct GNNTrainer {
    |            ---------- fields in this struct
664 |     model: E3EquivariantGNN,
665 |     optimizer: Optimizer,
    |     ^^^^^^^^^
...
669 |     device: Device,
    |     ^^^^^^

warning: field `device` is never read
   --> src/cma/neural/gnn_training.rs:922:5
    |
920 | pub struct GpuBatchGNNTrainer {
    |            ------------------ field in this struct
921 |     trainers: Vec<GNNTrainer>,
922 |     device: Device,
    |     ^^^^^^

warning: fields `teacher` and `device` are never read
   --> src/cma/neural/gnn_transfer_learning.rs:686:5
    |
685 | pub struct KnowledgeDistiller {
    |            ------------------ fields in this struct
686 |     teacher: E3EquivariantGNN,
    |     ^^^^^^^
687 |     config: DistillationConfig,
688 |     device: Device,
    |     ^^^^^^

warning: method `distillation_loss` is never used
   --> src/cma/neural/gnn_transfer_learning.rs:730:8
    |
691 | impl KnowledgeDistiller {
    | ----------------------- method in this implementation
...
730 |     fn distillation_loss(
    |        ^^^^^^^^^^^^^^^^^

warning: field `augmenter` is never read
   --> src/cma/neural/gnn_training_pipeline.rs:614:5
    |
612 | pub struct GNNTrainingPipeline {
    |            ------------------- field in this struct
613 |     preprocessor: DataPreprocessor,
614 |     augmenter: Option<DataAugmenter>,
    |     ^^^^^^^^^

warning: methods `estimate_kl_divergence`, `non_conformity_score`, and `verify_proof_internal` are never used
   --> src/cma/guarantees/mod.rs:198:8
    |
 36 | impl PrecisionFramework {
    | ----------------------- methods in this implementation
...
198 |     fn estimate_kl_divergence(&self, solution: &super::Solution, ensemble: &super::Ensemble) -> f64 {
    |        ^^^^^^^^^^^^^^^^^^^^^^
...
244 |     fn non_conformity_score(&self, solution: &super::Solution, calibration: &CalibrationPoint) -> f64 {
    |        ^^^^^^^^^^^^^^^^^^^^
...
270 |     fn verify_proof_internal(&self, _commitment: &str, _proof: &str) -> bool {
    |        ^^^^^^^^^^^^^^^^^^^^^

warning: fields `empirical_risk`, `kl_divergence`, and `sample_size` are never read
   --> src/cma/guarantees/mod.rs:290:5
    |
289 | struct PacBayesBound {
    |        ------------- fields in this struct
290 |     empirical_risk: f64,
    |     ^^^^^^^^^^^^^^
291 |     kl_divergence: f64,
    |     ^^^^^^^^^^^^^
292 |     error_bound: f64,
293 |     sample_size: usize,
    |     ^^^^^^^^^^^
    |
    = note: `PacBayesBound` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `recent_scores` is never read
   --> src/cma/guarantees/conformal.rs:340:5
    |
337 | pub struct AdaptiveConformalPredictor {
    |            -------------------------- field in this struct
...
340 |     recent_scores: std::collections::VecDeque<f64>,
    |     ^^^^^^^^^^^^^

warning: field `security_parameter` is never read
  --> src/cma/guarantees/zkp.rs:17:5
   |
16 | pub struct ZKProofSystem {
   |            ------------- field in this struct
17 |     security_parameter: usize, // Bits of security (e.g., 256)
   |     ^^^^^^^^^^^^^^^^^^

warning: fields `rmsd_threshold`, `binding_affinity_cutoff`, and `folding_temperature` are never read
   --> src/cma/applications/mod.rs:103:5
    |
102 | pub struct BiomolecularAdapter {
    |            ------------------- fields in this struct
103 |     rmsd_threshold: f64,
    |     ^^^^^^^^^^^^^^
104 |     binding_affinity_cutoff: f64,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
105 |     folding_temperature: f64,
    |     ^^^^^^^^^^^^^^^^^^^

warning: fields `property_r2_threshold`, `synthesis_confidence_min`, and `stability_window_ev` are never read
   --> src/cma/applications/mod.rs:253:5
    |
252 | pub struct MaterialsAdapter {
    |            ---------------- fields in this struct
253 |     property_r2_threshold: f64,
    |     ^^^^^^^^^^^^^^^^^^^^^
254 |     synthesis_confidence_min: f64,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^
255 |     stability_window_ev: f64,
    |     ^^^^^^^^^^^^^^^^^^^

warning: fields `solver_pool` and `pool_size` are never read
  --> src/cma/gpu_integration.rs:46:5
   |
44 | pub struct GpuTspBridge {
   |            ------------ fields in this struct
45 |     /// Pre-allocated solvers for batch processing
46 |     solver_pool: Vec<Arc<parking_lot::Mutex<GpuTspSolver>>>,
   |     ^^^^^^^^^^^
47 |     /// Number of parallel solvers
48 |     pool_size: usize,
   |     ^^^^^^^^^

warning: fields `namespace` and `control_frequency` are never read
  --> src/applications/robotics/ros_bridge.rs:91:5
   |
89 | pub struct RosInterface {
   |            ------------ fields in this struct
90 |     /// Robot namespace
91 |     namespace: String,
   |     ^^^^^^^^^
92 |     /// Control frequency (Hz)
93 |     control_frequency: f64,
   |     ^^^^^^^^^^^^^^^^^

warning: field `config` is never read
  --> src/applications/scientific/mod.rs:40:5
   |
39 | pub struct ScientificDiscovery {
   |            ------------------- field in this struct
40 |     config: ScientificConfig,
   |     ^^^^^^

warning: field `n_candidates` is never read
  --> src/applications/scientific/experiment_design.rs:30:5
   |
28 | pub struct ExperimentDesigner {
   |            ------------------ field in this struct
29 |     /// Number of candidate experiments to evaluate
30 |     n_candidates: usize,
   |     ^^^^^^^^^^^^

warning: field `config` is never read
  --> src/applications/scientific/parameter_optimization.rs:27:5
   |
26 | pub struct ParameterOptimizer {
   |            ------------------ field in this struct
27 |     config: OptimizationConfig,
   |     ^^^^^^

warning: field `confidence_level` is never read
  --> src/applications/scientific/hypothesis_testing.rs:25:5
   |
24 | pub struct HypothesisTester {
   |            ---------------- field in this struct
25 |     confidence_level: f64,
   |     ^^^^^^^^^^^^^^^^

warning: field `device` is never read
  --> src/chemistry/gpu_docking.rs:11:5
   |
10 | pub struct GpuMolecularDocker {
   |            ------------------ field in this struct
11 |     device: Arc<CudaContext>,
   |     ^^^^^^

warning: field `refine_solution` is never read
  --> src/time_series/arima_gpu.rs:62:5
   |
46 | pub struct ArimaGpu {
   |            -------- field in this struct
...
62 |     refine_solution: bool,
   |     ^^^^^^^^^^^^^^^

warning: method `solve_via_qr` is never used
   --> src/time_series/arima_gpu.rs:464:8
    |
 65 | impl ArimaGpu {
    | ------------- method in this implementation
...
464 |     fn solve_via_qr(&self, a_flat: &[f64], b: &[f64], n: usize) -> Result<Vec<f64>> {
    |        ^^^^^^^^^^^^

warning: fields `last_hidden_states` and `last_cell_states` are never read
  --> src/time_series/lstm_forecaster.rs:81:5
   |
70 | pub struct LstmForecaster {
   |            -------------- fields in this struct
...
81 |     last_hidden_states: Option<Vec<Array1<f64>>>,
   |     ^^^^^^^^^^^^^^^^^^
82 |     last_cell_states: Option<Vec<Array1<f64>>>,
   |     ^^^^^^^^^^^^^^^^

warning: field `gpu_available` is never read
  --> src/time_series/kalman_filter.rs:72:5
   |
56 | pub struct KalmanFilter {
   |            ------------ field in this struct
...
72 |     gpu_available: bool,
   |     ^^^^^^^^^^^^^

warning: fields `ar_coefficients` and `state_buffer` are never read
   --> src/time_series/kalman_filter.rs:389:5
    |
385 | pub struct ArimaKalmanFusion {
    |            ----------------- fields in this struct
...
389 |     ar_coefficients: Vec<f64>,
    |     ^^^^^^^^^^^^^^^
390 |     /// State buffer for AR(p) model
391 |     state_buffer: Vec<f64>,
    |     ^^^^^^^^^^^^

warning: field `workspace` is never read
  --> src/time_series/optimizations.rs:30:5
   |
22 | pub struct OptimizedGruCell {
   |            ---------------- field in this struct
...
30 |     workspace: Vec<f64>,
   |     ^^^^^^^^^

warning: field `config` is never read
   --> src/time_series/optimizations.rs:139:5
    |
135 | struct CachedArimaModel {
    |        ---------------- field in this struct
...
139 |     config: ArimaConfig,
    |     ^^^^^^
    |
    = note: `CachedArimaModel` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: field `num_threads` is never read
   --> src/time_series/optimizations.rs:258:5
    |
254 | pub struct BatchForecaster {
    |            --------------- field in this struct
...
258 |     num_threads: usize,
    |     ^^^^^^^^^^^

warning: field `gpu_available` is never read
  --> src/time_series/arima_gpu_optimized.rs:34:5
   |
20 | pub struct ArimaGpuOptimized {
   |            ----------------- field in this struct
...
34 |     gpu_available: bool,
   |     ^^^^^^^^^^^^^

warning: field `gpu_available` is never read
  --> src/time_series/lstm_gpu_optimized.rs:31:5
   |
22 | pub struct LstmGpuOptimized {
   |            ---------------- field in this struct
...
31 |     gpu_available: bool,
   |     ^^^^^^^^^^^^^

warning: field `num_gates` is never read
  --> src/time_series/lstm_gpu_optimized.rs:45:5
   |
35 | struct GpuWeightSet {
   |        ------------ field in this struct
...
45 |     num_gates: usize,
   |     ^^^^^^^^^

warning: field `gpu_available` is never read
  --> src/time_series/uncertainty_gpu_optimized.rs:23:5
   |
17 | pub struct UncertaintyGpuOptimized {
   |            ----------------------- field in this struct
...
23 |     gpu_available: bool,
   |     ^^^^^^^^^^^^^

warning: field `gpu_pool` is never read
   --> src/finance/portfolio_optimizer.rs:103:5
    |
101 | pub struct PortfolioOptimizer {
    |            ------------------ field in this struct
102 |     /// GPU memory pool for covariance computation
103 |     gpu_pool: GpuMemoryPool,
    |     ^^^^^^^^

warning: method `remove_last` is never used
   --> src/api_server/rate_limit.rs:358:8
    |
325 | impl SlidingWindow {
    | ------------------ method in this implementation
...
358 |     fn remove_last(&mut self) {
    |        ^^^^^^^^^^^

warning: field `safety_mode` is never read
  --> src/assistant/autonomous_agent.rs:35:5
   |
33 | pub struct AutonomousAgent {
   |            --------------- field in this struct
34 |     /// Safety mode - controls execution permissions
35 |     safety_mode: SafetyMode,
   |     ^^^^^^^^^^^

warning: fields `wq`, `wk`, `wv`, and `wo` are never read
  --> src/assistant/local_llm/gpu_transformer.rs:22:5
   |
17 | pub struct GpuTransformerLayer {
   |            ------------------- fields in this struct
...
22 |     wq: CudaSlice<f32>,  // Query projection weights
   |     ^^
23 |     wk: CudaSlice<f32>,  // Key projection weights
   |     ^^
24 |     wv: CudaSlice<f32>,  // Value projection weights
   |     ^^
25 |     wo: CudaSlice<f32>,  // Output projection weights
   |     ^^

warning: fields `metrics`, `attention_analyzer`, `transfer_entropy`, and `n_heads` are never read
   --> src/assistant/local_llm/gpu_transformer.rs:416:5
    |
396 | pub struct GpuLLMInference {
    |            --------------- fields in this struct
...
416 |     metrics: Option<LLMMetrics>,
    |     ^^^^^^^
417 |     attention_analyzer: Option<AttentionAnalyzer>,
    |     ^^^^^^^^^^^^^^^^^^
418 |     transfer_entropy: Option<TransferEntropyLLM>,
    |     ^^^^^^^^^^^^^^^^
...
424 |     n_heads: usize,
    |     ^^^^^^^

warning: field `alignment` is never read
   --> src/assistant/local_llm/gguf_loader.rs:199:5
    |
185 | pub struct GgufLoader {
    |            ---------- field in this struct
...
199 |     alignment: u64,
    |     ^^^^^^^^^

warning: method `Quantum` should have a snake case name
  --> src/integration/cross_domain_bridge.rs:56:12
   |
56 |     pub fn Quantum(data: Vec<f64>) -> Self {
   |            ^^^^^^^ help: convert the identifier to snake case: `quantum`
   |
   = note: `#[warn(non_snake_case)]` on by default

warning: method `Neuromorphic` should have a snake case name
  --> src/integration/cross_domain_bridge.rs:67:12
   |
67 |     pub fn Neuromorphic(data: Vec<f64>) -> Self {
   |            ^^^^^^^^^^^^ help: convert the identifier to snake case: `neuromorphic`

warning: structure field `F` should have a snake case name
   --> src/orchestration/optimization/geometric_manifold.rs:220:5
    |
220 |     F: DMatrix<f64>,
    |     ^ help: convert the identifier to snake case (notice the capitalization): `f`

warning: structure field `F_diag` should have a snake case name
   --> src/orchestration/optimization/geometric_manifold.rs:222:5
    |
222 |     F_diag: DVector<f64>,
    |     ^^^^^^ help: convert the identifier to snake case (notice the capitalization): `f_diag`

warning: structure field `A` should have a snake case name
   --> src/orchestration/optimization/geometric_manifold.rs:224:5
    |
224 |     A: Option<DMatrix<f64>>,
    |     ^ help: convert the identifier to snake case: `a`

warning: structure field `G` should have a snake case name
   --> src/orchestration/optimization/geometric_manifold.rs:225:5
    |
225 |     G: Option<DMatrix<f64>>,
    |     ^ help: convert the identifier to snake case: `g`

warning: variable `F` should have a snake case name
   --> src/orchestration/optimization/geometric_manifold.rs:899:13
    |
899 |         let F = &self.natural_gradient.fisher.F;
    |             ^ help: convert the identifier to snake case (notice the capitalization): `f`

warning: variable `F_reg` should have a snake case name
   --> src/orchestration/optimization/geometric_manifold.rs:900:13
    |
900 |         let F_reg = F + DMatrix::identity(F.nrows(), F.ncols()) * self.natural_gradient.damping;
    |             ^^^^^ help: convert the identifier to snake case (notice the capitalization): `f_reg`

warning: variable `F_inv` should have a snake case name
   --> src/orchestration/optimization/geometric_manifold.rs:902:21
    |
902 |         if let Some(F_inv) = F_reg.try_inverse() {
    |                     ^^^^^ help: convert the identifier to snake case (notice the capitalization): `f_inv`

warning: variable `F` should have a snake case name
   --> src/orchestration/optimization/geometric_manifold.rs:989:21
    |
989 |             let mut F = DMatrix::zeros(x.len(), x.len());
    |                     ^ help: convert the identifier to snake case (notice the capitalization): `f`

warning: structure field `I` should have a snake case name
  --> src/orchestration/neuromorphic/unified_neuromorphic.rs:63:5
   |
63 |     I: f64,
   |     ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: structure field `F` should have a snake case name
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:114:5
    |
114 |     F: f64,
    |     ^ help: convert the identifier to snake case (notice the capitalization): `f`

warning: structure field `D` should have a snake case name
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:116:5
    |
116 |     D: f64,
    |     ^ help: convert the identifier to snake case: `d`

warning: structure field `tau_F` should have a snake case name
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:118:5
    |
118 |     tau_F: f64,
    |     ^^^^^ help: convert the identifier to snake case (notice the capitalization): `tau_f`

warning: structure field `tau_D` should have a snake case name
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:119:5
    |
119 |     tau_D: f64,
    |     ^^^^^ help: convert the identifier to snake case: `tau_d`

warning: structure field `A_plus` should have a snake case name
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:147:5
    |
147 |     A_plus: f64,     // LTP amplitude
    |     ^^^^^^ help: convert the identifier to snake case: `a_plus`

warning: structure field `A_minus` should have a snake case name
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:148:5
    |
148 |     A_minus: f64,    // LTD amplitude
    |     ^^^^^^^ help: convert the identifier to snake case: `a_minus`

warning: structure field `A` should have a snake case name
  --> src/orchestration/inference/hierarchical_active_inference.rs:40:5
   |
40 |     A: DMatrix<f64>,             // Observation model
   |     ^ help: convert the identifier to snake case: `a`

warning: structure field `B` should have a snake case name
  --> src/orchestration/inference/hierarchical_active_inference.rs:41:5
   |
41 |     B: DMatrix<f64>,             // Transition model
   |     ^ help: convert the identifier to snake case: `b`

warning: structure field `C` should have a snake case name
  --> src/orchestration/inference/hierarchical_active_inference.rs:42:5
   |
42 |     C: DVector<f64>,             // Observation bias
   |     ^ help: convert the identifier to snake case (notice the capitalization): `c`

warning: structure field `D` should have a snake case name
  --> src/orchestration/inference/hierarchical_active_inference.rs:43:5
   |
43 |     D: DVector<f64>,             // Prior over initial states
   |     ^ help: convert the identifier to snake case: `d`

warning: structure field `F` should have a snake case name
  --> src/orchestration/inference/hierarchical_active_inference.rs:69:5
   |
69 |     F: f64,
   |     ^ help: convert the identifier to snake case (notice the capitalization): `f`

warning: structure field `G` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:114:5
    |
114 |     G: Vec<f64>,
    |     ^ help: convert the identifier to snake case: `g`

warning: variable `grad_F` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:443:13
    |
443 |         let grad_F = self.compute_free_energy_gradient(level_idx, &bottom_up_error)?;
    |             ^^^^^^ help: convert the identifier to snake case (notice the capitalization): `grad_f`

warning: variable `total_F` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:520:17
    |
520 |         let mut total_F = 0.0;
    |                 ^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `total_f`

warning: variable `G` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:569:17
    |
569 |             let G = self.evaluate_expected_free_energy(policy)?;
    |                 ^ help: convert the identifier to snake case: `g`

warning: variable `min_G` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:574:13
    |
574 |         let min_G = self.action_selection.G.iter().fold(f64::INFINITY, |a, &b| a.min(b));
    |             ^^^^^ help: convert the identifier to snake case: `min_g`

warning: variable `exp_neg_G` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:575:13
    |
575 |         let exp_neg_G: Vec<f64> = self.action_selection.G.iter()
    |             ^^^^^^^^^ help: convert the identifier to snake case: `exp_neg_g`

warning: variable `G` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:626:17
    |
626 |         let mut G = 0.0;
    |                 ^ help: convert the identifier to snake case: `g`

warning: variable `A_clone` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:707:17
    |
707 |             let A_clone = self.levels[level_idx].A.clone();
    |                 ^^^^^^^ help: convert the identifier to snake case: `a_clone`

warning: variable `B_clone` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:708:17
    |
708 |             let B_clone = self.levels[level_idx].B.clone();
    |                 ^^^^^^^ help: convert the identifier to snake case: `b_clone`

warning: variable `D_clone` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:709:17
    |
709 |             let D_clone = self.levels[level_idx].D.clone();
    |                 ^^^^^^^ help: convert the identifier to snake case: `d_clone`

warning: variable `dA` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:714:21
    |
714 |                 let dA = prediction_error * mu_clone.transpose() * learning_rate;
    |                     ^^ help: convert the identifier to snake case: `d_a`

warning: variable `dB` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:722:21
    |
722 |                 let dB = transition_error * mu_clone.transpose() * learning_rate;
    |                     ^^ help: convert the identifier to snake case: `d_b`

warning: variable `B_to_normalize` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:726:25
    |
726 |                 let mut B_to_normalize = self.levels[level_idx].B.clone();
    |                         ^^^^^^^^^^^^^^ help: convert the identifier to snake case: `b_to_normalize`

warning: variable `B` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:742:43
    |
742 |     fn normalize_transition_matrix(&self, B: &mut DMatrix<f64>) {
    |                                           ^ help: convert the identifier to snake case: `b`

warning: structure field `A` should have a snake case name
  --> src/orchestration/inference/joint_active_inference.rs:55:5
   |
55 |     A: DMatrix<f64>,
   |     ^ help: convert the identifier to snake case: `a`

warning: structure field `B` should have a snake case name
  --> src/orchestration/inference/joint_active_inference.rs:57:5
   |
57 |     B: DMatrix<f64>,
   |     ^ help: convert the identifier to snake case: `b`

warning: structure field `C` should have a snake case name
  --> src/orchestration/inference/joint_active_inference.rs:59:5
   |
59 |     C: DVector<f64>,
   |     ^ help: convert the identifier to snake case (notice the capitalization): `c`

warning: structure field `D` should have a snake case name
  --> src/orchestration/inference/joint_active_inference.rs:61:5
   |
61 |     D: DVector<f64>,
   |     ^ help: convert the identifier to snake case: `d`

warning: structure field `F` should have a snake case name
  --> src/orchestration/inference/joint_active_inference.rs:76:5
   |
76 |     F: f64,
   |     ^ help: convert the identifier to snake case (notice the capitalization): `f`

warning: structure field `G` should have a snake case name
  --> src/orchestration/inference/joint_active_inference.rs:78:5
   |
78 |     G: f64,
   |     ^ help: convert the identifier to snake case: `g`

warning: structure field `T` should have a snake case name
   --> src/orchestration/inference/joint_active_inference.rs:173:5
    |
173 |     T: DMatrix<f64>,
    |     ^ help: convert the identifier to snake case: `t`

warning: structure field `I` should have a snake case name
   --> src/orchestration/inference/joint_active_inference.rs:175:5
    |
175 |     I: DMatrix<f64>,
    |     ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: structure field `J` should have a snake case name
   --> src/orchestration/inference/joint_active_inference.rs:185:5
    |
185 |     J: DMatrix<f64>,
    |     ^ help: convert the identifier to snake case: `j`

warning: structure field `W` should have a snake case name
   --> src/orchestration/inference/joint_active_inference.rs:216:5
    |
216 |     W: DMatrix<f64>,
    |     ^ help: convert the identifier to snake case (notice the capitalization): `w`

warning: structure field `collective_F` should have a snake case name
   --> src/orchestration/inference/joint_active_inference.rs:349:5
    |
349 |     collective_F: f64,
    |     ^^^^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `collective_f`

warning: variable `E` should have a snake case name
   --> src/orchestration/causality/bidirectional_causality.rs:420:13
    |
420 |         let E = self.ccm_engine.embedding_dim;
    |             ^ help: convert the identifier to snake case: `e`

warning: variable `X_restricted` should have a snake case name
   --> src/orchestration/causality/bidirectional_causality.rs:786:17
    |
786 |         let mut X_restricted = DMatrix::zeros(n_samples, max_lag);
    |                 ^^^^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `x_restricted`

warning: variable `X_unrestricted` should have a snake case name
   --> src/orchestration/causality/bidirectional_causality.rs:797:17
    |
797 |         let mut X_unrestricted = DMatrix::zeros(n_samples, max_lag * 2);
    |                 ^^^^^^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `x_unrestricted`

warning: variable `X` should have a snake case name
   --> src/orchestration/causality/bidirectional_causality.rs:881:27
    |
881 |     fn compute_rss(&self, X: &DMatrix<f64>, y: &DVector<f64>) -> Result<f64, OrchestrationError> {
    |                           ^ help: convert the identifier to snake case (notice the capitalization): `x`

warning: variable `XtX` should have a snake case name
   --> src/orchestration/causality/bidirectional_causality.rs:883:13
    |
883 |         let XtX = X.transpose() * X;
    |             ^^^ help: convert the identifier to snake case: `xt_x`

warning: variable `Xty` should have a snake case name
   --> src/orchestration/causality/bidirectional_causality.rs:884:13
    |
884 |         let Xty = X.transpose() * y;
    |             ^^^ help: convert the identifier to snake case (notice the capitalization): `xty`

warning: variable `XtX_inv` should have a snake case name
   --> src/orchestration/causality/bidirectional_causality.rs:886:21
    |
886 |         if let Some(XtX_inv) = XtX.try_inverse() {
    |                     ^^^^^^^ help: convert the identifier to snake case: `xt_x_inv`

warning: variable `Z` should have a snake case name
    --> src/orchestration/causality/bidirectional_causality.rs:1070:17
     |
1070 |         let mut Z = DMatrix::zeros(n, k);
     |                 ^ help: convert the identifier to snake case (notice the capitalization): `z`

warning: variable `X` should have a snake case name
    --> src/orchestration/causality/bidirectional_causality.rs:1089:51
     |
1089 |     fn compute_residuals(&self, y: &DVector<f64>, X: &DMatrix<f64>) -> Result<DVector<f64>, OrchestrationError> {
     |                                                   ^ help: convert the identifier to snake case (notice the capitalization): `x`

warning: variable `XtX` should have a snake case name
    --> src/orchestration/causality/bidirectional_causality.rs:1090:13
     |
1090 |         let XtX = X.transpose() * X;
     |             ^^^ help: convert the identifier to snake case: `xt_x`

warning: variable `XtX_inv` should have a snake case name
    --> src/orchestration/causality/bidirectional_causality.rs:1091:21
     |
1091 |         if let Some(XtX_inv) = XtX.try_inverse() {
     |                     ^^^^^^^ help: convert the identifier to snake case: `xt_x_inv`

warning: variable `K_x` should have a snake case name
    --> src/orchestration/causality/bidirectional_causality.rs:1105:17
     |
1105 |         let mut K_x = DMatrix::zeros(n, n);
     |                 ^^^ help: convert the identifier to snake case (notice the capitalization): `k_x`

warning: variable `K_y` should have a snake case name
    --> src/orchestration/causality/bidirectional_causality.rs:1106:17
     |
1106 |         let mut K_y = DMatrix::zeros(n, n);
     |                 ^^^ help: convert the identifier to snake case (notice the capitalization): `k_y`

warning: variable `H` should have a snake case name
    --> src/orchestration/causality/bidirectional_causality.rs:1116:13
     |
1116 |         let H = DMatrix::identity(n, n) - DMatrix::from_element(n, n, 1.0 / n as f64);
     |             ^ help: convert the identifier to snake case: `h`

warning: variable `K_x_centered` should have a snake case name
    --> src/orchestration/causality/bidirectional_causality.rs:1117:13
     |
1117 |         let K_x_centered = &H * &K_x * &H;
     |             ^^^^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `k_x_centered`

warning: variable `K_y_centered` should have a snake case name
    --> src/orchestration/causality/bidirectional_causality.rs:1118:13
     |
1118 |         let K_y_centered = &H * &K_y * &H;
     |             ^^^^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `k_y_centered`

warning: structure field `W` should have a snake case name
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:222:5
    |
222 |     W: DMatrix<Complex64>,
    |     ^ help: convert the identifier to snake case (notice the capitalization): `w`

warning: structure field `W_opt` should have a snake case name
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:244:5
    |
244 |     W_opt: DMatrix<Complex64>,
    |     ^^^^^ help: convert the identifier to snake case (notice the capitalization): `w_opt`

warning: structure field `H` should have a snake case name
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:360:5
    |
360 |     H: DMatrix<Complex64>,
    |     ^ help: convert the identifier to snake case: `h`

warning: structure field `U` should have a snake case name
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:366:5
    |
366 |     U: Vec<DMatrix<Complex64>>,
    |     ^ help: convert the identifier to snake case (notice the capitalization): `u`

warning: calls to `std::mem::drop` with a reference instead of an owned value does nothing
   --> src/cma/conformal_prediction.rs:326:13
    |
326 |             drop(weights);  // Explicitly drop mutable borrow
    |             ^^^^^-------^
    |                  |
    |                  argument has type `&mut Vec<f64>`
    |
    = note: `#[warn(dropping_references)]` on by default
help: use `let _ = ...` to ignore the expression or result
    |
326 -             drop(weights);  // Explicitly drop mutable borrow
326 +             let _ = weights;  // Explicitly drop mutable borrow
    |

warning: variable `X_flat` should have a snake case name
   --> src/time_series/arima_gpu_optimized.rs:102:17
    |
102 |         let mut X_flat: Vec<f32> = Vec::with_capacity(num_samples * p);
    |                 ^^^^^^ help: convert the identifier to snake case (notice the capitalization): `x_flat`

warning: variable `X_transpose` should have a snake case name
   --> src/time_series/arima_gpu_optimized.rs:115:17
    |
115 |         let mut X_transpose: Vec<f32> = vec![0.0; p * num_samples];
    |                 ^^^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `x_transpose`

warning: variable `XtX` should have a snake case name
   --> src/time_series/arima_gpu_optimized.rs:125:13
    |
125 |         let XtX = executor.tensor_core_matmul_wmma(
    |             ^^^ help: convert the identifier to snake case: `xt_x`

warning: variable `Xty` should have a snake case name
   --> src/time_series/arima_gpu_optimized.rs:136:13
    |
136 |         let Xty = executor.tensor_core_matmul_wmma(
    |             ^^^ help: convert the identifier to snake case (notice the capitalization): `xty`

warning: variable `A` should have a snake case name
   --> src/time_series/arima_gpu_optimized.rs:169:39
    |
169 |     fn solve_linear_system_cpu(&self, A: &[f32], b: &[f32], n: usize) -> Result<Vec<f32>> {
    |                                       ^ help: convert the identifier to snake case: `a`

warning: variable `A_copy` should have a snake case name
   --> src/time_series/arima_gpu_optimized.rs:170:17
    |
170 |         let mut A_copy = A.to_vec();
    |                 ^^^^^^ help: convert the identifier to snake case: `a_copy`

warning: `prism-ai` (lib) generated 649 warnings (run `cargo fix --lib -p prism-ai` to apply 67 suggestions)
[CUBLAS Interposer] Loaded real CUBLAS: /usr/local/cuda-12.8/lib64/libcublas.so.12
[CUBLAS Interposer] Loaded real CUBLAS: /usr/local/cuda-12.8/lib64/libcublas.so.12
[CUBLAS Interposer] Loaded real CUBLAS: /usr/local/cuda-12.8/lib64/libcublas.so.12
[CUBLAS Interposer] Loaded real CUBLAS: /usr/local/cuda-12.8/lib64/libcublas.so.12
[CUBLAS Interposer] Loaded real CUBLAS: /usr/local/cuda-12.8/lib64/libcublas.so.12
[CUBLAS Interposer] Loaded real CUBLAS: /usr/local/cuda-12.8/lib64/libcublas.so.12
   Compiling prism-ai v0.1.0 (/home/diddy/Desktop/PRISM-AI-DoD/03-Source-Code)
[CUBLAS Interposer] Loaded real CUBLAS: /usr/local/cuda-12.8/lib64/libcublas.so.12
error[E0689]: can't call method `min` on ambiguous numeric type `{float}`
   --> benches/comprehensive_benchmarks.rs:211:46
    |
211 |             let allocated = remaining_demand.min(capacity);
    |                                              ^^^
    |
help: you must specify a type for this binding, like `f32`
    |
207 |         let mut remaining_demand: f32 = 1000.0; // MW
    |                                 +++++

For more information about this error, try `rustc --explain E0689`.
warning: prism-ai@0.1.0: Compiling CUBLAS interposer library for CUDA 12.8 compatibility
warning: prism-ai@0.1.0: Successfully compiled CUBLAS interposer library
warning: prism-ai@0.1.0: Interposer library at: /home/diddy/Desktop/PRISM-AI-DoD/03-Source-Code/target/release/build/prism-ai-0a2a4a3f381a983c/out/libcublas_interposer.so
warning: prism-ai@0.1.0: Compiling CUDA kernels with nvcc: /usr/local/cuda/bin/nvcc
warning: prism-ai@0.1.0: Detected Compute 12.0, using sm_90
warning: prism-ai@0.1.0: Compiling for GPU architecture: sm_90
warning: prism-ai@0.1.0: Compiling cuda_kernels/tensor_core_matmul.cu
warning: prism-ai@0.1.0: Successfully compiled cuda_kernels/tensor_core_matmul.cu to PTX
warning: prism-ai@0.1.0: Compiling neuromorphic kernels to shared library
warning: prism-ai@0.1.0: Successfully compiled neuromorphic kernels to shared library
warning: prism-ai@0.1.0: Library: /home/diddy/Desktop/PRISM-AI-DoD/03-Source-Code/target/release/build/prism-ai-0a2a4a3f381a983c/out/libneuromorphic_kernels.so
error: could not compile `prism-ai` (bench "comprehensive_benchmarks") due to 1 previous error
warning: use of deprecated associated function `gpu_reservoir::GpuReservoirComputer::new`: Use new_shared() with shared CUDA context
   --> src/neuromorphic/src/gpu_reservoir.rs:662:27
    |
662 |     GpuReservoirComputer::new(config, gpu_config)
    |                           ^^^
    |
    = note: `#[warn(deprecated)]` on by default

warning: unused import: `rayon::prelude`
  --> src/neuromorphic/src/gpu_reservoir.rs:15:5
   |
15 | use rayon::prelude::*;
   |     ^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` on by default

warning: unused variable: `reason`
   --> src/neuromorphic/src/pattern_detector.rs:357:30
    |
357 |     fn record_failure(&self, reason: &str) {
    |                              ^^^^^^ help: if this is intentional, prefix it with an underscore: `_reason`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `bin_source_past`
   --> src/neuromorphic/src/transfer_entropy.rs:109:17
    |
109 |             let bin_source_past = self.discretize_vector(&source_past);
    |                 ^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_bin_source_past`

warning: type `ReservoirStatistics` is more private than the item `ReservoirComputer::get_statistics`
   --> src/neuromorphic/src/reservoir.rs:224:5
    |
224 |     pub fn get_statistics(&self) -> &ReservoirStatistics {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method `ReservoirComputer::get_statistics` is reachable at visibility `pub`
    |
note: but type `ReservoirStatistics` is only usable at visibility `pub(self)`
   --> src/neuromorphic/src/reservoir.rs:108:1
    |
108 | struct ReservoirStatistics {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: `#[warn(private_interfaces)]` on by default

warning: fields `max_pool_size` and `total_allocated_bytes` are never read
  --> src/neuromorphic/src/gpu_memory.rs:17:5
   |
13 | pub struct GpuMemoryPool {
   |            ------------- fields in this struct
...
17 |     max_pool_size: usize,
   |     ^^^^^^^^^^^^^
18 |     total_allocated_bytes: Arc<Mutex<usize>>,
   |     ^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(dead_code)]` on by default

warning: hiding a lifetime that's elided elsewhere is confusing
   --> src/neuromorphic/src/gpu_memory.rs:302:29
    |
302 |     pub fn borrow_zero_copy(&mut self) -> Result<GpuBufferBorrow> {
    |                             ^^^^^^^^^            --------------- the same lifetime is hidden here
    |                             |
    |                             the lifetime is elided here
    |
    = help: the same lifetime is referred to in inconsistent ways, making the signature confusing
    = note: `#[warn(mismatched_lifetime_syntaxes)]` on by default
help: use `'_` for type paths
    |
302 |     pub fn borrow_zero_copy(&mut self) -> Result<GpuBufferBorrow<'_>> {
    |                                                                 ++++

warning: `neuromorphic-engine` (lib) generated 7 warnings
warning: unused import: `Array1`
  --> src/quantum/src/prct_coloring.rs:12:15
   |
12 | use ndarray::{Array1, Array2};
   |               ^^^^^^
   |
   = note: `#[warn(unused_imports)]` on by default

warning: unused import: `Context`
  --> src/quantum/src/prct_coloring.rs:14:22
   |
14 | use anyhow::{Result, Context};
   |                      ^^^^^^^

warning: unused import: `Hamiltonian`
  --> src/quantum/src/prct_coloring.rs:17:47
   |
17 | use crate::hamiltonian::{PhaseResonanceField, Hamiltonian};
   |                                               ^^^^^^^^^^^

warning: unused import: `HashMap`
  --> src/quantum/src/gpu_coloring.rs:10:24
   |
10 | use std::collections::{HashMap, HashSet};
   |                        ^^^^^^^

warning: unused import: `Context`
 --> src/quantum/src/prct_tsp.rs:8:22
  |
8 | use anyhow::{Result, Context};
  |                      ^^^^^^^

warning: unused import: `Context`
  --> src/quantum/src/qubo.rs:10:22
   |
10 | use anyhow::{anyhow, Context, Result};
   |                      ^^^^^^^

warning: unused import: `std::sync::Arc`
  --> src/quantum/src/qubo.rs:12:5
   |
12 | use std::sync::Arc;
   |     ^^^^^^^^^^^^^^

warning: variable does not need to be mutable
   --> src/quantum/src/gpu_coloring.rs:287:13
    |
287 |         let mut gpu_priorities = stream.alloc_zeros::<f32>(n)
    |             ----^^^^^^^^^^^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` on by default

warning: variable does not need to be mutable
   --> src/quantum/src/gpu_coloring.rs:289:13
    |
289 |         let mut gpu_colors = stream.alloc_zeros::<u32>(n)
    |             ----^^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
   --> src/quantum/src/gpu_coloring.rs:291:13
    |
291 |         let mut gpu_can_color = stream.alloc_zeros::<u32>(n)
    |             ----^^^^^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: value assigned to `current_energy` is never read
   --> src/quantum/src/qubo.rs:161:17
    |
161 |         let mut current_energy = self.best_energy;
    |                 ^^^^^^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?
    = note: `#[warn(unused_assignments)]` on by default

warning: variable `tour_gpu` is assigned to, but never used
  --> src/quantum/src/gpu_k_opt.rs:86:17
   |
86 |         let mut tour_gpu = stream.memcpy_stod(&tour_i32)?;
   |                 ^^^^^^^^
   |
   = note: consider using `_tour_gpu` instead
   = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `dist_gpu`
  --> src/quantum/src/gpu_k_opt.rs:89:13
   |
89 |         let dist_gpu = stream.memcpy_stod(&dist_flat)?;
   |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_dist_gpu`

warning: unused variable: `best_i_gpu`
  --> src/quantum/src/gpu_k_opt.rs:92:17
   |
92 |         let mut best_i_gpu = stream.alloc_zeros::<i32>(1)?;
   |                 ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_best_i_gpu`

warning: unused variable: `best_j_gpu`
  --> src/quantum/src/gpu_k_opt.rs:93:17
   |
93 |         let mut best_j_gpu = stream.alloc_zeros::<i32>(1)?;
   |                 ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_best_j_gpu`

warning: variable `best_delta_gpu` is assigned to, but never used
  --> src/quantum/src/gpu_k_opt.rs:94:17
   |
94 |         let mut best_delta_gpu = stream.memcpy_stod(&[f32::INFINITY])?;
   |                 ^^^^^^^^^^^^^^
   |
   = note: consider using `_best_delta_gpu` instead

warning: value assigned to `tour_gpu` is never read
   --> src/quantum/src/gpu_k_opt.rs:104:13
    |
104 |             tour_gpu = stream.memcpy_stod(&tour_i32)?;
    |             ^^^^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: value assigned to `best_delta_gpu` is never read
   --> src/quantum/src/gpu_k_opt.rs:108:13
    |
108 |             best_delta_gpu = stream.memcpy_stod(&[f32::INFINITY])?;
    |             ^^^^^^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: unused variable: `block_size`
   --> src/quantum/src/gpu_k_opt.rs:111:17
    |
111 |             let block_size = 16;
    |                 ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_block_size`

warning: unused variable: `cfg`
   --> src/quantum/src/gpu_k_opt.rs:112:17
    |
112 |             let cfg = LaunchConfig {
    |                 ^^^ help: if this is intentional, prefix it with an underscore: `_cfg`

warning: variable does not need to be mutable
  --> src/quantum/src/gpu_k_opt.rs:92:13
   |
92 |         let mut best_i_gpu = stream.alloc_zeros::<i32>(1)?;
   |             ----^^^^^^^^^^
   |             |
   |             help: remove this `mut`

warning: variable does not need to be mutable
  --> src/quantum/src/gpu_k_opt.rs:93:13
   |
93 |         let mut best_j_gpu = stream.alloc_zeros::<i32>(1)?;
   |             ----^^^^^^^^^^
   |             |
   |             help: remove this `mut`

warning: methods `generate_chromatic_coloring` and `optimize_tsp_ordering` are never used
   --> src/quantum/src/hamiltonian.rs:196:8
    |
137 | impl PhaseResonanceField {
    | ------------------------ methods in this implementation
...
196 |     fn generate_chromatic_coloring(&mut self, n_atoms: usize) {
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
220 |     fn optimize_tsp_ordering(&mut self, n_atoms: usize) {
    |        ^^^^^^^^^^^^^^^^^^^^^
    |
    = note: `#[warn(dead_code)]` on by default

warning: fields `masses`, `stencil_order`, and `energy_tolerance` are never read
   --> src/quantum/src/hamiltonian.rs:529:5
    |
522 | pub struct Hamiltonian {
    |            ----------- fields in this struct
...
529 |     masses: Array1<f64>,
    |     ^^^^^^
...
545 |     stencil_order: usize,   // Finite difference stencil order (9-point)
    |     ^^^^^^^^^^^^^
...
575 |     energy_tolerance: f64,
    |     ^^^^^^^^^^^^^^^^
    |
    = note: `Hamiltonian` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: methods `calculate_coupling_strength` and `pauli_dot_product` are never used
    --> src/quantum/src/hamiltonian.rs:1183:8
     |
 581 | impl Hamiltonian {
     | ---------------- methods in this implementation
...
1183 |     fn calculate_coupling_strength(&self, i: usize, j: usize, _t: f64) -> Complex64 {
     |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
1194 |     fn pauli_dot_product(&self, _i: usize, _j: usize) -> Complex64 {
     |        ^^^^^^^^^^^^^^^^^

warning: field `coupling` is never read
  --> src/quantum/src/prct_coloring.rs:33:5
   |
21 | pub struct ChromaticColoring {
   |            ----------------- field in this struct
...
33 |     coupling: Box<Array2<Complex64>>,
   |     ^^^^^^^^
   |
   = note: `ChromaticColoring` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `max_k` is never read
  --> src/quantum/src/gpu_k_opt.rs:14:5
   |
12 | pub struct GpuKOpt {
   |            ------- field in this struct
13 |     context: Arc<CudaContext>,
14 |     max_k: usize,
   |     ^^^^^

warning: `quantum-engine` (lib) generated 27 warnings (run `cargo fix --lib -p quantum-engine` to apply 12 suggestions)
warning: prism-ai@0.1.0: Compiling CUBLAS interposer library for CUDA 12.8 compatibility
warning: prism-ai@0.1.0: Successfully compiled CUBLAS interposer library
warning: prism-ai@0.1.0: Interposer library at: /home/diddy/Desktop/PRISM-AI-DoD/03-Source-Code/target/release/build/prism-ai-0a2a4a3f381a983c/out/libcublas_interposer.so
warning: prism-ai@0.1.0: Compiling CUDA kernels with nvcc: /usr/local/cuda/bin/nvcc
warning: prism-ai@0.1.0: Detected Compute 12.0, using sm_90
warning: prism-ai@0.1.0: Compiling for GPU architecture: sm_90
warning: prism-ai@0.1.0: Compiling cuda_kernels/tensor_core_matmul.cu
warning: prism-ai@0.1.0: Successfully compiled cuda_kernels/tensor_core_matmul.cu to PTX
warning: prism-ai@0.1.0: Compiling neuromorphic kernels to shared library
warning: prism-ai@0.1.0: Successfully compiled neuromorphic kernels to shared library
warning: prism-ai@0.1.0: Library: /home/diddy/Desktop/PRISM-AI-DoD/03-Source-Code/target/release/build/prism-ai-0a2a4a3f381a983c/out/libneuromorphic_kernels.so
warning: unused variable: `state`
   --> src/foundation/src/adp/decision_processor.rs:182:34
    |
182 |     fn generate_reasoning(&self, state: &State, action: Action, features: &[f64]) -> String {
    |                                  ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: field `quantum_hamiltonian` is never read
  --> src/foundation/src/platform.rs:33:5
   |
26 | pub struct NeuromorphicQuantumPlatform {
   |            --------------------------- field in this struct
...
33 |     quantum_hamiltonian: Arc<RwLock<Option<Hamiltonian>>>,
   |     ^^^^^^^^^^^^^^^^^^^
   |
   = note: `NeuromorphicQuantumPlatform` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` on by default

warning: field `state_to_reservoir` is never read
   --> src/foundation/src/platform.rs:101:5
    |
 95 | struct BidirectionalCoupling {
    |        --------------------- field in this struct
...
101 |     state_to_reservoir: f64,
    |     ^^^^^^^^^^^^^^^^^^
    |
    = note: `BidirectionalCoupling` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: methods `ensure_quantum_initialized`, `extract_quantum_features`, and `initialize_quantum_state` are never used
   --> src/foundation/src/platform.rs:758:14
    |
167 | impl NeuromorphicQuantumPlatform {
    | -------------------------------- methods in this implementation
...
758 |     async fn ensure_quantum_initialized(&self, input: &PlatformInput) -> Result<()> {
    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^
...
782 |     async fn extract_quantum_features(&self, _input: &PlatformInput, neuro_results: &NeuromorphicResults) -> Vec<f64> {
    |              ^^^^^^^^^^^^^^^^^^^^^^^^
...
822 |     async fn initialize_quantum_state(&self, hamiltonian: &mut Hamiltonian, features: &[f64]) -> Array1<Complex64> {
    |              ^^^^^^^^^^^^^^^^^^^^^^^^

warning: associated function `ingest_from_source` is never used
   --> src/foundation/src/ingestion/engine.rs:325:14
    |
 69 | impl IngestionEngine {
    | -------------------- associated function in this implementation
...
325 |     async fn ingest_from_source(
    |              ^^^^^^^^^^^^^^^^^^

warning: unused import: `HashMap`
  --> src/prct-core/src/coloring.rs:10:24
   |
10 | use std::collections::{HashMap, HashSet};
   |                        ^^^^^^^
   |
   = note: `#[warn(unused_imports)]` on by default

warning: unused import: `rayon::prelude`
 --> src/prct-core/src/coloring.rs:9:5
  |
9 | use rayon::prelude::*;
  |     ^^^^^^^^^^^^^^

warning: unused variable: `neuro_state`
   --> src/prct-core/src/drpp_algorithm.rs:194:9
    |
194 |         neuro_state: &NeuroState,
    |         ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_neuro_state`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `quantum_state`
   --> src/prct-core/src/drpp_algorithm.rs:195:9
    |
195 |         quantum_state: &QuantumState,
    |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_quantum_state`

warning: unused variable: `phase_field`
   --> src/prct-core/src/drpp_algorithm.rs:196:9
    |
196 |         phase_field: &mut PhaseField,
    |         ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_phase_field`

warning: unused variable: `n`
  --> src/prct-core/src/simulated_annealing.rs:31:9
   |
31 |     let n = graph.num_vertices;
   |         ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: `platform-foundation` (lib) generated 5 warnings
warning: `prct-core` (lib) generated 6 warnings (run `cargo fix --lib -p prct-core` to apply 1 suggestion)
[CUBLAS Interposer] Loaded real CUBLAS: /usr/local/cuda-12.8/lib64/libcublas.so.12
warning: unused import: `rand_distr::Normal`
 --> src/information_theory/advanced_transfer_entropy.rs:9:5
  |
9 | use rand_distr::Normal;
  |     ^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `std::collections::HashMap`
  --> src/information_theory/conditional_te.rs:24:5
   |
24 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> src/information_theory/multivariate_te.rs:24:5
   |
24 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> src/information_theory/time_delayed_te.rs:26:5
   |
26 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Context`
  --> src/orchestration/llm_clients/claude_client.rs:10:22
   |
10 | use anyhow::{Result, Context, bail};
   |                      ^^^^^^^

warning: unused import: `sleep`
 --> src/orchestration/llm_clients/gemini_client.rs:7:19
  |
7 | use tokio::time::{sleep, timeout, Duration, Instant};
  |                   ^^^^^

warning: unused import: `Context`
  --> src/orchestration/llm_clients/grok_client.rs:10:22
   |
10 | use anyhow::{Result, Context, bail};
   |                      ^^^^^^^

warning: unused import: `Duration`
  --> src/orchestration/llm_clients/ensemble.rs:16:28
   |
16 | use tokio::time::{Instant, Duration};
   |                            ^^^^^^^^

warning: unused import: `anyhow::Result`
  --> src/orchestration/thermodynamic/hamiltonian.rs:13:5
   |
13 | use anyhow::Result;
   |     ^^^^^^^^^^^^^^

warning: unused imports: `Array1` and `Array2`
  --> src/orchestration/thermodynamic/advanced_energy.rs:20:15
   |
20 | use ndarray::{Array1, Array2};
   |               ^^^^^^  ^^^^^^

warning: unused import: `Context`
  --> src/orchestration/thermodynamic/temperature_schedules.rs:17:22
   |
17 | use anyhow::{Result, Context};
   |                      ^^^^^^^

warning: unused import: `Context`
  --> src/orchestration/thermodynamic/replica_exchange.rs:15:22
   |
15 | use anyhow::{Result, Context};
   |                      ^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> src/orchestration/thermodynamic/replica_exchange.rs:16:5
   |
16 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Instant`
  --> src/orchestration/active_inference/hierarchical_client.rs:16:29
   |
16 | use tokio::time::{Duration, Instant};
   |                             ^^^^^^^

warning: unused import: `ThreatDetection`
  --> src/orchestration/integration/pwsa_llm_bridge.rs:11:77
   |
11 | use crate::api_server::routes::pwsa::{PwsaFusionPlatform, MissionAwareness, ThreatDetection, OctTelemetry, IrSensorFrame, GroundStationDa...
   |                                                                             ^^^^^^^^^^^^^^^

warning: unused import: `DMatrix`
  --> src/orchestration/integration/mission_charlie_integration.rs:20:25
   |
20 | use nalgebra::{DVector, DMatrix};
   |                         ^^^^^^^

warning: unused import: `parking_lot::RwLock`
  --> src/orchestration/integration/mission_charlie_integration.rs:23:5
   |
23 | use parking_lot::RwLock;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `nalgebra as na`
  --> src/orchestration/integration/prism_ai_integration.rs:14:5
   |
14 | use nalgebra as na;
   |     ^^^^^^^^^^^^^^

warning: unused import: `Array2`
  --> src/orchestration/integration/prism_ai_integration.rs:15:15
   |
15 | use ndarray::{Array2, Array1};
   |               ^^^^^^

warning: unused import: `std::time::SystemTime`
  --> src/orchestration/integration/prism_ai_integration.rs:17:5
   |
17 | use std::time::SystemTime;
   |     ^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `ActiveInferenceController`, `CausalDirection`, `CouplingStrength`, `EvolutionResult`, `ExecutionConfig`, `GenerativeModel`, `InformationChannel`, `PhaseSynchronizer`, `PolicySelector`, `SystemState`, `TransferEntropyResult`, `TransferEntropy`, `compile_and_execute`, and `detect_causal_direction`
  --> src/orchestration/integration/prism_ai_integration.rs:23:9
   |
23 |         GenerativeModel, HierarchicalModel, VariationalInference,
   |         ^^^^^^^^^^^^^^^
24 |         PolicySelector, ActiveInferenceController, FreeEnergyComponents,
   |         ^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^
...
29 |         ThermodynamicMetrics, EvolutionResult,
   |                               ^^^^^^^^^^^^^^^
...
33 |         TransferEntropy, TransferEntropyResult, CausalDirection,
   |         ^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^
34 |         detect_causal_direction,
   |         ^^^^^^^^^^^^^^^^^^^^^^^
...
38 |         CrossDomainBridge, DomainState, CouplingStrength,
   |                                         ^^^^^^^^^^^^^^^^
39 |         InformationChannel, PhaseSynchronizer, UnifiedPlatform,
   |         ^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^
...
44 |         HealthMonitor, ComponentHealth, HealthStatus, SystemState, SystemHealthState,
   |                                                       ^^^^^^^^^^^
...
50 |         compile_and_execute, ExecutionConfig,
   |         ^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^

warning: unused imports: `LLMResponse` and `OrchestrationError`
  --> src/orchestration/integration/prism_ai_integration.rs:77:32
   |
77 |     MissionCharlieIntegration, OrchestrationError, LLMResponse,
   |                                ^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^

warning: unused import: `anyhow::Result`
  --> src/orchestration/optimization/mdl_prompt_optimizer.rs:13:5
   |
13 | use anyhow::Result;
   |     ^^^^^^^^^^^^^^

warning: unused import: `std::io::Write`
  --> src/orchestration/optimization/mdl_prompt_optimizer.rs:51:13
   |
51 |         use std::io::Write;
   |             ^^^^^^^^^^^^^^

warning: unused import: `SymmetricEigen`
 --> src/orchestration/optimization/geometric_manifold.rs:8:39
  |
8 | use nalgebra::{DMatrix, DVector, SVD, SymmetricEigen};
  |                                       ^^^^^^^^^^^^^^

warning: unused import: `anyhow::Result`
  --> src/orchestration/caching/quantum_semantic_cache.rs:16:5
   |
16 | use anyhow::Result;
   |     ^^^^^^^^^^^^^^

warning: unused import: `Array1`
  --> src/orchestration/routing/te_embedding_gpu.rs:12:15
   |
12 | use ndarray::{Array1, Array2};
   |               ^^^^^^

warning: unused import: `Context as AnyhowContext`
  --> src/orchestration/routing/ksg_transfer_entropy_gpu.rs:17:22
   |
17 | use anyhow::{Result, Context as AnyhowContext};
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Array1`
  --> src/orchestration/routing/ksg_transfer_entropy_gpu.rs:18:15
   |
18 | use ndarray::{Array1, Array2, Axis};
   |               ^^^^^^

warning: unused import: `ndarray::Array1`
 --> src/orchestration/routing/te_validation.rs:7:5
  |
7 | use ndarray::Array1;
  |     ^^^^^^^^^^^^^^^

warning: unused import: `anyhow::Result`
  --> src/orchestration/validation/info_theoretic_validator.rs:12:5
   |
12 | use anyhow::Result;
   |     ^^^^^^^^^^^^^^

warning: unused imports: `Array1` and `Array2`
  --> src/orchestration/semantic_analysis/distance_metrics.rs:14:15
   |
14 | use ndarray::{Array1, Array2};
   |               ^^^^^^  ^^^^^^

warning: unused import: `Normal`
  --> src/orchestration/neuromorphic/unified_neuromorphic.rs:10:41
   |
10 | use rand_distr::{Distribution, Poisson, Normal};  // Fixed: rand_distr not rand
   |                                         ^^^^^^

warning: unused import: `ordered_float::OrderedFloat`
  --> src/orchestration/neuromorphic/unified_neuromorphic.rs:11:5
   |
11 | use ordered_float::OrderedFloat;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::gpu::GpuKernelExecutor`
 --> src/orchestration/neuromorphic/gpu_neuromorphic.rs:7:5
  |
7 | use crate::gpu::GpuKernelExecutor;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::gpu::neuromorphic_ffi::*`
 --> src/orchestration/neuromorphic/gpu_neuromorphic.rs:8:5
  |
8 | use crate::gpu::neuromorphic_ffi::*;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `CudaSlice`
 --> src/orchestration/neuromorphic/gpu_neuromorphic.rs:9:35
  |
9 | use cudarc::driver::{CudaContext, CudaSlice};
  |                                   ^^^^^^^^^

warning: unused imports: `DMatrix` and `DVector`
  --> src/orchestration/neuromorphic/gpu_neuromorphic.rs:10:16
   |
10 | use nalgebra::{DMatrix, DVector};
   |                ^^^^^^^  ^^^^^^^

warning: unused import: `std::sync::Arc`
  --> src/orchestration/local_llm/gpu_llm_inference.rs:15:5
   |
15 | use std::sync::Arc;
   |     ^^^^^^^^^^^^^^

warning: unused import: `cudarc::driver::CudaContext`
  --> src/orchestration/local_llm/gpu_llm_inference.rs:16:5
   |
16 | use cudarc::driver::CudaContext;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `GpuTransformerLayer`
  --> src/orchestration/local_llm/gpu_llm_inference.rs:18:30
   |
18 | use super::gpu_transformer::{GpuTransformerLayer, GpuLLMInference};
   |                              ^^^^^^^^^^^^^^^^^^^

warning: variant `Q2_K` should have an upper camel case name
  --> src/orchestration/local_llm/gguf_loader.rs:45:5
   |
45 |     Q2_K = 10,
   |     ^^^^ help: convert the identifier to upper camel case: `Q2K`
   |
   = note: `#[warn(non_camel_case_types)]` on by default

warning: variant `Q3_K` should have an upper camel case name
  --> src/orchestration/local_llm/gguf_loader.rs:46:5
   |
46 |     Q3_K = 11,
   |     ^^^^ help: convert the identifier to upper camel case: `Q3K`

warning: variant `Q4_K` should have an upper camel case name
  --> src/orchestration/local_llm/gguf_loader.rs:47:5
   |
47 |     Q4_K = 12,
   |     ^^^^ help: convert the identifier to upper camel case: `Q4K`

warning: variant `Q5_K` should have an upper camel case name
  --> src/orchestration/local_llm/gguf_loader.rs:48:5
   |
48 |     Q5_K = 13,
   |     ^^^^ help: convert the identifier to upper camel case: `Q5K`

warning: variant `Q6_K` should have an upper camel case name
  --> src/orchestration/local_llm/gguf_loader.rs:49:5
   |
49 |     Q6_K = 14,
   |     ^^^^ help: convert the identifier to upper camel case: `Q6K`

warning: variant `Q8_K` should have an upper camel case name
  --> src/orchestration/local_llm/gguf_loader.rs:50:5
   |
50 |     Q8_K = 15,
   |     ^^^^ help: convert the identifier to upper camel case: `Q8K`

warning: unused import: `anyhow::Result`
  --> src/orchestration/local_llm/attention_analyzer.rs:23:5
   |
23 | use anyhow::Result;
   |     ^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> src/orchestration/local_llm/transfer_entropy_llm.rs:31:5
   |
31 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `BTreeMap`
 --> src/orchestration/decomposition/pid_synergy.rs:9:42
  |
9 | use std::collections::{HashMap, HashSet, BTreeMap, BTreeSet};
  |                                          ^^^^^^^^

warning: unused import: `VecDeque`
 --> src/orchestration/inference/hierarchical_active_inference.rs:9:33
  |
9 | use std::collections::{HashMap, VecDeque};
  |                                 ^^^^^^^^

warning: unused import: `rand_distr::Normal`
  --> src/orchestration/inference/hierarchical_active_inference.rs:11:5
   |
11 | use rand_distr::Normal;
   |     ^^^^^^^^^^^^^^^^^^

warning: unused import: `SVD`
 --> src/orchestration/causality/bidirectional_causality.rs:8:34
  |
8 | use nalgebra::{DMatrix, DVector, SVD};
  |                                  ^^^

warning: unused import: `VecDeque`
 --> src/orchestration/causality/bidirectional_causality.rs:9:42
  |
9 | use std::collections::{HashMap, HashSet, VecDeque};
  |                                          ^^^^^^^^

warning: unused import: `rand_distr::Normal`
  --> src/orchestration/causality/bidirectional_causality.rs:12:5
   |
12 | use rand_distr::Normal;
   |     ^^^^^^^^^^^^^^^^^^

warning: unused import: `Complex`
 --> src/orchestration/quantum/quantum_entanglement_measures.rs:8:34
  |
8 | use nalgebra::{DMatrix, DVector, Complex, SymmetricEigen};
  |                                  ^^^^^^^

warning: unused import: `VecDeque`
  --> src/orchestration/quantum/quantum_entanglement_measures.rs:10:33
   |
10 | use std::collections::{HashMap, VecDeque};
   |                                 ^^^^^^^^

warning: unused import: `Context as AnyhowContext`
 --> src/gpu/gpu_enabled.rs:5:22
  |
5 | use anyhow::{Result, Context as AnyhowContext};
  |                      ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Arc`
 --> src/gpu/cublas_compat.rs:8:17
  |
8 | use std::sync::{Arc, OnceLock};
  |                 ^^^

warning: unused import: `Context`
 --> src/gpu/production_runtime.rs:9:22
  |
9 | use anyhow::{Result, Context};
  |                      ^^^^^^^

warning: unused import: `std::ffi::c_void`
   --> src/gpu/cudarc_replacement.rs:116:17
    |
116 |             use std::ffi::c_void;
    |                 ^^^^^^^^^^^^^^^^

warning: unused import: `cudarc::driver::sys`
   --> src/cma/gpu_integration.rs:159:21
    |
159 |                 use cudarc::driver::sys;
    |                     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::sync::Arc`
  --> src/assistant/local_llm/gpu_llm_inference.rs:15:5
   |
15 | use std::sync::Arc;
   |     ^^^^^^^^^^^^^^

warning: unused import: `cudarc::driver::CudaContext`
  --> src/assistant/local_llm/gpu_llm_inference.rs:16:5
   |
16 | use cudarc::driver::CudaContext;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `GpuTransformerLayer`
  --> src/assistant/local_llm/gpu_llm_inference.rs:18:56
   |
18 | use crate::orchestration::local_llm::gpu_transformer::{GpuTransformerLayer, GpuLLMInference};
   |                                                        ^^^^^^^^^^^^^^^^^^^

warning: variant `Q2_K` should have an upper camel case name
  --> src/assistant/local_llm/gguf_loader.rs:45:5
   |
45 |     Q2_K = 10,
   |     ^^^^ help: convert the identifier to upper camel case: `Q2K`

warning: variant `Q3_K` should have an upper camel case name
  --> src/assistant/local_llm/gguf_loader.rs:46:5
   |
46 |     Q3_K = 11,
   |     ^^^^ help: convert the identifier to upper camel case: `Q3K`

warning: variant `Q4_K` should have an upper camel case name
  --> src/assistant/local_llm/gguf_loader.rs:47:5
   |
47 |     Q4_K = 12,
   |     ^^^^ help: convert the identifier to upper camel case: `Q4K`

warning: variant `Q5_K` should have an upper camel case name
  --> src/assistant/local_llm/gguf_loader.rs:48:5
   |
48 |     Q5_K = 13,
   |     ^^^^ help: convert the identifier to upper camel case: `Q5K`

warning: variant `Q6_K` should have an upper camel case name
  --> src/assistant/local_llm/gguf_loader.rs:49:5
   |
49 |     Q6_K = 14,
   |     ^^^^ help: convert the identifier to upper camel case: `Q6K`

warning: variant `Q8_K` should have an upper camel case name
  --> src/assistant/local_llm/gguf_loader.rs:50:5
   |
50 |     Q8_K = 15,
   |     ^^^^ help: convert the identifier to upper camel case: `Q8K`

warning: unused variable: `input`
  --> src/api_server/graphql_schema.rs:55:9
   |
55 |         input: PortfolioOptimizationInput,
   |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_input`
   |
   = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `input`
  --> src/api_server/graphql_schema.rs:82:9
   |
82 |         input: MotionPlanInput,
   |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_input`

warning: unused variable: `input`
   --> src/api_server/graphql_schema.rs:127:9
    |
127 |         input: HealthcareRiskInput,
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_input`

warning: unused variable: `input`
   --> src/api_server/graphql_schema.rs:140:9
    |
140 |         input: EnergyForecastInput,
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_input`

warning: unused variable: `input`
   --> src/api_server/graphql_schema.rs:198:9
    |
198 |         input: PortfolioOptimizationInput,
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_input`

warning: unused variable: `input`
   --> src/api_server/graphql_schema.rs:216:9
    |
216 |         input: MotionPlanInput,
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_input`

warning: variable does not need to be mutable
   --> src/orchestration/llm_clients/openai_client.rs:126:13
    |
126 |         let mut last = self.last_request.lock().await;
    |             ----^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` on by default

warning: unused variable: `start`
   --> src/orchestration/llm_clients/ensemble.rs:129:13
    |
129 |         let start = Instant::now();
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_start`

warning: unused variable: `manifold_result`
   --> src/orchestration/integration/mission_charlie_integration.rs:260:13
    |
260 |         let manifold_result = self.manifold_optimizer.optimize_llm_responses(
    |             ^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_manifold_result`

warning: unused variable: `context`
   --> src/orchestration/integration/prism_ai_integration.rs:249:45
    |
249 |         let sensor_assessment = if let Some(context) = sensor_context {
    |                                             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_context`

warning: unused variable: `state`
   --> src/orchestration/integration/prism_ai_integration.rs:291:17
    |
291 |             let state = self.response_to_state(&charlie_response);
    |                 ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `bridged_result`
   --> src/orchestration/integration/prism_ai_integration.rs:296:13
    |
296 |         let bridged_result = {
    |             ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_bridged_result`

warning: variable does not need to be mutable
   --> src/orchestration/integration/prism_ai_integration.rs:327:17
    |
327 |             let mut health = self.health_monitor.write();
    |                 ----^^^^^^
    |                 |
    |                 help: remove this `mut`

warning: unused variable: `hamiltonian`
   --> src/phase6/integration.rs:240:9
    |
240 |         hamiltonian: &ModulatedHamiltonian,
    |         ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_hamiltonian`

warning: unused variable: `n`
   --> src/phase6/integration.rs:242:13
    |
242 |         let n = adjacency.nrows();
    |             ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: unused variable: `initial_state`
   --> src/phase6/integration.rs:267:9
    |
267 |         initial_state: &Array1<f64>,
    |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_initial_state`

warning: unused variable: `avg_temp`
   --> src/phase6/integration.rs:271:13
    |
271 |         let avg_temp = hamiltonian.local_temperature.mean().unwrap_or(1.0);
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_avg_temp`

warning: unused variable: `state`
  --> src/api_server/routes/pwsa.rs:95:11
   |
95 |     State(state): State<Arc<AppState>>,
   |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/pwsa.rs:140:11
    |
140 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/pwsa.rs:159:11
    |
159 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/pwsa.rs:179:11
    |
179 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/finance.rs:103:11
    |
103 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/finance.rs:195:11
    |
195 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/finance.rs:215:11
    |
215 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/finance.rs:233:11
    |
233 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/finance.rs:299:11
    |
299 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `request`
   --> src/api_server/routes/finance.rs:300:10
    |
300 |     Json(request): Json<BacktestRequest>,
    |          ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_request`

warning: unused variable: `req`
   --> src/api_server/routes/finance_advanced.rs:258:10
    |
258 |     Json(req): Json<GnnPortfolioPredictionRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/finance_advanced.rs:293:10
    |
293 |     Json(req): Json<TransferEntropyCausalityRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/finance_advanced.rs:321:10
    |
321 |     Json(req): Json<PortfolioRebalancingRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `state`
   --> src/api_server/routes/telecom.rs:101:11
    |
101 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/telecom.rs:122:11
    |
122 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/telecom.rs:142:11
    |
142 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/telecom.rs:157:11
    |
157 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
  --> src/api_server/routes/robotics.rs:83:11
   |
83 |     State(state): State<Arc<AppState>>,
   |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/robotics.rs:168:11
    |
168 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/robotics.rs:185:11
    |
185 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/robotics.rs:208:11
    |
208 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
  --> src/api_server/routes/llm.rs:85:11
   |
85 |     State(state): State<Arc<AppState>>,
   |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/llm.rs:105:11
    |
105 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/llm.rs:125:11
    |
125 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/llm.rs:161:11
    |
161 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/llm.rs:180:11
    |
180 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/time_series.rs:122:11
    |
122 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/time_series.rs:241:11
    |
241 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/time_series.rs:263:11
    |
263 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/time_series.rs:287:11
    |
287 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/time_series.rs:306:11
    |
306 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/pixels.rs:144:11
    |
144 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/pixels.rs:201:11
    |
201 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/pixels.rs:221:11
    |
221 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/pixels.rs:240:11
    |
240 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `state`
   --> src/api_server/routes/pixels.rs:258:11
    |
258 |     State(state): State<Arc<AppState>>,
    |           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:296:10
    |
296 |     Json(req): Json<HealthcareRiskRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:329:10
    |
329 |     Json(req): Json<EnergyForecastRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:346:10
    |
346 |     Json(req): Json<ManufacturingMaintenanceRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:362:10
    |
362 |     Json(req): Json<SupplyChainDemandRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:377:10
    |
377 |     Json(req): Json<AgricultureYieldRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:394:10
    |
394 |     Json(req): Json<CybersecurityThreatRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:414:10
    |
414 |     Json(req): Json<ClimateForecastRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:427:10
    |
427 |     Json(req): Json<SmartCityOptimizationRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:443:10
    |
443 |     Json(req): Json<EducationPerformanceRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:468:10
    |
468 |     Json(req): Json<RetailInventoryRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `req`
   --> src/api_server/routes/applications.rs:481:10
    |
481 |     Json(req): Json<ConstructionForecastRequest>,
    |          ^^^ help: if this is intentional, prefix it with an underscore: `_req`

warning: unused variable: `state`
  --> src/api_server/websocket.rs:76:43
   |
76 | async fn handle_socket(socket: WebSocket, state: Arc<AppState>) {
   |                                           ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused import: `Context`
  --> src/statistical_mechanics/gpu.rs:15:30
   |
15 | use anyhow::{Result, anyhow, Context};
   |                              ^^^^^^^

warning: unused import: `Context`
  --> src/active_inference/gpu.rs:16:30
   |
16 | use anyhow::{Result, anyhow, Context};
   |                              ^^^^^^^

warning: unused import: `Read`
  --> src/resilience/checkpoint_manager.rs:38:15
   |
38 | use std::io::{Read, Write};
   |               ^^^^

warning: unused import: `Distribution`
  --> src/orchestration/neuromorphic/unified_neuromorphic.rs:10:18
   |
10 | use rand_distr::{Distribution, Poisson, Normal};  // Fixed: rand_distr not rand
   |                  ^^^^^^^^^^^^

warning: unused import: `rand::distributions::Distribution`
  --> src/orchestration/inference/hierarchical_active_inference.rs:10:5
   |
10 | use rand::distributions::Distribution;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rand::distributions::Distribution`
  --> src/orchestration/causality/bidirectional_causality.rs:11:5
   |
11 | use rand::distributions::Distribution;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Context`
 --> src/quantum_mlir/runtime.rs:6:22
  |
6 | use anyhow::{Result, Context};
  |                      ^^^^^^^

warning: unused import: `sha2::Digest`
  --> src/cma/guarantees/mod.rs:16:5
   |
16 | use sha2::Digest;
   |     ^^^^^^^^^^^^

warning: unused import: `gpu_integration::GpuSolvable`
   --> src/cma/mod.rs:127:13
    |
127 |         use gpu_integration::GpuSolvable;
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused variable: `psi_n`
   --> src/information_theory/transfer_entropy.rs:391:13
    |
391 |         let psi_n = digamma(n as f64);
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_psi_n`

warning: value assigned to `count_greater` is never read
   --> src/information_theory/transfer_entropy.rs:487:17
    |
487 |         let mut count_greater = 0;
    |                 ^^^^^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?
    = note: `#[warn(unused_assignments)]` on by default

warning: unused variable: `rng`
   --> src/information_theory/transfer_entropy.rs:491:17
    |
491 |             let rng = rand::thread_rng();
    |                 ^^^ help: if this is intentional, prefix it with an underscore: `_rng`

warning: unused variable: `lag_xy`
   --> src/information_theory/transfer_entropy.rs:672:10
    |
672 |     let (lag_xy, result_xy) = te_calc.find_optimal_lag(x, y, max_lag);
    |          ^^^^^^ help: if this is intentional, prefix it with an underscore: `_lag_xy`

warning: unused variable: `lag_yx`
   --> src/information_theory/transfer_entropy.rs:675:10
    |
675 |     let (lag_yx, result_yx) = te_calc.find_optimal_lag(y, x, max_lag);
    |          ^^^^^^ help: if this is intentional, prefix it with an underscore: `_lag_yx`

warning: unused variable: `source_i`
   --> src/information_theory/advanced_transfer_entropy.rs:614:38
    |
614 |     pub fn unique_information(&self, source_i: &Array1<f64>,
    |                                      ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_source_i`

warning: unused variable: `other_sources`
   --> src/information_theory/advanced_transfer_entropy.rs:615:30
    |
615 | ...                   other_sources: &[Array1<f64>],
    |                       ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_other_sources`

warning: unused variable: `target`
   --> src/information_theory/advanced_transfer_entropy.rs:616:30
    |
616 | ...                   target: &Array1<f64>) -> f64 {
    |                       ^^^^^^ help: if this is intentional, prefix it with an underscore: `_target`

warning: unused variable: `sources`
   --> src/information_theory/advanced_transfer_entropy.rs:640:43
    |
640 |     pub fn synergistic_information(&self, sources: &[Array1<f64>],
    |                                           ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_sources`

warning: unused variable: `target`
   --> src/information_theory/advanced_transfer_entropy.rs:641:35
    |
641 | ...                   target: &Array1<f64>) -> f64 {
    |                       ^^^^^^ help: if this is intentional, prefix it with an underscore: `_target`

warning: unused variable: `n`
  --> src/information_theory/ksg_estimator.rs:66:13
   |
66 |         let n = source.len();
   |             ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: unused variable: `tree_dim_plus`
   --> src/information_theory/ksg_estimator.rs:349:13
    |
349 |         let tree_dim_plus = KdTree::new(&points_dim_plus);
    |             ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_tree_dim_plus`

warning: unused variable: `dist_cond`
   --> src/information_theory/conditional_te.rs:250:17
    |
250 |             let dist_cond = self.find_kth_neighbor_distance_cond(emb, i)?;
    |                 ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_dist_cond`

warning: unused variable: `x_embed`
   --> src/information_theory/transfer_entropy_gpu.rs:161:26
    |
161 |     fn gpu_ksg_te(&self, x_embed: &[Vec<f64>], y_embed: &[Vec<f64>], y_future: &[f64]) -> Result<f64> {
    |                          ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_x_embed`

warning: unused variable: `y_embed`
   --> src/information_theory/transfer_entropy_gpu.rs:161:48
    |
161 |     fn gpu_ksg_te(&self, x_embed: &[Vec<f64>], y_embed: &[Vec<f64>], y_future: &[f64]) -> Result<f64> {
    |                                                ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_y_embed`

warning: unused variable: `y_future`
   --> src/information_theory/transfer_entropy_gpu.rs:161:70
    |
161 |     fn gpu_ksg_te(&self, x_embed: &[Vec<f64>], y_embed: &[Vec<f64>], y_future: &[f64]) -> Result<f64> {
    |                                                                      ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_y_future`

warning: unused variable: `source`
   --> src/information_theory/transfer_entropy_gpu.rs:168:36
    |
168 |     fn gpu_permutation_test(&self, source: &Array1<f64>, target: &Array1<f64>, observed_te: f64) -> Result<f64> {
    |                                    ^^^^^^ help: if this is intentional, prefix it with an underscore: `_source`

warning: unused variable: `target`
   --> src/information_theory/transfer_entropy_gpu.rs:168:58
    |
168 |     fn gpu_permutation_test(&self, source: &Array1<f64>, target: &Array1<f64>, observed_te: f64) -> Result<f64> {
    |                                                          ^^^^^^ help: if this is intentional, prefix it with an underscore: `_target`

warning: unused variable: `observed_te`
   --> src/information_theory/transfer_entropy_gpu.rs:168:80
    |
168 |     fn gpu_permutation_test(&self, source: &Array1<f64>, target: &Array1<f64>, observed_te: f64) -> Result<f64> {
    |                                                                                ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_observed_te`

warning: unused variable: `source`
   --> src/information_theory/transfer_entropy_gpu.rs:174:36
    |
174 |     fn gpu_ksg_significance(&self, source: &Array1<f64>, target: &Array1<f64>, observed_te: f64) -> Result<f64> {
    |                                    ^^^^^^ help: if this is intentional, prefix it with an underscore: `_source`

warning: unused variable: `target`
   --> src/information_theory/transfer_entropy_gpu.rs:174:58
    |
174 |     fn gpu_ksg_significance(&self, source: &Array1<f64>, target: &Array1<f64>, observed_te: f64) -> Result<f64> {
    |                                                          ^^^^^^ help: if this is intentional, prefix it with an underscore: `_target`

warning: unused variable: `observed_te`
   --> src/information_theory/transfer_entropy_gpu.rs:174:80
    |
174 |     fn gpu_ksg_significance(&self, source: &Array1<f64>, target: &Array1<f64>, observed_te: f64) -> Result<f64> {
    |                                                                                ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_observed_te`

warning: unused variable: `mi_y_x1`
   --> src/information_theory/pid.rs:227:13
    |
227 |         let mi_y_x1 = self.mutual_information(y, x1)?;
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_mi_y_x1`

warning: unused variable: `mi_y_x2`
   --> src/information_theory/pid.rs:228:13
    |
228 |         let mi_y_x2 = self.mutual_information(y, x2)?;
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_mi_y_x2`

warning: unused variable: `mi_y_x1x2`
   --> src/information_theory/pid.rs:229:13
    |
229 |         let mi_y_x1x2 = self.mutual_information_joint(y, x1, x2)?;
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_mi_y_x1x2`

warning: unused variable: `dtheta`
   --> src/statistical_mechanics/thermodynamic_network.rs:273:13
    |
273 |         let dtheta = 2.0 * PI / 10.0; // 10 bins in phase
    |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_dtheta`

warning: unused variable: `dv`
   --> src/statistical_mechanics/thermodynamic_network.rs:274:13
    |
274 |         let dv = (KB * temperature).sqrt() / 5.0; // 5 bins in velocity
    |             ^^ help: if this is intentional, prefix it with an underscore: `_dv`

warning: unused variable: `natural_frequencies`
   --> src/statistical_mechanics/thermodynamic_network.rs:296:9
    |
296 |         natural_frequencies: &[f64],
    |         ^^^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_natural_frequencies`

warning: unused variable: `initial_entropy`
   --> src/statistical_mechanics/thermodynamic_network.rs:416:13
    |
416 |         let initial_entropy = self.state.entropy;
    |             ^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_initial_entropy`

warning: unused variable: `order_r`
   --> src/statistical_mechanics/gpu.rs:266:13
    |
266 |         let order_r = (order_real_vec[0]*order_real_vec[0] + order_imag_vec[0]*order_imag_vec[0]).sqrt() / (n as f64);
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_order_r`

warning: unused variable: `horizon`
   --> src/active_inference/hierarchical_model.rs:434:31
    |
434 |     pub fn predict(&mut self, horizon: f64) {
    |                               ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_horizon`

warning: unused variable: `weighted_dynamical`
   --> src/active_inference/variational_inference.rs:225:13
    |
225 |         let weighted_dynamical = &dynamical_error * &model.level1.belief.precision;
    |             ^^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_weighted_dynamical`

warning: unused variable: `action`
  --> src/active_inference/controller.rs:43:17
   |
43 |             let action = self.controller.control(&test_model);
   |                 ^^^^^^ help: if this is intentional, prefix it with an underscore: `_action`

warning: unused variable: `obs`
  --> src/active_inference/controller.rs:46:17
   |
46 |             let obs = Array1::<f64>::ones(100);  // Simplified
   |                 ^^^ help: if this is intentional, prefix it with an underscore: `_obs`

warning: unused variable: `num_steps`
  --> src/active_inference/controller.rs:66:9
   |
66 |         num_steps: usize,
   |         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_num_steps`

warning: unused variable: `jacobian_f32`
   --> src/active_inference/gpu_inference.rs:172:13
    |
172 |         let jacobian_f32: Vec<f32> = jacobian.as_slice().unwrap()
    |             ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_jacobian_f32`

warning: unused variable: `error_f32`
   --> src/active_inference/gpu_inference.rs:174:13
    |
174 |         let error_f32: Vec<f32> = error.as_slice().unwrap()
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_error_f32`

warning: unused variable: `diffusion`
   --> src/active_inference/gpu_inference.rs:261:13
    |
261 |         let diffusion = level.diffusion;
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_diffusion`

warning: unused variable: `predicted`
   --> src/active_inference/gpu_inference.rs:326:17
    |
326 |             let predicted = self.predict_observations_gpu(
    |                 ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_predicted`

warning: unused variable: `model`
   --> src/active_inference/gpu_policy_eval.rs:684:42
    |
684 |     fn compute_efe_components(&mut self, model: &HierarchicalModel) -> Result<()> {
    |                                          ^^^^^ help: if this is intentional, prefix it with an underscore: `_model`

warning: unused variable: `t`
   --> src/active_inference/policy_search_gpu.rs:380:18
    |
380 |             for (t, base_action) in base_policy.actions.iter().enumerate() {
    |                  ^ help: if this is intentional, prefix it with an underscore: `_t`

warning: unused variable: `j`
  --> src/integration/information_channel.rs:60:22
   |
60 |                 for (j, &p_y_given_x) in self.transition_matrix.column(i).iter().enumerate() {
   |                      ^ help: if this is intentional, prefix it with an underscore: `_j`

warning: unused variable: `performance`
   --> src/integration/unified_platform.rs:101:13
    |
101 |         let performance = self.total_latency_ms < 500.0;
    |             ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_performance`

warning: unused variable: `exec`
   --> src/integration/multi_modal_reasoner.rs:216:13
    |
216 |         let exec = self.executor.lock().unwrap();
    |             ^^^^ help: if this is intentional, prefix it with an underscore: `_exec`

warning: unused variable: `conf_gpu`
   --> src/integration/multi_modal_reasoner.rs:220:13
    |
220 |         let conf_gpu = stream.memcpy_stod(&confidences)?;
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_conf_gpu`

warning: unused variable: `n`
  --> src/orchestration/llm_clients/ensemble.rs:68:13
   |
68 |         let n = llm_clients.len();
   |             ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: unused variable: `n`
   --> src/orchestration/thermodynamic/advanced_energy.rs:188:13
    |
188 |         let n = self.models.len();
    |             ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: unused variable: `kernel`
   --> src/orchestration/thermodynamic/advanced_energy.rs:244:13
    |
244 |         let kernel = executor_lock.get_kernel("weighted_energy_sum")?;
    |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_kernel`

warning: unused variable: `costs_dev`
   --> src/orchestration/thermodynamic/advanced_energy.rs:249:13
    |
249 |         let costs_dev = stream.memcpy_stod(costs)?;
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_costs_dev`

warning: unused variable: `qualities_dev`
   --> src/orchestration/thermodynamic/advanced_energy.rs:250:13
    |
250 |         let qualities_dev = stream.memcpy_stod(qualities)?;
    |             ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_qualities_dev`

warning: unused variable: `latencies_dev`
   --> src/orchestration/thermodynamic/advanced_energy.rs:251:13
    |
251 |         let latencies_dev = stream.memcpy_stod(latencies)?;
    |             ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_latencies_dev`

warning: unused variable: `uncertainties_dev`
   --> src/orchestration/thermodynamic/advanced_energy.rs:252:13
    |
252 |         let uncertainties_dev = stream.memcpy_stod(uncertainties)?;
    |             ^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_uncertainties_dev`

warning: unused variable: `cfg`
   --> src/orchestration/thermodynamic/advanced_energy.rs:265:13
    |
265 |         let cfg = cudarc::driver::LaunchConfig {
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_cfg`

warning: unused variable: `energies_f32`
   --> src/orchestration/thermodynamic/advanced_energy.rs:279:13
    |
279 |         let energies_f32: Vec<f32> = costs.iter().zip(qualities.iter()).zip(latencies.iter()).zip(uncertainties.iter())
    |             ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_energies_f32`

warning: unnecessary `unsafe` block
   --> src/orchestration/thermodynamic/advanced_energy.rs:271:9
    |
271 |         unsafe {
    |         ^^^^^^ unnecessary `unsafe` block
    |
    = note: `#[warn(unused_unsafe)]` on by default

warning: variable does not need to be mutable
   --> src/orchestration/thermodynamic/advanced_energy.rs:253:13
    |
253 |         let mut energies_dev = stream.alloc_zeros::<f32>(n)?;
    |             ----^^^^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `n_accepted`
   --> src/orchestration/thermodynamic/replica_exchange.rs:145:13
    |
145 |         let n_accepted = self.exchange_manager.exchange_round();
    |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_n_accepted`

warning: unused variable: `g`
   --> src/orchestration/optimization/geometric_manifold.rs:960:13
    |
960 |         let g = (self.manifold.metric.g)(x);
    |             ^ help: if this is intentional, prefix it with an underscore: `_g`

warning: unused variable: `tangent`
    --> src/orchestration/optimization/geometric_manifold.rs:1365:17
     |
1365 |             let tangent = &geodesic.tangents[i];
     |                 ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_tangent`

warning: unused variable: `g0_inv`
    --> src/orchestration/optimization/geometric_manifold.rs:1371:26
     |
1371 |             if let (Some(g0_inv), Some(g1_inv)) = (g0.clone().try_inverse(), g1.try_inverse()) {
     |                          ^^^^^^ help: if this is intentional, prefix it with an underscore: `_g0_inv`

warning: unused variable: `manifold_dimension`
    --> src/orchestration/optimization/geometric_manifold.rs:1396:13
     |
1396 |         let manifold_dimension = self.manifold.dimension;
     |             ^^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_manifold_dimension`

warning: unused variable: `kernel`
  --> src/orchestration/routing/te_embedding_gpu.rs:93:13
   |
93 |         let kernel = executor_lock.get_kernel("time_delayed_embedding")?;
   |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_kernel`

warning: unused variable: `ts_dev`
  --> src/orchestration/routing/te_embedding_gpu.rs:97:13
   |
97 |         let ts_dev = stream.memcpy_stod(&time_series_f32)?;
   |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_ts_dev`

warning: value assigned to `embedded_dev` is never read
  --> src/orchestration/routing/te_embedding_gpu.rs:98:17
   |
98 |         let mut embedded_dev = stream.alloc_zeros::<f32>(n_embedded * embedding_dim)?;
   |                 ^^^^^^^^^^^^
   |
   = help: maybe it is overwritten before being read?

warning: unused variable: `cfg`
   --> src/orchestration/routing/te_embedding_gpu.rs:104:13
    |
104 |         let cfg = LaunchConfig {
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_cfg`

warning: unnecessary `unsafe` block
   --> src/orchestration/routing/te_embedding_gpu.rs:110:9
    |
110 |         unsafe {
    |         ^^^^^^ unnecessary `unsafe` block

warning: unused variable: `kernel`
   --> src/orchestration/routing/gpu_kdtree.rs:170:13
    |
170 |         let kernel = executor_lock.get_kernel("compute_distances")?;
    |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_kernel`

warning: unused variable: `dataset_dev`
   --> src/orchestration/routing/gpu_kdtree.rs:174:13
    |
174 |         let dataset_dev = stream.memcpy_stod(&dataset_f32)?;
    |             ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_dataset_dev`

warning: unused variable: `query_dev`
   --> src/orchestration/routing/gpu_kdtree.rs:175:13
    |
175 |         let query_dev = stream.memcpy_stod(&query_f32)?;
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_query_dev`

warning: value assigned to `distances_dev` is never read
   --> src/orchestration/routing/gpu_kdtree.rs:176:17
    |
176 |         let mut distances_dev = stream.alloc_zeros::<f32>(n_points)?;
    |                 ^^^^^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: unused variable: `cfg`
   --> src/orchestration/routing/gpu_kdtree.rs:182:13
    |
182 |         let cfg = LaunchConfig {
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_cfg`

warning: unnecessary `unsafe` block
   --> src/orchestration/routing/gpu_kdtree.rs:188:9
    |
188 |         unsafe {
    |         ^^^^^^ unnecessary `unsafe` block

warning: variable does not need to be mutable
   --> src/orchestration/routing/te_validation.rs:367:13
    |
367 |         let mut total = results.len();
    |             ----^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `dim`
    --> src/orchestration/neuromorphic/unified_neuromorphic.rs:1054:13
     |
1054 |         for dim in 0..input_dim {
     |             ^^^ help: if this is intentional, prefix it with an underscore: `_dim`

warning: unused variable: `poisson`
    --> src/orchestration/neuromorphic/unified_neuromorphic.rs:1109:17
     |
1109 |             let poisson = Poisson::new((modulated_rate * 0.05).max(0.1)).unwrap();  // Scale for 50ms window
     |                 ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_poisson`

warning: unused variable: `weights`
  --> src/orchestration/neuromorphic/gpu_neuromorphic.rs:53:9
   |
53 |         weights: Option<&[f32]>,
   |         ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_weights`

warning: unused variable: `params`
  --> src/orchestration/neuromorphic/gpu_neuromorphic.rs:78:9
   |
78 |         params: &[(f32, f32, f32, f32)], // (a, b, c, d)
   |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_params`

warning: unused variable: `currents`
  --> src/orchestration/neuromorphic/gpu_neuromorphic.rs:96:61
   |
96 |     pub fn apply_input(&mut self, neuron_indices: &[usize], currents: &[f32]) -> Result<(), OrchestrationError> {
   |                                                             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_currents`

warning: unused variable: `batch_size`
   --> src/orchestration/local_llm/gpu_transformer.rs:254:13
    |
254 |         let batch_size = 1;  // For simplicity, batch_size = 1
    |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_batch_size`

warning: unused variable: `hidden_activated`
   --> src/orchestration/local_llm/gpu_transformer.rs:370:17
    |
370 |         let mut hidden_activated = hidden.clone();
    |                 ^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_hidden_activated`

warning: variable does not need to be mutable
   --> src/orchestration/local_llm/gpu_transformer.rs:370:13
    |
370 |         let mut hidden_activated = hidden.clone();
    |             ----^^^^^^^^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `tda`
   --> src/orchestration/local_llm/attention_analyzer.rs:315:58
    |
315 |         let topology_suggests_collapse = if let Some(ref tda) = self.tda_analyzer {
    |                                                          ^^^ help: if this is intentional, prefix it with an underscore: `_tda`

warning: unused variable: `y`
   --> src/orchestration/local_llm/transfer_entropy_llm.rs:340:35
    |
340 |     fn conditional_entropy(&self, y: usize, x_seq: &[usize]) -> Result<f32> {
    |                                   ^ help: if this is intentional, prefix it with an underscore: `_y`

warning: unused variable: `data`
  --> src/orchestration/local_llm/tda_topology_adapter.rs:23:32
   |
23 |     fn analyze_topology(&self, data: &[f64]) -> Result<TopologyAnalysis> {
   |                                ^^^^ help: if this is intentional, prefix it with an underscore: `_data`

warning: unused variable: `edges`
   --> src/orchestration/decomposition/pid_synergy.rs:846:46
    |
846 |     fn compute_mobius(nodes: &[LatticeNode], edges: &HashMap<usize, Vec<usize>>) -> HashMap<(usize, usize), f64> {
    |                                              ^^^^^ help: if this is intentional, prefix it with an underscore: `_edges`

warning: unused variable: `n_levels`
   --> src/orchestration/inference/hierarchical_active_inference.rs:200:13
    |
200 |         let n_levels = level_dims.len();
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_n_levels`

warning: unused variable: `iteration`
   --> src/orchestration/inference/hierarchical_active_inference.rs:286:13
    |
286 |         for iteration in 0..10 {  // Fixed iterations for now
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_iteration`

warning: value assigned to `total_F` is never read
   --> src/orchestration/inference/hierarchical_active_inference.rs:520:17
    |
520 |         let mut total_F = 0.0;
    |                 ^^^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: unused variable: `i`
   --> src/orchestration/inference/hierarchical_active_inference.rs:568:14
    |
568 |         for (i, policy) in self.action_selection.policies.iter().enumerate() {
    |              ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `state`
   --> src/orchestration/inference/hierarchical_active_inference.rs:664:49
    |
664 |     fn compute_expected_information_gain(&self, state: &DVector<f64>) -> Result<f64, OrchestrationError> {
    |                                                 ^^^^^ help: if this is intentional, prefix it with an underscore: `_state`

warning: unused variable: `query`
   --> src/orchestration/inference/hierarchical_active_inference.rs:817:30
    |
817 | ...                   query: &str,
    |                       ^^^^^ help: if this is intentional, prefix it with an underscore: `_query`

warning: unused variable: `i`
   --> src/orchestration/inference/hierarchical_active_inference.rs:862:14
    |
862 |         for (i, response) in responses.iter().enumerate() {
    |              ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `delay`
   --> src/orchestration/inference/joint_active_inference.rs:604:21
    |
604 |                 let delay = match self.communication.bandwidth.delay_dist {
    |                     ^^^^^ help: if this is intentional, prefix it with an underscore: `_delay`

warning: unused variable: `i`
   --> src/orchestration/inference/joint_active_inference.rs:765:17
    |
765 |             for i in 0..n {
    |                 ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: variable does not need to be mutable
   --> src/orchestration/inference/joint_active_inference.rs:767:21
    |
767 |                 let mut received = proposals.clone();
    |                     ----^^^^^^^^
    |                     |
    |                     help: remove this `mut`

warning: unused variable: `agent`
   --> src/orchestration/inference/joint_active_inference.rs:982:14
    |
982 |         for (agent, agent_policy) in self.agents.iter().zip(&policy.agent_policies) {
    |              ^^^^^ help: if this is intentional, prefix it with an underscore: `_agent`

warning: unused variable: `constraint`
    --> src/orchestration/inference/joint_active_inference.rs:1030:32
     |
1030 |     fn check_constraint(&self, constraint: &CoordinationConstraint, policies: &[AgentPolicy]) -> bool {
     |                                ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_constraint`

warning: unused variable: `policies`
    --> src/orchestration/inference/joint_active_inference.rs:1030:69
     |
1030 |     fn check_constraint(&self, constraint: &CoordinationConstraint, policies: &[AgentPolicy]) -> bool {
     |                                                                     ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_policies`

warning: unused variable: `agent`
    --> src/orchestration/inference/joint_active_inference.rs:1217:13
     |
1217 |         for agent in &self.agents {
     |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_agent`

warning: variable does not need to be mutable
   --> src/orchestration/causality/bidirectional_causality.rs:321:13
    |
321 |         let mut ccm_result = self.convergent_cross_mapping(x_data, y_data)?;
    |             ----^^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `x_curr`
   --> src/orchestration/causality/bidirectional_causality.rs:738:31
    |
738 |         for ((y_next, y_curr, x_curr), p_joint) in &joint_prob {
    |                               ^^^^^^ help: if this is intentional, prefix it with an underscore: `_x_curr`

warning: unused variable: `query`
    --> src/orchestration/causality/bidirectional_causality.rs:1525:67
     |
1525 |     pub fn analyze_llm_causality(&mut self, responses: &[String], query: &str) -> Result<LLMCausalityAnalysis, OrchestrationError> {
     |                                                                   ^^^^^ help: if this is intentional, prefix it with an underscore: `_query`

warning: unused variable: `basis`
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:970:46
    |
970 |     fn compute_classical_correlations(&self, basis: &DMatrix<Complex64>) -> Result<f64, OrchestrationError> {
    |                                              ^^^^^ help: if this is intentional, prefix it with an underscore: `_basis`

warning: unused variable: `op`
   --> src/quantum_mlir/dialect.rs:117:42
    |
117 |             verification: Some(Box::new(|op| {
    |                                          ^^ help: if this is intentional, prefix it with an underscore: `_op`

warning: unused variable: `op`
   --> src/quantum_mlir/dialect.rs:166:42
    |
166 |             verification: Some(Box::new(|op| {
    |                                          ^^ help: if this is intentional, prefix it with an underscore: `_op`

warning: unused variable: `block_size`
  --> src/gpu/gpu_tensor_optimized.rs:69:13
   |
69 |         let block_size = 16;
   |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_block_size`

warning: unused variable: `lda`
  --> src/gpu/production_runtime.rs:59:17
   |
59 |         a: u64, lda: usize,
   |                 ^^^ help: if this is intentional, prefix it with an underscore: `_lda`

warning: unused variable: `ldb`
  --> src/gpu/production_runtime.rs:60:17
   |
60 |         b: u64, ldb: usize,
   |                 ^^^ help: if this is intentional, prefix it with an underscore: `_ldb`

warning: unused variable: `ldc`
  --> src/gpu/production_runtime.rs:62:17
   |
62 |         c: u64, ldc: usize,
   |                 ^^^ help: if this is intentional, prefix it with an underscore: `_ldc`

warning: unnecessary `unsafe` block
  --> src/gpu/cudarc_replacement.rs:45:9
   |
45 |         unsafe {
   |         ^^^^^^ unnecessary `unsafe` block

warning: unnecessary `unsafe` block
  --> src/gpu/cudarc_replacement.rs:63:9
   |
63 |         unsafe {
   |         ^^^^^^ unnecessary `unsafe` block

warning: unnecessary `unsafe` block
  --> src/gpu/cudarc_replacement.rs:78:9
   |
78 |         unsafe {
   |         ^^^^^^ unnecessary `unsafe` block

warning: unused variable: `transa`
   --> src/gpu/cudarc_replacement.rs:162:13
    |
162 |             transa: bool,
    |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_transa`

warning: unused variable: `transb`
   --> src/gpu/cudarc_replacement.rs:163:13
    |
163 |             transb: bool,
    |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_transb`

warning: unused variable: `incx`
   --> src/gpu/cudarc_replacement.rs:194:13
    |
194 |             incx: i32,
    |             ^^^^ help: if this is intentional, prefix it with an underscore: `_incx`

warning: unused variable: `incy`
   --> src/gpu/cudarc_replacement.rs:196:13
    |
196 |             incy: i32,
    |             ^^^^ help: if this is intentional, prefix it with an underscore: `_incy`

warning: unused variable: `regulated`
   --> src/phase6/predictive_neuro.rs:510:13
    |
510 |         let regulated = matrix + reg * Array2::eye(n);
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_regulated`

warning: unused variable: `block_size`
   --> src/phase6/gpu_tda.rs:179:13
    |
179 |         let block_size = 16;
    |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_block_size`

warning: unused variable: `delay`
   --> src/cma/causal_discovery.rs:131:13
    |
131 |         let delay = 1;
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_delay`

warning: unused variable: `beta`
   --> src/cma/quantum/path_integral.rs:143:9
    |
143 |         beta: f64,
    |         ^^^^ help: if this is intentional, prefix it with an underscore: `_beta`

warning: unused variable: `hamiltonian`
   --> src/cma/quantum/pimc_gpu.rs:168:37
    |
168 |     fn hamiltonian_to_matrix(&self, hamiltonian: &ProblemHamiltonian, n_dim: usize) -> Vec<f32> {
    |                                     ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_hamiltonian`

warning: unused variable: `hamiltonian`
   --> src/cma/neural/neural_quantum.rs:511:9
    |
511 |         hamiltonian: &ProblemHamiltonian,
    |         ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_hamiltonian`

warning: unused variable: `hamiltonian`
   --> src/cma/neural/neural_quantum.rs:526:9
    |
526 |         hamiltonian: &ProblemHamiltonian,
    |         ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_hamiltonian`

warning: unused variable: `batch_size`
   --> src/cma/neural/gnn_training.rs:296:9
    |
296 |         batch_size: usize,
    |         ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_batch_size`

warning: unused variable: `learning_rate`
   --> src/cma/neural/gnn_training.rs:777:9
    |
777 |         learning_rate: f64,
    |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_learning_rate`

warning: unused variable: `source_model`
   --> src/cma/neural/gnn_transfer_learning.rs:434:9
    |
434 |         source_model: &E3EquivariantGNN,
    |         ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_source_model`

warning: unused variable: `trained_model`
   --> src/cma/neural/gnn_transfer_learning.rs:518:13
    |
518 |         let trained_model = trainer.get_model();
    |             ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_trained_model`

warning: unused variable: `ensembles`
   --> src/cma/neural/gnn_transfer_learning.rs:702:9
    |
702 |         ensembles: &[Ensemble],
    |         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_ensembles`

warning: unused variable: `manifolds`
   --> src/cma/neural/gnn_transfer_learning.rs:703:9
    |
703 |         manifolds: &[CausalManifold],
    |         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_manifolds`

warning: unused variable: `model`
   --> src/cma/neural/gnn_training_pipeline.rs:478:9
    |
478 |         model: &E3EquivariantGNN,
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_model`

warning: unused variable: `i`
   --> src/cma/neural/gnn_training_pipeline.rs:674:14
    |
674 |         for (i, metric) in metrics.iter().enumerate() {
    |              ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `rng`
  --> src/cma/gpu_integration.rs:76:13
   |
76 |         let rng = ChaCha20Rng::seed_from_u64(seed);
   |             ^^^ help: if this is intentional, prefix it with an underscore: `_rng`

warning: unnecessary `unsafe` block
   --> src/cma/gpu_integration.rs:158:13
    |
158 |             unsafe {
    |             ^^^^^^ unnecessary `unsafe` block

warning: unused variable: `n`
  --> src/cma/transfer_entropy_gpu.rs:63:13
   |
63 |         let n = source.len();
   |             ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: unused variable: `psi`
   --> src/cma/pac_bayes.rs:208:13
    |
208 |         let psi = |x: f64| -> f64 {
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_psi`

warning: unused variable: `train_data`
   --> src/cma/conformal_prediction.rs:210:14
    |
210 |         let (train_data, calib_data) = proper_training_data.split_at(split_point);
    |              ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_train_data`

warning: unused variable: `candidates`
   --> src/cma/conformal_prediction.rs:389:58
    |
389 |     fn compute_efficiency(&self, prediction_set: &[f64], candidates: &[f64]) -> f64 {
    |                                                          ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_candidates`

warning: unused variable: `x`
   --> src/cma/conformal_prediction.rs:474:35
    |
474 |     fn predict_uncertainty(&self, x: &Array1<f64>) -> Result<f64> {
    |                                   ^ help: if this is intentional, prefix it with an underscore: `_x`

warning: unused variable: `history`
   --> src/applications/robotics/trajectory_forecasting.rs:253:17
    |
253 |             let history = vec![TrajectoryPoint {
    |                 ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_history`

warning: unused variable: `historical_interactions`
   --> src/applications/robotics/trajectory_forecasting.rs:240:9
    |
240 |         historical_interactions: &[InteractionHistory],
    |         ^^^^^^^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_historical_interactions`

warning: unused variable: `protein_smiles`
  --> src/chemistry/gpu_docking.rs:35:9
   |
35 |         protein_smiles: &str,
   |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_protein_smiles`

warning: unused variable: `x_arr`
   --> src/time_series/lstm_forecaster.rs:362:13
    |
362 |         let x_arr = Array1::from(input_vec);
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_x_arr`

warning: unused variable: `variance`
   --> src/finance/portfolio_optimizer.rs:288:17
    |
288 |             let variance = self.compute_portfolio_variance(&weights, covariance);
    |                 ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_variance`

warning: value assigned to `temperature` is never read
   --> src/finance/thermodynamic_consensus.rs:190:17
    |
190 |         let mut temperature = self.config.temperature;
    |                 ^^^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: unused variable: `key`
   --> src/api_server/advanced_info_theory.rs:140:13
    |
140 |         let key = (hash_sequence(&x_history), hash_sequence(&y_prev_history), y_current);
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_key`

warning: unused variable: `y_recent`
   --> src/api_server/advanced_info_theory.rs:350:9
    |
350 |     let y_recent = if y_history.is_empty() {
    |         ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_y_recent`

warning: unused variable: `sharpe`
  --> src/api_server/portfolio.rs:86:17
   |
86 |             let sharpe = (portfolio_return - self.risk_free_rate) / portfolio_risk;
   |                 ^^^^^^ help: if this is intentional, prefix it with an underscore: `_sharpe`

warning: unused variable: `params`
   --> src/assistant/autonomous_agent.rs:220:55
    |
220 |     pub fn call_robotics_tool(&self, operation: &str, params: serde_json::Value) -> Result<ToolResult> {
    |                                                       ^^^^^^ help: if this is intentional, prefix it with an underscore: `_params`

warning: unused variable: `params`
   --> src/assistant/autonomous_agent.rs:243:58
    |
243 |     pub fn call_time_series_tool(&self, operation: &str, params: serde_json::Value) -> Result<ToolResult> {
    |                                                          ^^^^^^ help: if this is intentional, prefix it with an underscore: `_params`

warning: unused variable: `batch_size`
   --> src/assistant/local_llm/gpu_transformer.rs:254:13
    |
254 |         let batch_size = 1;  // For simplicity, batch_size = 1
    |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_batch_size`

warning: unused variable: `hidden_activated`
   --> src/assistant/local_llm/gpu_transformer.rs:370:17
    |
370 |         let mut hidden_activated = hidden.clone();
    |                 ^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_hidden_activated`

warning: variable does not need to be mutable
   --> src/assistant/local_llm/gpu_transformer.rs:370:13
    |
370 |         let mut hidden_activated = hidden.clone();
    |             ----^^^^^^^^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: type `LLMStatistics` is more private than the item `BanditLLMEnsemble::get_statistics`
   --> src/orchestration/llm_clients/ensemble.rs:207:5
    |
207 |     pub fn get_statistics(&self) -> Vec<LLMStatistics> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method `BanditLLMEnsemble::get_statistics` is reachable at visibility `pub`
    |
note: but type `LLMStatistics` is only usable at visibility `pub(self)`
   --> src/orchestration/llm_clients/ensemble.rs:45:1
    |
 45 | struct LLMStatistics {
    | ^^^^^^^^^^^^^^^^^^^^
    = note: `#[warn(private_interfaces)]` on by default

warning: type `mission_charlie_integration::IntegrationMetrics` is more private than the item `DiagnosticReport::performance_metrics`
   --> src/orchestration/integration/mission_charlie_integration.rs:578:5
    |
578 |     pub performance_metrics: IntegrationMetrics,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ field `DiagnosticReport::performance_metrics` is reachable at visibility `pub`
    |
note: but type `mission_charlie_integration::IntegrationMetrics` is only usable at visibility `pub(self)`
   --> src/orchestration/integration/mission_charlie_integration.rs:73:1
    |
 73 | struct IntegrationMetrics {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: type `Geodesic` is more private than the item `GeometricManifoldOptimizer::compute_geodesic`
    --> src/orchestration/optimization/geometric_manifold.rs:1148:5
     |
1148 |     pub fn compute_geodesic(&mut self, start: &DVector<f64>, end: &DVector<f64>) -> Result<Geodesic, OrchestrationError> {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method `GeometricManifoldOptimizer::compute_geodesic` is reachable at visibility `pub`
     |
note: but type `Geodesic` is only usable at visibility `pub(self)`
    --> src/orchestration/optimization/geometric_manifold.rs:286:1
     |
 286 | struct Geodesic {
     | ^^^^^^^^^^^^^^^

warning: type `Geodesic` is more private than the item `GeometricManifoldOptimizer::parallel_transport`
    --> src/orchestration/optimization/geometric_manifold.rs:1327:5
     |
1327 |     pub fn parallel_transport(&mut self, vector: &DVector<f64>, geodesic: &Geodesic) -> Result<DVector<f64>, OrchestrationError> {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method `GeometricManifoldOptimizer::parallel_transport` is reachable at visibility `pub`
     |
note: but type `Geodesic` is only usable at visibility `pub(self)`
    --> src/orchestration/optimization/geometric_manifold.rs:286:1
     |
 286 | struct Geodesic {
     | ^^^^^^^^^^^^^^^

warning: type `GpuEmbeddings` is more private than the item `GpuKSGEstimator::create_embeddings`
   --> src/cma/transfer_entropy_gpu.rs:223:5
    |
223 |     pub fn create_embeddings(&self, source: &TimeSeries, target: &TimeSeries) -> Result<GpuEmbeddings> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method `GpuKSGEstimator::create_embeddings` is reachable at visibility `pub`
    |
note: but type `GpuEmbeddings` is only usable at visibility `pub(self)`
   --> src/cma/transfer_entropy_gpu.rs:303:1
    |
303 | struct GpuEmbeddings {
    | ^^^^^^^^^^^^^^^^^^^^

warning: field `n_conditioning` is never read
  --> src/information_theory/conditional_te.rs:54:5
   |
46 | pub struct ConditionalTE {
   |            ------------- field in this struct
...
54 |     n_conditioning: usize,
   |     ^^^^^^^^^^^^^^
   |
   = note: `ConditionalTE` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` on by default

warning: field `dimensions` is never read
  --> src/information_theory/memory_efficient.rs:32:5
   |
26 | pub struct SparseHistogram {
   |            --------------- field in this struct
...
32 |     dimensions: usize,
   |     ^^^^^^^^^^
   |
   = note: `SparseHistogram` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `dimensions` is never read
   --> src/information_theory/memory_efficient.rs:264:5
    |
258 | pub struct CompressedHistogram {
    |            ------------------- field in this struct
...
264 |     dimensions: usize,
    |     ^^^^^^^^^^

warning: field `config` is never read
  --> src/information_theory/gpu_transfer_entropy.rs:17:5
   |
16 | pub struct GpuTransferEntropy {
   |            ------------------ field in this struct
17 |     config: TransferEntropy,
   |     ^^^^^^

warning: field `n_sources` is never read
   --> src/information_theory/multivariate_te.rs:422:5
    |
414 | struct MultivariateEmbeddings {
    |        ---------------------- field in this struct
...
422 |     n_sources: usize,
    |     ^^^^^^^^^
    |
    = note: `MultivariateEmbeddings` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `init_kernel` is never read
  --> src/statistical_mechanics/gpu.rs:27:5
   |
23 | pub struct ThermodynamicGpu {
   |            ---------------- field in this struct
...
27 |     init_kernel: Arc<CudaFunction>,
   |     ^^^^^^^^^^^

warning: fields `precision_weight_kernel`, `axpby_kernel`, `velocity_update_kernel`, and `hierarchical_project_kernel` are never read
  --> src/active_inference/gpu.rs:31:5
   |
24 | pub struct ActiveInferenceGpu {
   |            ------------------ fields in this struct
...
31 |     precision_weight_kernel: Arc<CudaFunction>,
   |     ^^^^^^^^^^^^^^^^^^^^^^^
...
35 |     axpby_kernel: Arc<CudaFunction>,
   |     ^^^^^^^^^^^^
36 |     velocity_update_kernel: Arc<CudaFunction>,
   |     ^^^^^^^^^^^^^^^^^^^^^^
37 |     hierarchical_project_kernel: Arc<CudaFunction>,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: field `rng_init_kernel` is never read
   --> src/active_inference/gpu_policy_eval.rs:105:5
    |
 96 | pub struct GpuPolicyEvaluator {
    |            ------------------ field in this struct
...
105 |     rng_init_kernel: Arc<CudaFunction>,
    |     ^^^^^^^^^^^^^^^
    |
    = note: `GpuPolicyEvaluator` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: field `config` is never read
   --> src/active_inference/hierarchical_inference_gpu.rs:111:5
    |
107 | pub struct HierarchicalActiveInferenceGpu {
    |            ------------------------------ field in this struct
...
111 |     config: HierarchicalConfig,
    |     ^^^^^^

warning: field `cuda_context` is never read
   --> src/integration/unified_platform.rs:162:5
    |
160 | pub struct UnifiedPlatform {
    |            --------------- field in this struct
161 |     /// Shared CUDA context (GPU resources)
162 |     cuda_context: Arc<CudaContext>,
    |     ^^^^^^^^^^^^

warning: field `num_qubits` is never read
  --> src/integration/quantum_mlir_integration.rs:24:5
   |
18 | pub struct QuantumMlirIntegration {
   |            ---------------------- field in this struct
...
24 |     num_qubits: usize,
   |     ^^^^^^^^^^

warning: method `calculate_coherence` is never used
   --> src/integration/quantum_mlir_integration.rs:204:8
    |
 37 | impl QuantumMlirIntegration {
    | --------------------------- method in this implementation
...
204 |     fn calculate_coherence(&self, state: &QuantumState) -> f64 {
    |        ^^^^^^^^^^^^^^^^^^^

warning: fields `constraint_weights_gpu`, `gnn_weights_gpu`, and `hamiltonian_gpu` are never read
  --> src/integration/multi_modal_reasoner.rs:49:5
   |
44 | pub struct MultiModalReasoner {
   |            ------------------ fields in this struct
...
49 |     constraint_weights_gpu: Option<CudaSlice<f32>>,
   |     ^^^^^^^^^^^^^^^^^^^^^^
...
52 |     gnn_weights_gpu: Option<Vec<CudaSlice<f32>>>,
   |     ^^^^^^^^^^^^^^^
...
55 |     hamiltonian_gpu: Option<CudaSlice<f32>>,
   |     ^^^^^^^^^^^^^^^

warning: field `id` is never read
  --> src/optimization/memory_optimizer.rs:48:5
   |
42 | pub struct PinnedBuffer {
   |            ------------ field in this struct
...
48 |     id: usize,
   |     ^^

warning: fields `buffer_size` and `num_buffers` are never read
  --> src/optimization/memory_optimizer.rs:92:5
   |
86 | pub struct PinnedMemoryPool {
   |            ---------------- fields in this struct
...
92 |     buffer_size: usize,
   |     ^^^^^^^^^^^
93 |     /// Total number of buffers
94 |     num_buffers: usize,
   |     ^^^^^^^^^^^

warning: field `id` is never read
  --> src/orchestration/llm_clients/openai_client.rs:62:5
   |
61 | struct OpenAIResponse {
   |        -------------- field in this struct
62 |     id: String,
   |     ^^
   |
   = note: `OpenAIResponse` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `id` is never read
  --> src/orchestration/llm_clients/claude_client.rs:43:5
   |
42 | struct ClaudeResponse {
   |        -------------- field in this struct
43 |     id: String,
   |     ^^
   |
   = note: `ClaudeResponse` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: field `timestamp` is never read
  --> src/orchestration/llm_clients/claude_client.rs:64:5
   |
62 | struct CachedResponse {
   |        -------------- field in this struct
63 |     response: LLMResponse,
64 |     timestamp: SystemTime,
   |     ^^^^^^^^^
   |
   = note: `CachedResponse` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: field `timestamp` is never read
  --> src/orchestration/llm_clients/gemini_client.rs:84:5
   |
82 | struct CachedResponse {
   |        -------------- field in this struct
83 |     response: LLMResponse,
84 |     timestamp: SystemTime,
   |     ^^^^^^^^^
   |
   = note: `CachedResponse` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: field `timestamp` is never read
  --> src/orchestration/llm_clients/grok_client.rs:61:5
   |
59 | struct CachedResponse {
   |        -------------- field in this struct
60 |     response: LLMResponse,
61 |     timestamp: SystemTime,
   |     ^^^^^^^^^
   |
   = note: `CachedResponse` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: field `model_name` is never read
  --> src/orchestration/llm_clients/ensemble.rs:46:5
   |
45 | struct LLMStatistics {
   |        ------------- field in this struct
46 |     model_name: String,
   |     ^^^^^^^^^^
   |
   = note: `LLMStatistics` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: field `model_priors` is never read
   --> src/orchestration/llm_clients/ensemble.rs:235:5
    |
228 | pub struct BayesianLLMEnsemble {
    |            ------------------- field in this struct
...
235 |     model_priors: Array1<f64>,
    |     ^^^^^^^^^^^^

warning: field `uncertainty_threshold` is never read
   --> src/orchestration/llm_clients/ensemble.rs:413:5
    |
405 | pub struct LLMOrchestrator {
    |            --------------- field in this struct
...
413 |     uncertainty_threshold: f64,
    |     ^^^^^^^^^^^^^^^^^^^^^

warning: field `cuda_context` is never read
  --> src/orchestration/thermodynamic/gpu_thermodynamic_consensus.rs:47:5
   |
45 | pub struct GpuThermodynamicConsensus {
   |            ------------------------- field in this struct
46 |     gpu_executor: Arc<std::sync::Mutex<GpuKernelExecutor>>,
47 |     cuda_context: Arc<CudaContext>,
   |     ^^^^^^^^^^^^

warning: field `timestamp` is never read
   --> src/orchestration/thermodynamic/advanced_energy.rs:154:5
    |
149 | struct EnergyRecord {
    |        ------------ field in this struct
...
154 |     timestamp: std::time::Instant,
    |     ^^^^^^^^^
    |
    = note: `EnergyRecord` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `token_predictor` is never read
  --> src/orchestration/active_inference/hierarchical_client.rs:34:5
   |
26 | pub struct HierarchicalActiveInferenceClient {
   |            --------------------------------- field in this struct
...
34 |     token_predictor: Option<TokenPredictor>,
   |     ^^^^^^^^^^^^^^^

warning: field `predicted_tokens` is never read
  --> src/orchestration/active_inference/hierarchical_client.rs:56:5
   |
55 | struct TokenPredictor {
   |        -------------- field in this struct
56 |     predicted_tokens: Vec<String>,
   |     ^^^^^^^^^^^^^^^^

warning: fields `mdl_optimizer` and `pwsa_bridge` are never read
  --> src/orchestration/integration/mission_charlie_integration.rs:39:5
   |
33 | pub struct MissionCharlieIntegration {
   |            ------------------------- fields in this struct
...
39 |     mdl_optimizer: MDLPromptOptimizer,
   |     ^^^^^^^^^^^^^
...
43 |     pwsa_bridge: PWSAIntegrationBridge,
   |     ^^^^^^^^^^^

warning: field `synergy` is never read
  --> src/orchestration/integration/mission_charlie_integration.rs:79:5
   |
73 | struct IntegrationMetrics {
   |        ------------------ field in this struct
...
79 |     synergy: HashMap<(String, String), f64>,
   |     ^^^^^^^
   |
   = note: `IntegrationMetrics` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `gpu_backend` is never read
   --> src/orchestration/integration/prism_ai_integration.rs:109:5
    |
 88 | pub struct PrismAIOrchestrator {
    |            ------------------- field in this struct
...
109 |     gpu_backend: Arc<RwLock<GpuBackend>>,
    |     ^^^^^^^^^^^

warning: field `feature_importance` is never read
  --> src/orchestration/optimization/mdl_prompt_optimizer.rs:18:5
   |
16 | pub struct MDLPromptOptimizer {
   |            ------------------ field in this struct
17 |     /// Feature importance (learned from historical queries)
18 |     feature_importance: HashMap<String, f64>,
   |     ^^^^^^^^^^^^^^^^^^

warning: field `curvature` is never read
  --> src/orchestration/optimization/geometric_manifold.rs:25:5
   |
13 | pub struct GeometricManifoldOptimizer {
   |            -------------------------- field in this struct
...
25 |     curvature: CurvatureAnalyzer,
   |     ^^^^^^^^^

warning: field `chart` is never read
  --> src/orchestration/optimization/geometric_manifold.rs:44:5
   |
32 | struct RiemannianManifold {
   |        ------------------ field in this struct
...
44 |     chart: LocalChart,
   |     ^^^^^
   |
   = note: `RiemannianManifold` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: fields `g_inv` and `det_g` are never read
  --> src/orchestration/optimization/geometric_manifold.rs:64:5
   |
60 | struct MetricTensor {
   |        ------------ fields in this struct
...
64 |     g_inv: Box<dyn Fn(&DVector<f64>) -> DMatrix<f64> + Send + Sync>,
   |     ^^^^^
65 |     /// Determinant of metric
66 |     det_g: Box<dyn Fn(&DVector<f64>) -> f64 + Send + Sync>,
   |     ^^^^^

warning: fields `grad_h` and `hess_h` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:103:5
    |
 99 | struct ManifoldConstraint {
    |        ------------------ fields in this struct
...
103 |     grad_h: fn(&DVector<f64>) -> DVector<f64>,
    |     ^^^^^^
104 |     /// Hessian of constraint
105 |     hess_h: fn(&DVector<f64>) -> DMatrix<f64>,
    |     ^^^^^^
    |
    = note: `ManifoldConstraint` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `domain`, `phi`, `phi_inv`, and `d_phi` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:112:5
    |
110 | struct LocalChart {
    |        ---------- fields in this struct
111 |     /// Chart domain
112 |     domain: Domain,
    |     ^^^^^^
113 |     /// Coordinate map
114 |     phi: fn(&DVector<f64>) -> DVector<f64>,
    |     ^^^
115 |     /// Inverse map
116 |     phi_inv: fn(&DVector<f64>) -> DVector<f64>,
    |     ^^^^^^^
117 |     /// Jacobian of coordinate map
118 |     d_phi: fn(&DVector<f64>) -> DMatrix<f64>,
    |     ^^^^^
    |
    = note: `LocalChart` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `lower` and `upper` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:124:5
    |
122 | struct Domain {
    |        ------ fields in this struct
123 |     /// Lower bounds
124 |     lower: DVector<f64>,
    |     ^^^^^
125 |     /// Upper bounds
126 |     upper: DVector<f64>,
    |     ^^^^^
    |
    = note: `Domain` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `line_search` and `trust_region` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:139:5
    |
131 | struct ManifoldOptimizer {
    |        ----------------- fields in this struct
...
139 |     line_search: LineSearchMethod,
    |     ^^^^^^^^^^^
140 |     /// Trust region parameters
141 |     trust_region: TrustRegionParams,
    |     ^^^^^^^^^^^^
    |
    = note: `ManifoldOptimizer` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: multiple variants are never constructed
   --> src/orchestration/optimization/geometric_manifold.rs:146:5
    |
145 | enum OptimizationAlgorithm {
    |      --------------------- variants in this enum
146 |     RiemannianGradientDescent,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
147 |     RiemannianConjugateGradient,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
148 |     RiemannianNewton,
    |     ^^^^^^^^^^^^^^^^
149 |     RiemannianQuasiNewton,
    |     ^^^^^^^^^^^^^^^^^^^^^
150 |     RiemannianTrustRegion,
    |     ^^^^^^^^^^^^^^^^^^^^^
151 |     NaturalGradientDescent,
    |     ^^^^^^^^^^^^^^^^^^^^^^
152 |     RiemannianAdam,
153 |     RiemannianLBFGS,
    |     ^^^^^^^^^^^^^^^
    |
    = note: `OptimizationAlgorithm` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Fixed`, `LineSearch`, and `Armijo` are never constructed
   --> src/orchestration/optimization/geometric_manifold.rs:158:5
    |
157 | enum StepSizeSchedule {
    |      ---------------- variants in this enum
158 |     Fixed(f64),
    |     ^^^^^
159 |     Adaptive(AdaptiveSchedule),
160 |     LineSearch,
    |     ^^^^^^^^^^
161 |     Armijo,
    |     ^^^^^^
    |
    = note: `StepSizeSchedule` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `min_step` is never read
   --> src/orchestration/optimization/geometric_manifold.rs:168:5
    |
165 | struct AdaptiveSchedule {
    |        ---------------- field in this struct
...
168 |     min_step: f64,
    |     ^^^^^^^^
    |
    = note: `AdaptiveSchedule` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `f_tol` and `x_tol` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:178:5
    |
172 | struct ConvergenceCriteria {
    |        ------------------- fields in this struct
...
178 |     f_tol: f64,
    |     ^^^^^
179 |     /// Step size tolerance
180 |     x_tol: f64,
    |     ^^^^^
    |
    = note: `ConvergenceCriteria` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Backtracking`, `WolfeConditions`, and `NonmonotoneLineSearch` are never constructed
   --> src/orchestration/optimization/geometric_manifold.rs:185:5
    |
184 | enum LineSearchMethod {
    |      ---------------- variants in this enum
185 |     Backtracking,
    |     ^^^^^^^^^^^^
186 |     WolfeConditions,
    |     ^^^^^^^^^^^^^^^
187 |     StrongWolfe,
188 |     NonmonotoneLineSearch,
    |     ^^^^^^^^^^^^^^^^^^^^^
    |
    = note: `LineSearchMethod` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `delta`, `delta_max`, `eta_1`, and `eta_2` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:194:5
    |
192 | struct TrustRegionParams {
    |        ----------------- fields in this struct
193 |     /// Initial trust region radius
194 |     delta: f64,
    |     ^^^^^
195 |     /// Maximum radius
196 |     delta_max: f64,
    |     ^^^^^^^^^
197 |     /// Radius update parameters
198 |     eta_1: f64,
    |     ^^^^^
199 |     eta_2: f64,
    |     ^^^^^
    |
    = note: `TrustRegionParams` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `lambda`, `diagonal`, and `kfac` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:208:5
    |
204 | struct NaturalGradient {
    |        --------------- fields in this struct
...
208 |     lambda: f64,
    |     ^^^^^^
209 |     /// Use diagonal approximation
210 |     diagonal: bool,
    |     ^^^^^^^^
211 |     /// Use KFAC approximation
212 |     kfac: bool,
    |     ^^^^
    |
    = note: `NaturalGradient` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `F_diag`, `A`, and `G` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:222:5
    |
218 | struct FisherInformation {
    |        ----------------- fields in this struct
...
222 |     F_diag: DVector<f64>,
    |     ^^^^^^
223 |     /// KFAC factors
224 |     A: Option<DMatrix<f64>>,
    |     ^
225 |     G: Option<DMatrix<f64>>,
    |     ^
    |
    = note: `FisherInformation` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `integration` is never read
   --> src/orchestration/optimization/geometric_manifold.rs:234:5
    |
232 | struct GeodesicSolver {
    |        -------------- field in this struct
233 |     /// Integration method
234 |     integration: IntegrationMethod,
    |     ^^^^^^^^^^^
    |
    = note: `GeodesicSolver` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `DormandPrince`, `SymplecticEuler`, and `Verlet` are never constructed
   --> src/orchestration/optimization/geometric_manifold.rs:246:5
    |
244 | enum IntegrationMethod {
    |      ----------------- variants in this enum
245 |     RungeKutta4,
246 |     DormandPrince,
    |     ^^^^^^^^^^^^^
247 |     SymplecticEuler,
    |     ^^^^^^^^^^^^^^^
248 |     Verlet,
    |     ^^^^^^
    |
    = note: `IntegrationMethod` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `max_iter` is never read
   --> src/orchestration/optimization/geometric_manifold.rs:258:5
    |
252 | struct BVPSolver {
    |        --------- field in this struct
...
258 |     max_iter: usize,
    |     ^^^^^^^^
    |
    = note: `BVPSolver` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `FiniteDifference` and `Collocation` are never constructed
   --> src/orchestration/optimization/geometric_manifold.rs:264:5
    |
262 | enum BVPMethod {
    |      --------- variants in this enum
263 |     Shooting,
264 |     FiniteDifference,
    |     ^^^^^^^^^^^^^^^^
265 |     Collocation,
    |     ^^^^^^^^^^^
    |
    = note: `BVPMethod` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `velocity_search` and `newton_tol` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:271:5
    |
269 | struct ShootingMethod {
    |        -------------- fields in this struct
270 |     /// Initial velocity search
271 |     velocity_search: VelocitySearch,
    |     ^^^^^^^^^^^^^^^
272 |     /// Newton iterations
273 |     newton_tol: f64,
    |     ^^^^^^^^^^
    |
    = note: `ShootingMethod` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `GradientDescent` and `ParticleSwarm` are never constructed
   --> src/orchestration/optimization/geometric_manifold.rs:281:5
    |
279 | enum VelocitySearch {
    |      -------------- variants in this enum
280 |     Newton,
281 |     GradientDescent,
    |     ^^^^^^^^^^^^^^^
282 |     ParticleSwarm,
    |     ^^^^^^^^^^^^^
    |
    = note: `VelocitySearch` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `start` is never read
   --> src/orchestration/optimization/geometric_manifold.rs:288:5
    |
286 | struct Geodesic {
    |        -------- field in this struct
287 |     /// Starting point
288 |     start: DVector<f64>,
    |     ^^^^^
    |
    = note: `Geodesic` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `pole_params` and `cache` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:307:5
    |
301 | struct ParallelTransport {
    |        ----------------- fields in this struct
...
307 |     pole_params: PoleLadder,
    |     ^^^^^^^^^^^
308 |     /// Transport cache
309 |     cache: HashMap<u64, DMatrix<f64>>,
    |     ^^^^^
    |
    = note: `ParallelTransport` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `PoleLadder`, `FermiWalker`, and `LieTransport` are never constructed
   --> src/orchestration/optimization/geometric_manifold.rs:315:5
    |
313 | enum TransportMethod {
    |      --------------- variants in this enum
314 |     SchildLadder,
315 |     PoleLadder,
    |     ^^^^^^^^^^
316 |     FermiWalker,
    |     ^^^^^^^^^^^
317 |     LieTransport,
    |     ^^^^^^^^^^^^
    |
    = note: `TransportMethod` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `order` is never read
   --> src/orchestration/optimization/geometric_manifold.rs:325:5
    |
321 | struct SchildLadder {
    |        ------------ field in this struct
...
325 |     order: usize,
    |     ^^^^^
    |
    = note: `SchildLadder` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `pole` and `retraction` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:331:5
    |
329 | struct PoleLadder {
    |        ---------- fields in this struct
330 |     /// Pole point
331 |     pole: Option<DVector<f64>>,
    |     ^^^^
332 |     /// Retraction type
333 |     retraction: RetractionType,
    |     ^^^^^^^^^^
    |
    = note: `PoleLadder` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Cayley` and `Projection` are never constructed
   --> src/orchestration/optimization/geometric_manifold.rs:339:5
    |
337 | enum RetractionType {
    |      -------------- variants in this enum
338 |     Exponential,
339 |     Cayley,
    |     ^^^^^^
340 |     Projection,
    |     ^^^^^^^^^^
    |
    = note: `RetractionType` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `riemann`, `ricci`, `scalar`, and `sectional` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:347:5
    |
345 | struct CurvatureAnalyzer {
    |        ----------------- fields in this struct
346 |     /// Riemann curvature tensor
347 |     riemann: RiemannTensor,
    |     ^^^^^^^
348 |     /// Ricci curvature
349 |     ricci: RicciCurvature,
    |     ^^^^^
350 |     /// Scalar curvature
351 |     scalar: ScalarCurvature,
    |     ^^^^^^
352 |     /// Sectional curvatures
353 |     sectional: SectionalCurvatures,
    |     ^^^^^^^^^
    |
    = note: `CurvatureAnalyzer` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `components` and `symmetries` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:359:5
    |
357 | struct RiemannTensor {
    |        ------------- fields in this struct
358 |     /// R^l_ijk components
359 |     components: HashMap<(usize, usize, usize, usize), f64>,
    |     ^^^^^^^^^^
360 |     /// Symmetries
361 |     symmetries: TensorSymmetries,
    |     ^^^^^^^^^^
    |
    = note: `RiemannTensor` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `antisym_12`, `antisym_34`, `interchange`, and `bianchi` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:366:5
    |
365 | struct TensorSymmetries {
    |        ---------------- fields in this struct
366 |     antisym_12: bool,
    |     ^^^^^^^^^^
367 |     antisym_34: bool,
    |     ^^^^^^^^^^
368 |     interchange: bool,
    |     ^^^^^^^^^^^
369 |     bianchi: bool,
    |     ^^^^^^^
    |
    = note: `TensorSymmetries` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `tensor` and `eigenvalues` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:375:5
    |
373 | struct RicciCurvature {
    |        -------------- fields in this struct
374 |     /// Ricci tensor R_ij
375 |     tensor: DMatrix<f64>,
    |     ^^^^^^
376 |     /// Eigenvalues
377 |     eigenvalues: DVector<f64>,
    |     ^^^^^^^^^^^
    |
    = note: `RicciCurvature` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `value` and `gradient` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:383:5
    |
381 | struct ScalarCurvature {
    |        --------------- fields in this struct
382 |     /// Scalar curvature value
383 |     value: f64,
    |     ^^^^^
384 |     /// Gradient of scalar curvature
385 |     gradient: DVector<f64>,
    |     ^^^^^^^^
    |
    = note: `ScalarCurvature` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `curvatures` and `principal` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:391:5
    |
389 | struct SectionalCurvatures {
    |        ------------------- fields in this struct
390 |     /// Sectional curvatures for 2-planes
391 |     curvatures: HashMap<(usize, usize), f64>,
    |     ^^^^^^^^^^
392 |     /// Principal curvatures
393 |     principal: Vec<f64>,
    |     ^^^^^^^^^
    |
    = note: `SectionalCurvatures` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `f_decrease`, `step_norm`, and `constraint_violation` are never read
   --> src/orchestration/optimization/geometric_manifold.rs:416:5
    |
412 | struct ConvergenceMetrics {
    |        ------------------ fields in this struct
...
416 |     f_decrease: f64,
    |     ^^^^^^^^^^
417 |     /// Step norm
418 |     step_norm: f64,
    |     ^^^^^^^^^
419 |     /// Constraint violation
420 |     constraint_violation: f64,
    |     ^^^^^^^^^^^^^^^^^^^^
    |
    = note: `ConvergenceMetrics` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `timestamp` is never read
  --> src/orchestration/caching/quantum_semantic_cache.rs:43:5
   |
39 | struct CachedEntry {
   |        ----------- field in this struct
...
43 |     timestamp: SystemTime,
   |     ^^^^^^^^^
   |
   = note: `CachedEntry` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: field `model_name` is never read
  --> src/orchestration/routing/thermodynamic_balancer.rs:30:5
   |
29 | struct LLMPerformanceProfile {
   |        --------------------- field in this struct
30 |     model_name: String,
   |     ^^^^^^^^^^
   |
   = note: `LLMPerformanceProfile` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: method `extract_core_concept` is never used
   --> src/orchestration/routing/thermodynamic_balancer.rs:296:8
    |
164 | impl QuantumVotingConsensus {
    | --------------------------- method in this implementation
...
296 |     fn extract_core_concept(&self, response: &str) -> String {
    |        ^^^^^^^^^^^^^^^^^^^^

warning: field `timestamp` is never read
  --> src/orchestration/routing/transfer_entropy_router.rs:62:5
   |
56 | struct RoutingHistory {
   |        -------------- field in this struct
...
62 |     timestamp: u64,
   |     ^^^^^^^^^

warning: field `enable_domain` is never read
  --> src/orchestration/routing/transfer_entropy_router.rs:86:5
   |
84 | struct FeatureConfig {
   |        ------------- field in this struct
85 |     /// Enable domain detection
86 |     enable_domain: bool,
   |     ^^^^^^^^^^^^^
   |
   = note: `FeatureConfig` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `cuda_context` is never read
  --> src/orchestration/routing/gpu_transfer_entropy_router.rs:93:5
   |
91 | pub struct GpuTransferEntropyRouter {
   |            ------------------------ field in this struct
92 |     gpu_executor: Arc<std::sync::Mutex<GpuKernelExecutor>>,
93 |     cuda_context: Arc<CudaContext>,
   |     ^^^^^^^^^^^^

warning: fields `time` and `amplitude` are never read
   --> src/orchestration/neuromorphic/spike_consensus.rs:108:5
    |
107 | struct Spike {
    |        ----- fields in this struct
108 |     time: f64,
    |     ^^^^
109 |     amplitude: f64,
    |     ^^^^^^^^^

warning: field `neuron_type` is never read
  --> src/orchestration/neuromorphic/unified_neuromorphic.rs:61:5
   |
50 | struct IzhikevichNeuron {
   |        ---------------- field in this struct
...
61 |     neuron_type: NeuronType,
   |     ^^^^^^^^^^^
   |
   = note: `IzhikevichNeuron` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `LowThreshold` and `Resonator` are never constructed
  --> src/orchestration/neuromorphic/unified_neuromorphic.rs:75:5
   |
71 | enum NeuronType {
   |      ---------- variants in this enum
...
75 |     LowThreshold,        // LTS interneurons
   |     ^^^^^^^^^^^^
76 |     Resonator,           // Resonator neurons
   |     ^^^^^^^^^
   |
   = note: `NeuronType` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `delay` is never read
  --> src/orchestration/neuromorphic/unified_neuromorphic.rs:90:5
   |
82 | struct Synapse {
   |        ------- field in this struct
...
90 |     delay: f64,
   |     ^^^^^
   |
   = note: `Synapse` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Static`, `ShortTerm`, `Homeostatic`, and `Neuromodulated` are never constructed
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:103:5
    |
102 | enum PlasticityType {
    |      -------------- variants in this enum
103 |     Static,
    |     ^^^^^^
104 |     STDP,
105 |     ShortTerm,
    |     ^^^^^^^^^
106 |     Homeostatic,
    |     ^^^^^^^^^^^
107 |     Neuromodulated,
    |     ^^^^^^^^^^^^^^
    |
    = note: `PlasticityType` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `tau_F` and `tau_D` are never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:118:5
    |
112 | struct STPState {
    |        -------- fields in this struct
...
118 |     tau_F: f64,
    |     ^^^^^
119 |     tau_D: f64,
    |     ^^^^^
    |
    = note: `STPState` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `layer_type` is never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:128:5
    |
124 | struct Layer {
    |        ----- field in this struct
...
128 |     layer_type: LayerType,
    |     ^^^^^^^^^^
    |
    = note: `Layer` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variant `Reservoir` is never constructed
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:138:5
    |
134 | enum LayerType {
    |      --------- variant in this enum
...
138 |     Reservoir,  // For liquid state machine
    |     ^^^^^^^^^
    |
    = note: `LayerType` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `tau_plus` and `tau_minus` are never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:145:5
    |
143 | struct STDPEngine {
    |        ---------- fields in this struct
144 |     /// STDP window parameters
145 |     tau_plus: f64,   // LTP time constant (ms)
    |     ^^^^^^^^
146 |     tau_minus: f64,  // LTD time constant (ms)
    |     ^^^^^^^^^
    |
    = note: `STDPEngine` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `neurons_per_dim`, `tuning_curves`, `decoding_matrix`, `sparsity`, and `lambda_sparse` are never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:170:5
    |
168 | struct PopulationCoder {
    |        --------------- fields in this struct
169 |     /// Number of neurons per dimension
170 |     neurons_per_dim: usize,
    |     ^^^^^^^^^^^^^^^
171 |     /// Tuning curves for each neuron
172 |     tuning_curves: Vec<TuningCurve>,
    |     ^^^^^^^^^^^^^
173 |     /// Decoding weights
174 |     decoding_matrix: DMatrix<f64>,
    |     ^^^^^^^^^^^^^^^
175 |     /// Sparse coding parameters
176 |     sparsity: f64,
    |     ^^^^^^^^
177 |     lambda_sparse: f64,
    |     ^^^^^^^^^^^^^
    |
    = note: `PopulationCoder` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `preferred`, `sigma`, `max_rate`, and `baseline` are never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:183:5
    |
181 | struct TuningCurve {
    |        ----------- fields in this struct
182 |     /// Preferred value
183 |     preferred: f64,
    |     ^^^^^^^^^
184 |     /// Tuning width
185 |     sigma: f64,
    |     ^^^^^
186 |     /// Maximum firing rate
187 |     max_rate: f64,
    |     ^^^^^^^^
188 |     /// Baseline rate
189 |     baseline: f64,
    |     ^^^^^^^^
    |
    = note: `TuningCurve` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `temporal_kernel` and `sequence_memory` are never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:198:5
    |
194 | struct TemporalProcessor {
    |        ----------------- fields in this struct
...
198 |     temporal_kernel: Vec<f64>,
    |     ^^^^^^^^^^^^^^^
...
202 |     sequence_memory: SequenceMemory,
    |     ^^^^^^^^^^^^^^^
    |
    = note: `TemporalProcessor` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `spectral_radius` is never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:210:5
    |
206 | struct ReservoirState {
    |        -------------- field in this struct
...
210 |     spectral_radius: f64,
    |     ^^^^^^^^^^^^^^^
    |
    = note: `ReservoirState` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `sequences`, `similarity_threshold`, and `max_length` are never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:230:5
    |
228 | struct SequenceMemory {
    |        -------------- fields in this struct
229 |     /// Stored sequences
230 |     sequences: Vec<Vec<DVector<f64>>>,
    |     ^^^^^^^^^
231 |     /// Sequence similarity threshold
232 |     similarity_threshold: f64,
    |     ^^^^^^^^^^^^^^^^^^^^
233 |     /// Maximum sequence length
234 |     max_length: usize,
    |     ^^^^^^^^^^
    |
    = note: `SequenceMemory` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `tau_homeostatic` is never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:245:5
    |
239 | struct HomeostaticController {
    |        --------------------- field in this struct
...
245 |     tau_homeostatic: f64,
    |     ^^^^^^^^^^^^^^^
    |
    = note: `HomeostaticController` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `routing_table` and `pattern_threshold` are never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:256:5
    |
254 | struct SpikeRouter {
    |        ----------- fields in this struct
255 |     /// Routing table based on spike patterns
256 |     routing_table: HashMap<SpikePattern, usize>,
    |     ^^^^^^^^^^^^^
...
262 |     pattern_threshold: f64,
    |     ^^^^^^^^^^^^^^^^^
    |
    = note: `SpikeRouter` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `source`, `target`, and `weight` are never read
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:276:5
    |
274 | struct Route {
    |        ----- fields in this struct
275 |     /// Source layer
276 |     source: usize,
    |     ^^^^^^
277 |     /// Target layer
278 |     target: usize,
    |     ^^^^^^
279 |     /// Routing weight
280 |     weight: f64,
    |     ^^^^^^
    |
    = note: `Route` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `device` is never read
   --> src/orchestration/production/gpu_monitoring.rs:111:5
    |
105 | pub struct GpuMonitor {
    |            ---------- field in this struct
...
111 |     device: Option<Arc<CudaContext>>,
    |     ^^^^^^

warning: fields `wq`, `wk`, `wv`, and `wo` are never read
  --> src/orchestration/local_llm/gpu_transformer.rs:22:5
   |
17 | pub struct GpuTransformerLayer {
   |            ------------------- fields in this struct
...
22 |     wq: CudaSlice<f32>,  // Query projection weights
   |     ^^
23 |     wk: CudaSlice<f32>,  // Key projection weights
   |     ^^
24 |     wv: CudaSlice<f32>,  // Value projection weights
   |     ^^
25 |     wo: CudaSlice<f32>,  // Output projection weights
   |     ^^

warning: fields `metrics`, `attention_analyzer`, `transfer_entropy`, and `n_heads` are never read
   --> src/orchestration/local_llm/gpu_transformer.rs:416:5
    |
396 | pub struct GpuLLMInference {
    |            --------------- fields in this struct
...
416 |     metrics: Option<LLMMetrics>,
    |     ^^^^^^^
417 |     attention_analyzer: Option<AttentionAnalyzer>,
    |     ^^^^^^^^^^^^^^^^^^
418 |     transfer_entropy: Option<TransferEntropyLLM>,
    |     ^^^^^^^^^^^^^^^^
...
424 |     n_heads: usize,
    |     ^^^^^^^

warning: field `alignment` is never read
   --> src/orchestration/local_llm/gguf_loader.rs:199:5
    |
185 | pub struct GgufLoader {
    |            ---------- field in this struct
...
199 |     alignment: u64,
    |     ^^^^^^^^^

warning: field `timestamp` is never read
  --> src/orchestration/cache/quantum_cache.rs:43:5
   |
39 | struct CachedEntry {
   |        ----------- field in this struct
...
43 |     timestamp: SystemTime,
   |     ^^^^^^^^^
   |
   = note: `CachedEntry` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: field `temperature` is never read
 --> src/orchestration/consensus/hamiltonian.rs:7:5
  |
5 | pub struct InformationHamiltonian {
  |            ---------------------- field in this struct
6 |     n_llms: usize,
7 |     temperature: f64,
  |     ^^^^^^^^^^^

warning: fields `edges` and `mobius` are never read
  --> src/orchestration/decomposition/pid_synergy.rs:32:5
   |
28 | struct InformationLattice {
   |        ------------------ fields in this struct
...
32 |     edges: HashMap<usize, Vec<usize>>,
   |     ^^^^^
33 |     /// Möbius function values for inclusion-exclusion
34 |     mobius: HashMap<(usize, usize), f64>,
   |     ^^^^^^
   |
   = note: `InformationLattice` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `pi_value` and `cumulative_info` are never read
  --> src/orchestration/decomposition/pid_synergy.rs:42:5
   |
38 | struct LatticeNode {
   |        ----------- fields in this struct
...
42 |     pi_value: f64,
   |     ^^^^^^^^
43 |     /// Cumulative information (PI + all descendants)
44 |     cumulative_info: f64,
   |     ^^^^^^^^^^^^^^^
   |
   = note: `LatticeNode` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `use_gpu` and `parallel_threshold` are never read
  --> src/orchestration/decomposition/pid_synergy.rs:71:5
   |
65 | struct OptimizationConfig {
   |        ------------------ fields in this struct
...
71 |     use_gpu: bool,
   |     ^^^^^^^
72 |     /// Parallel decomposition for large systems
73 |     parallel_threshold: usize,
   |     ^^^^^^^^^^^^^^^^^^
   |
   = note: `OptimizationConfig` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `pi_a` is never read
  --> src/orchestration/inference/hierarchical_active_inference.rs:58:5
   |
52 | struct PrecisionMatrix {
   |        --------------- field in this struct
...
58 |     pi_a: DMatrix<f64>,
   |     ^^^^
   |
   = note: `PrecisionMatrix` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `kl_divergence` is never read
  --> src/orchestration/inference/hierarchical_active_inference.rs:75:5
   |
67 | struct VariationalParameters {
   |        --------------------- field in this struct
...
75 |     kl_divergence: f64,
   |     ^^^^^^^^^^^^^
   |
   = note: `VariationalParameters` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `eta_pi` and `eta_a` are never read
  --> src/orchestration/inference/hierarchical_active_inference.rs:86:5
   |
82 | struct LearningRates {
   |        ------------- fields in this struct
...
86 |     eta_pi: f64,
   |     ^^^^^^
...
90 |     eta_a: f64,
   |     ^^^^^
   |
   = note: `LearningRates` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `habits` is never read
   --> src/orchestration/inference/hierarchical_active_inference.rs:120:5
    |
110 | struct ActionSelection {
    |        --------------- field in this struct
...
120 |     habits: DVector<f64>,
    |     ^^^^^^
    |
    = note: `ActionSelection` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `probability` and `expected_outcomes` are never read
   --> src/orchestration/inference/hierarchical_active_inference.rs:128:5
    |
124 | struct Policy {
    |        ------ fields in this struct
...
128 |     probability: f64,
    |     ^^^^^^^^^^^
129 |     /// Expected outcomes under this policy
130 |     expected_outcomes: Vec<DVector<f64>>,
    |     ^^^^^^^^^^^^^^^^^
    |
    = note: `Policy` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `id` is never read
  --> src/orchestration/inference/joint_active_inference.rs:34:5
   |
32 | struct ActiveInferenceAgent {
   |        -------------------- field in this struct
33 |     /// Agent ID
34 |     id: usize,
   |     ^^
   |
   = note: `ActiveInferenceAgent` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `B`, `C`, `D`, `theta`, and `depth` are never read
  --> src/orchestration/inference/joint_active_inference.rs:57:5
   |
53 | struct LocalGenerativeModel {
   |        -------------------- fields in this struct
...
57 |     B: DMatrix<f64>,
   |     ^
58 |     /// Prior preferences C
59 |     C: DVector<f64>,
   |     ^
60 |     /// Initial state prior D
61 |     D: DVector<f64>,
   |     ^
62 |     /// Model parameters θ
63 |     theta: DVector<f64>,
   |     ^^^^^
64 |     /// Hierarchical depth
65 |     depth: usize,
   |     ^^^^^
   |
   = note: `LocalGenerativeModel` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `sigma` and `info_gain` are never read
  --> src/orchestration/inference/joint_active_inference.rs:74:5
   |
70 | struct BeliefState {
   |        ----------- fields in this struct
...
74 |     sigma: DMatrix<f64>,
   |     ^^^^^
...
80 |     info_gain: f64,
   |     ^^^^^^^^^
   |
   = note: `BeliefState` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `pi_w`, `pi_gamma`, `attention`, and `adaptive` are never read
  --> src/orchestration/inference/joint_active_inference.rs:91:5
   |
87 | struct PrecisionWeights {
   |        ---------------- fields in this struct
...
91 |     pi_w: f64,
   |     ^^^^
92 |     /// Policy precision
93 |     pi_gamma: f64,
   |     ^^^^^^^^
94 |     /// Attention weights
95 |     attention: DVector<f64>,
   |     ^^^^^^^^^
96 |     /// Adaptive precision
97 |     adaptive: bool,
   |     ^^^^^^^^
   |
   = note: `PrecisionWeights` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `eta_theta`, `eta_pi`, `temperature`, and `gamma` are never read
   --> src/orchestration/inference/joint_active_inference.rs:106:5
    |
102 | struct LearningParameters {
    |        ------------------ fields in this struct
...
106 |     eta_theta: f64,
    |     ^^^^^^^^^
107 |     /// Learning rate for precision
108 |     eta_pi: f64,
    |     ^^^^^^
109 |     /// Exploration temperature
110 |     temperature: f64,
    |     ^^^^^^^^^^^
111 |     /// Discount factor
112 |     gamma: f64,
    |     ^^^^^
    |
    = note: `LearningParameters` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `from`, `msg_type`, and `timestamp` are never read
   --> src/orchestration/inference/joint_active_inference.rs:119:5
    |
117 | struct Message {
    |        ------- fields in this struct
118 |     /// Sender ID
119 |     from: usize,
    |     ^^^^
...
123 |     msg_type: MessageType,
    |     ^^^^^^^^
...
127 |     timestamp: f64,
    |     ^^^^^^^^^
    |
    = note: `Message` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `PolicyProposal`, `ObservationReport`, `CoordinationRequest`, and `ConsensusVote` are never constructed
   --> src/orchestration/inference/joint_active_inference.rs:133:5
    |
131 | enum MessageType {
    |      ----------- variants in this enum
132 |     BeliefUpdate,
133 |     PolicyProposal,
    |     ^^^^^^^^^^^^^^
134 |     ObservationReport,
    |     ^^^^^^^^^^^^^^^^^
135 |     CoordinationRequest,
    |     ^^^^^^^^^^^^^^^^^^^
136 |     ConsensusVote,
    |     ^^^^^^^^^^^^^
    |
    = note: `MessageType` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Policy`, `Observation`, `Coordination`, and `Vote` are never constructed
   --> src/orchestration/inference/joint_active_inference.rs:142:5
    |
140 | enum MessageContent {
    |      -------------- variants in this enum
141 |     Belief(DVector<f64>),
142 |     Policy(Vec<f64>),
    |     ^^^^^^
143 |     Observation(DVector<f64>),
    |     ^^^^^^^^^^^
144 |     Coordination(CoordinationData),
    |     ^^^^^^^^^^^^
145 |     Vote(f64),
    |     ^^^^
    |
    = note: `MessageContent` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `action_proposal`, `expected_outcome`, and `confidence` are never read
   --> src/orchestration/inference/joint_active_inference.rs:150:5
    |
149 | struct CoordinationData {
    |        ---------------- fields in this struct
150 |     action_proposal: DVector<f64>,
    |     ^^^^^^^^^^^^^^^
151 |     expected_outcome: DVector<f64>,
    |     ^^^^^^^^^^^^^^^^
152 |     confidence: f64,
    |     ^^^^^^^^^^
    |
    = note: `CoordinationData` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `global_states`, `joint_dynamics`, and `shared_priors` are never read
   --> src/orchestration/inference/joint_active_inference.rs:159:5
    |
157 | struct SharedGenerativeModel {
    |        --------------------- fields in this struct
158 |     /// Global state space
159 |     global_states: DMatrix<f64>,
    |     ^^^^^^^^^^^^^
160 |     /// Joint transition dynamics
161 |     joint_dynamics: JointDynamics,
    |     ^^^^^^^^^^^^^^
162 |     /// Shared priors
163 |     shared_priors: SharedPriors,
    |     ^^^^^^^^^^^^^
    |
    = note: `SharedGenerativeModel` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `T`, `I`, and `nonlinear` are never read
   --> src/orchestration/inference/joint_active_inference.rs:173:5
    |
171 | struct JointDynamics {
    |        ------------- fields in this struct
172 |     /// Joint state transition
173 |     T: DMatrix<f64>,
    |     ^
174 |     /// Interaction terms
175 |     I: DMatrix<f64>,
    |     ^
176 |     /// Nonlinear coupling
177 |     nonlinear: NonlinearCoupling,
    |     ^^^^^^^^^
    |
    = note: `JointDynamics` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `f` and `J` are never read
   --> src/orchestration/inference/joint_active_inference.rs:183:5
    |
181 | struct NonlinearCoupling {
    |        ----------------- fields in this struct
182 |     /// Coupling function
183 |     f: fn(&DVector<f64>, &DVector<f64>) -> DVector<f64>,
    |     ^
184 |     /// Jacobian
185 |     J: DMatrix<f64>,
    |     ^
    |
    = note: `NonlinearCoupling` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `goals`, `constraints`, and `prior_cov` are never read
   --> src/orchestration/inference/joint_active_inference.rs:191:5
    |
189 | struct SharedPriors {
    |        ------------ fields in this struct
190 |     /// Shared goals
191 |     goals: DVector<f64>,
    |     ^^^^^
192 |     /// Common constraints
193 |     constraints: Vec<Constraint>,
    |     ^^^^^^^^^^^
194 |     /// Prior covariance
195 |     prior_cov: DMatrix<f64>,
    |     ^^^^^^^^^
    |
    = note: `SharedPriors` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `constraint_type` and `value` are never read
   --> src/orchestration/inference/joint_active_inference.rs:201:5
    |
199 | struct Constraint {
    |        ---------- fields in this struct
200 |     /// Constraint type
201 |     constraint_type: ConstraintType,
    |     ^^^^^^^^^^^^^^^
202 |     /// Constraint value
203 |     value: f64,
    |     ^^^^^
    |
    = note: `Constraint` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Equality`, `Inequality`, and `Boundary` are never constructed
   --> src/orchestration/inference/joint_active_inference.rs:208:5
    |
207 | enum ConstraintType {
    |      -------------- variants in this enum
208 |     Equality,
    |     ^^^^^^^^
209 |     Inequality,
    |     ^^^^^^^^^^
210 |     Boundary,
    |     ^^^^^^^^
    |
    = note: `ConstraintType` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `delays` and `adaptive` are never read
   --> src/orchestration/inference/joint_active_inference.rs:218:5
    |
214 | struct CouplingMatrix {
    |        -------------- fields in this struct
...
218 |     delays: DMatrix<usize>,
    |     ^^^^^^
219 |     /// Adaptive coupling
220 |     adaptive: bool,
    |     ^^^^^^^^
    |
    = note: `CouplingMatrix` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `state`, `emergence`, and `stability` are never read
   --> src/orchestration/inference/joint_active_inference.rs:226:5
    |
224 | struct EmergentState {
    |        ------------- fields in this struct
225 |     /// State vector
226 |     state: DVector<f64>,
    |     ^^^^^
227 |     /// Emergence measure
228 |     emergence: f64,
    |     ^^^^^^^^^
229 |     /// Stability
230 |     stability: f64,
    |     ^^^^^^^^^
    |
    = note: `EmergentState` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `encoding` is never read
   --> src/orchestration/inference/joint_active_inference.rs:241:5
    |
235 | struct CommunicationProtocol {
    |        --------------------- field in this struct
...
241 |     encoding: MessageEncoding,
    |     ^^^^^^^^
    |
    = note: `CommunicationProtocol` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Ring`, `Star`, `Hierarchical`, `SmallWorld`, and `Dynamic` are never constructed
   --> src/orchestration/inference/joint_active_inference.rs:249:5
    |
247 | enum CommunicationTopology {
    |      --------------------- variants in this enum
248 |     FullyConnected,
249 |     Ring,
    |     ^^^^
250 |     Star,
    |     ^^^^
251 |     Hierarchical,
    |     ^^^^^^^^^^^^
252 |     SmallWorld,
    |     ^^^^^^^^^^
253 |     Dynamic,
    |     ^^^^^^^
    |
    = note: `CommunicationTopology` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `max_size` is never read
   --> src/orchestration/inference/joint_active_inference.rs:261:5
    |
257 | struct BandwidthLimits {
    |        --------------- field in this struct
...
261 |     max_size: usize,
    |     ^^^^^^^^
    |
    = note: `BandwidthLimits` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Uniform` and `Exponential` are never constructed
   --> src/orchestration/inference/joint_active_inference.rs:269:5
    |
267 | enum DelayDistribution {
    |      ----------------- variants in this enum
268 |     Constant(f64),
269 |     Uniform(f64, f64),
    |     ^^^^^^^
270 |     Exponential(f64),
    |     ^^^^^^^^^^^
    |
    = note: `DelayDistribution` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Sparse`, `Compressed`, and `Hierarchical` are never constructed
   --> src/orchestration/inference/joint_active_inference.rs:276:5
    |
274 | enum MessageEncoding {
    |      --------------- variants in this enum
275 |     Dense,
276 |     Sparse,
    |     ^^^^^^
277 |     Compressed,
    |     ^^^^^^^^^^
278 |     Hierarchical,
    |     ^^^^^^^^^^^^
    |
    = note: `MessageEncoding` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `max_retries` is never read
   --> src/orchestration/inference/joint_active_inference.rs:288:5
    |
282 | struct ReliabilityParams {
    |        ----------------- field in this struct
...
288 |     max_retries: usize,
    |     ^^^^^^^^^^^
    |
    = note: `ReliabilityParams` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `synchronization` and `commitment` are never read
   --> src/orchestration/inference/joint_active_inference.rs:297:5
    |
293 | struct CoordinationMechanism {
    |        --------------------- fields in this struct
...
297 |     synchronization: SynchronizationMethod,
    |     ^^^^^^^^^^^^^^^
...
301 |     commitment: CommitmentProtocol,
    |     ^^^^^^^^^^
    |
    = note: `CoordinationMechanism` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Averaging`, `Voting`, `Raft`, and `PBFT` are never constructed
   --> src/orchestration/inference/joint_active_inference.rs:306:5
    |
305 | enum ConsensusAlgorithm {
    |      ------------------ variants in this enum
306 |     Averaging,
    |     ^^^^^^^^^
307 |     Voting,
    |     ^^^^^^
308 |     ByzantineAgreement,
309 |     Raft,
    |     ^^^^
310 |     PBFT,
    |     ^^^^
    |
    = note: `ConsensusAlgorithm` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Synchronous`, `Asynchronous`, and `EventDriven` are never constructed
   --> src/orchestration/inference/joint_active_inference.rs:315:5
    |
314 | enum SynchronizationMethod {
    |      --------------------- variants in this enum
315 |     Synchronous,
    |     ^^^^^^^^^^^
316 |     Asynchronous,
    |     ^^^^^^^^^^^^
317 |     PartiallySynchronous,
318 |     EventDriven,
    |     ^^^^^^^^^^^
    |
    = note: `SynchronizationMethod` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Priority`, `Arbitration`, and `RandomSelection` are never constructed
   --> src/orchestration/inference/joint_active_inference.rs:323:5
    |
322 | enum ConflictResolution {
    |      ------------------ variants in this enum
323 |     Priority,
    |     ^^^^^^^^
324 |     Negotiation,
325 |     Arbitration,
    |     ^^^^^^^^^^^
326 |     RandomSelection,
    |     ^^^^^^^^^^^^^^^
    |
    = note: `ConflictResolution` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `two_phase`, `timeout`, and `rollback` are never read
   --> src/orchestration/inference/joint_active_inference.rs:332:5
    |
330 | struct CommitmentProtocol {
    |        ------------------ fields in this struct
331 |     /// Two-phase commit
332 |     two_phase: bool,
    |     ^^^^^^^^^
333 |     /// Timeout for commitment
334 |     timeout: f64,
    |     ^^^^^^^
335 |     /// Rollback mechanism
336 |     rollback: bool,
    |     ^^^^^^^^
    |
    = note: `CommitmentProtocol` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `time`, `order_before`, and `critical_point` are never read
   --> src/orchestration/inference/joint_active_inference.rs:372:5
    |
370 | struct PhaseTransition {
    |        --------------- fields in this struct
371 |     /// Time of transition
372 |     time: f64,
    |     ^^^^
373 |     /// Order parameter before
374 |     order_before: f64,
    |     ^^^^^^^^^^^^
...
378 |     critical_point: f64,
    |     ^^^^^^^^^^^^^^
    |
    = note: `PhaseTransition` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `pattern_type`, `spatial`, `temporal`, and `stability` are never read
   --> src/orchestration/inference/joint_active_inference.rs:384:5
    |
382 | struct EmergentPattern {
    |        --------------- fields in this struct
383 |     /// Pattern type
384 |     pattern_type: PatternType,
    |     ^^^^^^^^^^^^
385 |     /// Spatial configuration
386 |     spatial: DMatrix<f64>,
    |     ^^^^^^^
387 |     /// Temporal dynamics
388 |     temporal: Vec<f64>,
    |     ^^^^^^^^
389 |     /// Stability measure
390 |     stability: f64,
    |     ^^^^^^^^^
    |
    = note: `EmergentPattern` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Clustering`, `WaveFormation`, and `Differentiation` are never constructed
   --> src/orchestration/inference/joint_active_inference.rs:396:5
    |
394 | enum PatternType {
    |      ----------- variants in this enum
395 |     Synchronization,
396 |     Clustering,
    |     ^^^^^^^^^^
397 |     WaveFormation,
    |     ^^^^^^^^^^^^^
398 |     Consensus,
399 |     Differentiation,
    |     ^^^^^^^^^^^^^^^
    |
    = note: `PatternType` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `individual_spaces`, `joint_actions`, and `pareto_frontier` are never read
   --> src/orchestration/inference/joint_active_inference.rs:406:5
    |
404 | struct JointActionSpace {
    |        ---------------- fields in this struct
405 |     /// Individual action spaces
406 |     individual_spaces: Vec<ActionSpace>,
    |     ^^^^^^^^^^^^^^^^^
407 |     /// Joint action combinations
408 |     joint_actions: Vec<JointAction>,
    |     ^^^^^^^^^^^^^
...
412 |     pareto_frontier: Vec<JointAction>,
    |     ^^^^^^^^^^^^^^^
    |
    = note: `JointActionSpace` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `discrete`, `continuous`, and `mixed` are never read
   --> src/orchestration/inference/joint_active_inference.rs:418:5
    |
416 | struct ActionSpace {
    |        ----------- fields in this struct
417 |     /// Discrete actions
418 |     discrete: Vec<usize>,
    |     ^^^^^^^^
419 |     /// Continuous actions
420 |     continuous: DVector<f64>,
    |     ^^^^^^^^^^
421 |     /// Mixed actions
422 |     mixed: MixedAction,
    |     ^^^^^
    |
    = note: `ActionSpace` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `discrete_part` and `continuous_part` are never read
   --> src/orchestration/inference/joint_active_inference.rs:427:5
    |
426 | struct MixedAction {
    |        ----------- fields in this struct
427 |     discrete_part: usize,
    |     ^^^^^^^^^^^^^
428 |     continuous_part: DVector<f64>,
    |     ^^^^^^^^^^^^^^^
    |
    = note: `MixedAction` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `actions`, `expected_outcome`, `utility`, and `feasible` are never read
   --> src/orchestration/inference/joint_active_inference.rs:434:5
    |
432 | struct JointAction {
    |        ----------- fields in this struct
433 |     /// Actions for each agent
434 |     actions: Vec<DVector<f64>>,
    |     ^^^^^^^
435 |     /// Expected joint outcome
436 |     expected_outcome: DVector<f64>,
    |     ^^^^^^^^^^^^^^^^
437 |     /// Joint utility
438 |     utility: f64,
    |     ^^^^^^^
439 |     /// Feasibility
440 |     feasible: bool,
    |     ^^^^^^^^
    |
    = note: `JointAction` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `agents` and `constraint_fn` are never read
   --> src/orchestration/inference/joint_active_inference.rs:446:5
    |
444 | struct CoordinationConstraint {
    |        ---------------------- fields in this struct
445 |     /// Agents involved
446 |     agents: Vec<usize>,
    |     ^^^^^^
447 |     /// Constraint function
448 |     constraint_fn: fn(&[DVector<f64>]) -> bool,
    |     ^^^^^^^^^^^^^
    |
    = note: `CoordinationConstraint` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `expected_value` and `coordination_cost` are never read
    --> src/orchestration/inference/joint_active_inference.rs:1534:5
     |
1532 | struct JointPolicy {
     |        ----------- fields in this struct
1533 |     agent_policies: Vec<AgentPolicy>,
1534 |     expected_value: f64,
     |     ^^^^^^^^^^^^^^
1535 |     coordination_cost: f64,
     |     ^^^^^^^^^^^^^^^^^
     |
     = note: `JointPolicy` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `original` is never read
  --> src/orchestration/causality/bidirectional_causality.rs:54:5
   |
50 | struct ShadowManifold {
   |        -------------- field in this struct
...
54 |     original: DVector<f64>,
   |     ^^^^^^^^
   |
   = note: `ShadowManifold` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `FixedWidth`, `KernelDensity`, and `Symbolic` are never constructed
  --> src/orchestration/causality/bidirectional_causality.rs:80:5
   |
79 | enum BinningMethod {
   |      ------------- variants in this enum
80 |     FixedWidth(usize),
   |     ^^^^^^^^^^
81 |     Adaptive,
82 |     KernelDensity,
   |     ^^^^^^^^^^^^^
83 |     Symbolic,
   |     ^^^^^^^^
   |
   = note: `BinningMethod` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `alpha`, `use_var`, `spectral`, and `conditional_vars` are never read
   --> src/orchestration/causality/bidirectional_causality.rs:92:5
    |
 88 | struct GrangerCausalityTester {
    |        ---------------------- fields in this struct
...
 92 |     alpha: f64,
    |     ^^^^^
 93 |     /// Use VAR model
 94 |     use_var: bool,
    |     ^^^^^^^
...
 98 |     spectral: bool,
    |     ^^^^^^^^
 99 |     /// Conditional Granger causality
100 |     conditional_vars: Vec<String>,
    |     ^^^^^^^^^^^^^^^^
    |
    = note: `GrangerCausalityTester` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `d_separation_cache` and `backdoor_paths` are never read
   --> src/orchestration/causality/bidirectional_causality.rs:113:5
    |
105 | struct CausalGraph {
    |        ----------- fields in this struct
...
113 |     d_separation_cache: HashMap<(usize, usize, HashSet<usize>), bool>,
    |     ^^^^^^^^^^^^^^^^^^
114 |     /// Backdoor paths
115 |     backdoor_paths: HashMap<(usize, usize), Vec<Vec<usize>>>,
    |     ^^^^^^^^^^^^^^
    |
    = note: `CausalGraph` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `node_type`, `observed`, and `intervened` are never read
   --> src/orchestration/causality/bidirectional_causality.rs:123:5
    |
119 | struct CausalNode {
    |        ---------- fields in this struct
...
123 |     node_type: NodeType,
    |     ^^^^^^^^^
124 |     /// Is observed
125 |     observed: bool,
    |     ^^^^^^^^
126 |     /// Intervention state
127 |     intervened: Option<f64>,
    |     ^^^^^^^^^^
    |
    = note: `CausalNode` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Latent`, `Confounder`, `Mediator`, and `Collider` are never constructed
   --> src/orchestration/causality/bidirectional_causality.rs:133:5
    |
131 | enum NodeType {
    |      -------- variants in this enum
132 |     Observed,
133 |     Latent,
    |     ^^^^^^
134 |     Confounder,
    |     ^^^^^^^^^^
135 |     Mediator,
    |     ^^^^^^^^
136 |     Collider,
    |     ^^^^^^^^
    |
    = note: `NodeType` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `strength`, `edge_type`, and `lag` are never read
   --> src/orchestration/causality/bidirectional_causality.rs:142:5
    |
140 | struct CausalEdge {
    |        ---------- fields in this struct
141 |     /// Edge strength
142 |     strength: f64,
    |     ^^^^^^^^
143 |     /// Edge type
144 |     edge_type: EdgeType,
    |     ^^^^^^^^^
145 |     /// Time lag
146 |     lag: usize,
    |     ^^^
    |
    = note: `CausalEdge` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variant `TimeDelayed` is never constructed
   --> src/orchestration/causality/bidirectional_causality.rs:154:5
    |
150 | enum EdgeType {
    |      -------- variant in this enum
...
154 |     TimeDelayed,
    |     ^^^^^^^^^^^
    |
    = note: `EdgeType` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `conflict_resolution` is never read
   --> src/orchestration/causality/bidirectional_causality.rs:169:5
    |
159 | struct PCAlgorithm {
    |        ----------- field in this struct
...
169 |     conflict_resolution: ConflictResolution,
    |     ^^^^^^^^^^^^^^^^^^^
    |
    = note: `PCAlgorithm` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `PartialCorrelation`, `MutualInformation`, and `KernelCIT` are never constructed
   --> src/orchestration/causality/bidirectional_causality.rs:174:5
    |
173 | enum IndependenceTest {
    |      ---------------- variants in this enum
174 |     PartialCorrelation,
    |     ^^^^^^^^^^^^^^^^^^
175 |     MutualInformation,
    |     ^^^^^^^^^^^^^^^^^
176 |     HSIC,  // Hilbert-Schmidt Independence Criterion
177 |     KernelCIT,  // Kernel Conditional Independence Test
    |     ^^^^^^^^^
    |
    = note: `IndependenceTest` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variant `ConservativeOrientation` is never constructed
   --> src/orchestration/causality/bidirectional_causality.rs:184:5
    |
181 | enum OrientationRule {
    |      --------------- variant in this enum
...
184 |     ConservativeOrientation,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: `OrientationRule` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `Conservative`, `Majority`, and `MaxStrength` are never constructed
   --> src/orchestration/causality/bidirectional_causality.rs:190:5
    |
189 | enum ConflictResolution {
    |      ------------------ variants in this enum
190 |     Conservative,
    |     ^^^^^^^^^^^^
191 |     Majority,
    |     ^^^^^^^^
192 |     MaxStrength,
    |     ^^^^^^^^^^^
    |
    = note: `ConflictResolution` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `RandomShuffle`, `PhaseRandomization`, and `TwinSurrogates` are never constructed
   --> src/orchestration/causality/bidirectional_causality.rs:215:5
    |
214 | enum SurrogateMethod {
    |      --------------- variants in this enum
215 |     RandomShuffle,
    |     ^^^^^^^^^^^^^
216 |     PhaseRandomization,
    |     ^^^^^^^^^^^^^^^^^^
217 |     IAAFT,  // Iterative Amplitude Adjusted Fourier Transform
218 |     TwinSurrogates,
    |     ^^^^^^^^^^^^^^
    |
    = note: `SurrogateMethod` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `None`, `Bonferroni`, and `BenjaminiYekutieli` are never constructed
   --> src/orchestration/causality/bidirectional_causality.rs:223:5
    |
222 | enum MultipleTestingCorrection {
    |      ------------------------- variants in this enum
223 |     None,
    |     ^^^^
224 |     Bonferroni,
    |     ^^^^^^^^^^
225 |     BenjaminiHochberg,
226 |     BenjaminiYekutieli,
    |     ^^^^^^^^^^^^^^^^^^
    |
    = note: `MultipleTestingCorrection` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `sampling_rate` and `capacity` are never read
   --> src/orchestration/causality/bidirectional_causality.rs:235:5
    |
231 | struct TimeSeriesBuffer {
    |        ---------------- fields in this struct
...
235 |     sampling_rate: f64,
    |     ^^^^^^^^^^^^^
236 |     /// Buffer capacity
237 |     capacity: usize,
    |     ^^^^^^^^
    |
    = note: `TimeSeriesBuffer` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `p_value`, `adjusted_p`, and `significant` are never read
    --> src/orchestration/causality/bidirectional_causality.rs:1788:5
     |
1787 | struct SignificanceResult {
     |        ------------------ fields in this struct
1788 |     p_value: f64,
     |     ^^^^^^^
1789 |     adjusted_p: f64,
     |     ^^^^^^^^^^
1790 |     significant: bool,
     |     ^^^^^^^^^^^
     |
     = note: `SignificanceResult` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `channels` and `multipartite` are never read
  --> src/orchestration/quantum/quantum_entanglement_measures.rs:24:5
   |
14 | pub struct QuantumEntanglementAnalyzer {
   |            --------------------------- fields in this struct
...
24 |     channels: QuantumChannels,
   |     ^^^^^^^^
...
28 |     multipartite: MultipartiteEntanglement,
   |     ^^^^^^^^^^^^

warning: field `eigenvectors` is never read
  --> src/orchestration/quantum/quantum_entanglement_measures.rs:45:5
   |
33 | struct DensityMatrixHandler {
   |        -------------------- field in this struct
...
45 |     eigenvectors: DMatrix<Complex64>,
   |     ^^^^^^^^^^^^
   |
   = note: `DensityMatrixHandler` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `squashed`, `formation`, and `distillable` are never read
  --> src/orchestration/quantum/quantum_entanglement_measures.rs:58:5
   |
50 | struct EntanglementMeasures {
   |        -------------------- fields in this struct
...
58 |     squashed: SquashedEntanglement,
   |     ^^^^^^^^
59 |     /// Entanglement of formation
60 |     formation: EntanglementOfFormation,
   |     ^^^^^^^^^
61 |     /// Distillable entanglement
62 |     distillable: DistillableEntanglement,
   |     ^^^^^^^^^^^
   |
   = note: `EntanglementMeasures` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `magic_basis` is never read
  --> src/orchestration/quantum/quantum_entanglement_measures.rs:74:5
   |
68 | struct ConcurrenceMeasure {
   |        ------------------ field in this struct
...
74 |     magic_basis: DMatrix<Complex64>,
   |     ^^^^^^^^^^^
   |
   = note: `ConcurrenceMeasure` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `iterations` is never read
  --> src/orchestration/quantum/quantum_entanglement_measures.rs:96:5
   |
90 | struct RelativeEntropyMeasure {
   |        ---------------------- field in this struct
...
96 |     iterations: usize,
   |     ^^^^^^^^^^
   |
   = note: `RelativeEntropyMeasure` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `value`, `cmi`, and `extension_dim` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:102:5
    |
100 | struct SquashedEntanglement {
    |        -------------------- fields in this struct
101 |     /// Squashed entanglement value
102 |     value: f64,
    |     ^^^^^
103 |     /// Conditional mutual information
104 |     cmi: f64,
    |     ^^^
105 |     /// Extension dimension
106 |     extension_dim: usize,
    |     ^^^^^^^^^^^^^
    |
    = note: `SquashedEntanglement` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `value`, `decomposition`, and `convex_roof` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:112:5
    |
110 | struct EntanglementOfFormation {
    |        ----------------------- fields in this struct
111 |     /// EOF value
112 |     value: f64,
    |     ^^^^^
113 |     /// Optimal decomposition
114 |     decomposition: Vec<(f64, DMatrix<Complex64>)>,
    |     ^^^^^^^^^^^^^
115 |     /// Convex roof
116 |     convex_roof: f64,
    |     ^^^^^^^^^^^
    |
    = note: `EntanglementOfFormation` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `rate`, `efficiency`, and `fidelity` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:122:5
    |
120 | struct DistillableEntanglement {
    |        ----------------------- fields in this struct
121 |     /// Distillable entanglement rate
122 |     rate: f64,
    |     ^^^^
123 |     /// Protocol efficiency
124 |     efficiency: f64,
    |     ^^^^^^^^^^
125 |     /// Fidelity after distillation
126 |     fidelity: f64,
    |     ^^^^^^^^
    |
    = note: `DistillableEntanglement` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `monotone` and `additive` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:134:5
    |
130 | struct LogarithmicNegativity {
    |        --------------------- fields in this struct
...
134 |     monotone: bool,
    |     ^^^^^^^^
135 |     /// Additivity satisfied
136 |     additive: bool,
    |     ^^^^^^^^
    |
    = note: `LogarithmicNegativity` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `geometric_discord`, `mid`, `deficit`, and `work_deficit` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:145:5
    |
141 | struct QuantumCorrelations {
    |        ------------------- fields in this struct
...
145 |     geometric_discord: GeometricDiscord,
    |     ^^^^^^^^^^^^^^^^^
146 |     /// Measurement-induced disturbance
147 |     mid: MeasurementInducedDisturbance,
    |     ^^^
148 |     /// Quantum deficit
149 |     deficit: QuantumDeficit,
    |     ^^^^^^^
150 |     /// One-way work deficit
151 |     work_deficit: OneWayWorkDeficit,
    |     ^^^^^^^^^^^^
    |
    = note: `QuantumCorrelations` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `value`, `closest_classical`, and `hs_distance` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:169:5
    |
167 | struct GeometricDiscord {
    |        ---------------- fields in this struct
168 |     /// Geometric discord value
169 |     value: f64,
    |     ^^^^^
170 |     /// Closest classical state
171 |     closest_classical: DMatrix<Complex64>,
    |     ^^^^^^^^^^^^^^^^^
172 |     /// Hilbert-Schmidt distance
173 |     hs_distance: f64,
    |     ^^^^^^^^^^^
    |
    = note: `GeometricDiscord` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `value`, `pre_state`, and `post_state` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:179:5
    |
177 | struct MeasurementInducedDisturbance {
    |        ----------------------------- fields in this struct
178 |     /// MID value
179 |     value: f64,
    |     ^^^^^
180 |     /// Pre-measurement state
181 |     pre_state: DMatrix<Complex64>,
    |     ^^^^^^^^^
182 |     /// Post-measurement state
183 |     post_state: DMatrix<Complex64>,
    |     ^^^^^^^^^^
    |
    = note: `MeasurementInducedDisturbance` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `value`, `zero_way`, and `one_way` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:189:5
    |
187 | struct QuantumDeficit {
    |        -------------- fields in this struct
188 |     /// Deficit value
189 |     value: f64,
    |     ^^^^^
190 |     /// Zero-way deficit
191 |     zero_way: f64,
    |     ^^^^^^^^
192 |     /// One-way deficit
193 |     one_way: f64,
    |     ^^^^^^^
    |
    = note: `QuantumDeficit` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `value`, `extractable_work`, and `thermal_state` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:199:5
    |
197 | struct OneWayWorkDeficit {
    |        ----------------- fields in this struct
198 |     /// Work deficit value
199 |     value: f64,
    |     ^^^^^
200 |     /// Extractable work
201 |     extractable_work: f64,
    |     ^^^^^^^^^^^^^^^^
202 |     /// Thermal state
203 |     thermal_state: DMatrix<Complex64>,
    |     ^^^^^^^^^^^^^
    |
    = note: `OneWayWorkDeficit` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `nonlinear`, `optimal`, and `decomposition` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:212:5
    |
208 | struct EntanglementWitnesses {
    |        --------------------- fields in this struct
...
212 |     nonlinear: Vec<NonlinearWitness>,
    |     ^^^^^^^^^
213 |     /// Optimal witness
214 |     optimal: OptimalWitness,
    |     ^^^^^^^
215 |     /// Witness decomposition
216 |     decomposition: WitnessDecomposition,
    |     ^^^^^^^^^^^^^
    |
    = note: `EntanglementWitnesses` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `W`, `expectation`, `threshold`, and `detected` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:222:5
    |
220 | struct LinearWitness {
    |        ------------- fields in this struct
221 |     /// Witness operator
222 |     W: DMatrix<Complex64>,
    |     ^
223 |     /// Expectation value
224 |     expectation: f64,
    |     ^^^^^^^^^^^
225 |     /// Detection threshold
226 |     threshold: f64,
    |     ^^^^^^^^^
227 |     /// Detected entanglement
228 |     detected: bool,
    |     ^^^^^^^^
    |
    = note: `LinearWitness` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `witness_fn`, `value`, and `separable_bound` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:234:5
    |
232 | struct NonlinearWitness {
    |        ---------------- fields in this struct
233 |     /// Witness function
234 |     witness_fn: fn(&DMatrix<Complex64>) -> f64,
    |     ^^^^^^^^^^
235 |     /// Value for current state
236 |     value: f64,
    |     ^^^^^
237 |     /// Separable bound
238 |     separable_bound: f64,
    |     ^^^^^^^^^^^^^^^
    |
    = note: `NonlinearWitness` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `W_opt`, `method`, and `strength` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:244:5
    |
242 | struct OptimalWitness {
    |        -------------- fields in this struct
243 |     /// Optimal witness operator
244 |     W_opt: DMatrix<Complex64>,
    |     ^^^^^
245 |     /// Optimization method used
246 |     method: OptimizationMethod,
    |     ^^^^^^
247 |     /// Witness strength
248 |     strength: f64,
    |     ^^^^^^^^
    |
    = note: `OptimalWitness` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: variants `GradientDescent`, `GeneticAlgorithm`, and `ConvexOptimization` are never constructed
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:254:5
    |
252 | enum OptimizationMethod {
    |      ------------------ variants in this enum
253 |     SDP,  // Semidefinite programming
254 |     GradientDescent,
    |     ^^^^^^^^^^^^^^^
255 |     GeneticAlgorithm,
    |     ^^^^^^^^^^^^^^^^
256 |     ConvexOptimization,
    |     ^^^^^^^^^^^^^^^^^^
    |
    = note: `OptimizationMethod` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `positive`, `negative`, and `error` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:262:5
    |
260 | struct WitnessDecomposition {
    |        -------------------- fields in this struct
261 |     /// Positive part
262 |     positive: DMatrix<Complex64>,
    |     ^^^^^^^^
263 |     /// Negative part
264 |     negative: DMatrix<Complex64>,
    |     ^^^^^^^^
265 |     /// Decomposition error
266 |     error: f64,
    |     ^^^^^
    |
    = note: `WitnessDecomposition` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `depolarizing`, `amplitude_damping`, `phase_damping`, `entanglement_breaking`, and `locc` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:273:5
    |
271 | struct QuantumChannels {
    |        --------------- fields in this struct
272 |     /// Depolarizing channel
273 |     depolarizing: DepolarizingChannel,
    |     ^^^^^^^^^^^^
274 |     /// Amplitude damping
275 |     amplitude_damping: AmplitudeDampingChannel,
    |     ^^^^^^^^^^^^^^^^^
276 |     /// Phase damping
277 |     phase_damping: PhaseDampingChannel,
    |     ^^^^^^^^^^^^^
278 |     /// Entanglement breaking channels
279 |     entanglement_breaking: EntanglementBreakingChannel,
    |     ^^^^^^^^^^^^^^^^^^^^^
280 |     /// LOCC operations
281 |     locc: LOCCOperations,
    |     ^^^^
    |
    = note: `QuantumChannels` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `p`, `kraus`, and `capacity` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:287:5
    |
285 | struct DepolarizingChannel {
    |        ------------------- fields in this struct
286 |     /// Depolarizing probability
287 |     p: f64,
    |     ^
288 |     /// Kraus operators
289 |     kraus: Vec<DMatrix<Complex64>>,
    |     ^^^^^
290 |     /// Channel capacity
291 |     capacity: f64,
    |     ^^^^^^^^
    |
    = note: `DepolarizingChannel` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `gamma`, `kraus`, and `steady_state` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:297:5
    |
295 | struct AmplitudeDampingChannel {
    |        ----------------------- fields in this struct
296 |     /// Damping parameter
297 |     gamma: f64,
    |     ^^^^^
298 |     /// Kraus operators
299 |     kraus: Vec<DMatrix<Complex64>>,
    |     ^^^^^
300 |     /// Steady state
301 |     steady_state: DMatrix<Complex64>,
    |     ^^^^^^^^^^^^
    |
    = note: `AmplitudeDampingChannel` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `lambda`, `kraus`, and `t2` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:307:5
    |
305 | struct PhaseDampingChannel {
    |        ------------------- fields in this struct
306 |     /// Dephasing rate
307 |     lambda: f64,
    |     ^^^^^^
308 |     /// Kraus operators
309 |     kraus: Vec<DMatrix<Complex64>>,
    |     ^^^^^
310 |     /// Decoherence time
311 |     t2: f64,
    |     ^^
    |
    = note: `PhaseDampingChannel` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `p_break`, `measurement_basis`, and `preparation_states` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:317:5
    |
315 | struct EntanglementBreakingChannel {
    |        --------------------------- fields in this struct
316 |     /// Breaking probability
317 |     p_break: f64,
    |     ^^^^^^^
318 |     /// Measurement basis
319 |     measurement_basis: DMatrix<Complex64>,
    |     ^^^^^^^^^^^^^^^^^
320 |     /// Preparation states
321 |     preparation_states: Vec<DMatrix<Complex64>>,
    |     ^^^^^^^^^^^^^^^^^^
    |
    = note: `EntanglementBreakingChannel` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `local_ops`, `comm_rounds`, and `success_prob` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:327:5
    |
325 | struct LOCCOperations {
    |        -------------- fields in this struct
326 |     /// Local operations
327 |     local_ops: Vec<LocalOperation>,
    |     ^^^^^^^^^
328 |     /// Classical communication rounds
329 |     comm_rounds: usize,
    |     ^^^^^^^^^^^
330 |     /// Success probability
331 |     success_prob: f64,
    |     ^^^^^^^^^^^^
    |
    = note: `LOCCOperations` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `party`, `operation`, and `probability` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:337:5
    |
335 | struct LocalOperation {
    |        -------------- fields in this struct
336 |     /// Party index
337 |     party: usize,
    |     ^^^^^
338 |     /// Operation
339 |     operation: DMatrix<Complex64>,
    |     ^^^^^^^^^
340 |     /// Probability
341 |     probability: f64,
    |     ^^^^^^^^^^^
    |
    = note: `LocalOperation` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `sudden_death`, `oscillations`, and `asymptotic` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:350:5
    |
346 | struct EntanglementDynamics {
    |        -------------------- fields in this struct
...
350 |     sudden_death: SuddenDeathBirth,
    |     ^^^^^^^^^^^^
351 |     /// Entanglement oscillations
352 |     oscillations: EntanglementOscillations,
    |     ^^^^^^^^^^^^
353 |     /// Asymptotic entanglement
354 |     asymptotic: AsymptoticEntanglement,
    |     ^^^^^^^^^^
    |
    = note: `EntanglementDynamics` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `H` is never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:360:5
    |
358 | struct TimeEvolution {
    |        ------------- field in this struct
359 |     /// Hamiltonian
360 |     H: DMatrix<Complex64>,
    |     ^
    |
    = note: `TimeEvolution` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `death_times`, `birth_times`, `dark_periods`, and `revival_amplitude` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:372:5
    |
370 | struct SuddenDeathBirth {
    |        ---------------- fields in this struct
371 |     /// Death times
372 |     death_times: Vec<f64>,
    |     ^^^^^^^^^^^
373 |     /// Birth times
374 |     birth_times: Vec<f64>,
    |     ^^^^^^^^^^^
375 |     /// Dark periods
376 |     dark_periods: Vec<(f64, f64)>,
    |     ^^^^^^^^^^^^
377 |     /// Revival amplitude
378 |     revival_amplitude: f64,
    |     ^^^^^^^^^^^^^^^^^
    |
    = note: `SuddenDeathBirth` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `frequency`, `amplitude`, `phase`, and `damping` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:384:5
    |
382 | struct EntanglementOscillations {
    |        ------------------------ fields in this struct
383 |     /// Oscillation frequency
384 |     frequency: f64,
    |     ^^^^^^^^^
385 |     /// Amplitude
386 |     amplitude: f64,
    |     ^^^^^^^^^
387 |     /// Phase
388 |     phase: f64,
    |     ^^^^^
389 |     /// Damping rate
390 |     damping: f64,
    |     ^^^^^^^
    |
    = note: `EntanglementOscillations` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `steady_state`, `convergence_rate`, and `equilibrium_time` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:396:5
    |
394 | struct AsymptoticEntanglement {
    |        ---------------------- fields in this struct
395 |     /// Steady state entanglement
396 |     steady_state: f64,
    |     ^^^^^^^^^^^^
397 |     /// Convergence rate
398 |     convergence_rate: f64,
    |     ^^^^^^^^^^^^^^^^
399 |     /// Equilibrium time
400 |     equilibrium_time: f64,
    |     ^^^^^^^^^^^^^^^^
    |
    = note: `AsymptoticEntanglement` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `ghz`, `w_state`, `cluster`, `graph`, and `gme` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:407:5
    |
405 | struct MultipartiteEntanglement {
    |        ------------------------ fields in this struct
406 |     /// GHZ state fidelity
407 |     ghz: GHZEntanglement,
    |     ^^^
408 |     /// W state entanglement
409 |     w_state: WStateEntanglement,
    |     ^^^^^^^
410 |     /// Cluster state entanglement
411 |     cluster: ClusterEntanglement,
    |     ^^^^^^^
412 |     /// Graph state entanglement
413 |     graph: GraphStateEntanglement,
    |     ^^^^^
414 |     /// Genuine multipartite entanglement
415 |     gme: GenuineMultipartiteEntanglement,
    |     ^^^
    |
    = note: `MultipartiteEntanglement` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `ghz_state`, `fidelity`, and `three_tangle` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:421:5
    |
419 | struct GHZEntanglement {
    |        --------------- fields in this struct
420 |     /// GHZ state
421 |     ghz_state: DMatrix<Complex64>,
    |     ^^^^^^^^^
422 |     /// Fidelity with ideal GHZ
423 |     fidelity: f64,
    |     ^^^^^^^^
424 |     /// Three-tangle
425 |     three_tangle: f64,
    |     ^^^^^^^^^^^^
    |
    = note: `GHZEntanglement` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `w_state`, `fidelity`, and `robustness` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:431:5
    |
429 | struct WStateEntanglement {
    |        ------------------ fields in this struct
430 |     /// W state
431 |     w_state: DMatrix<Complex64>,
    |     ^^^^^^^
432 |     /// Fidelity with ideal W
433 |     fidelity: f64,
    |     ^^^^^^^^
434 |     /// Robustness
435 |     robustness: f64,
    |     ^^^^^^^^^^
    |
    = note: `WStateEntanglement` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `cluster_state`, `stabilizers`, and `connectivity` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:441:5
    |
439 | struct ClusterEntanglement {
    |        ------------------- fields in this struct
440 |     /// Cluster state
441 |     cluster_state: DMatrix<Complex64>,
    |     ^^^^^^^^^^^^^
442 |     /// Stabilizers
443 |     stabilizers: Vec<DMatrix<Complex64>>,
    |     ^^^^^^^^^^^
444 |     /// Graph connectivity
445 |     connectivity: f64,
    |     ^^^^^^^^^^^^
    |
    = note: `ClusterEntanglement` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `adjacency`, `graph_state`, and `lc_equivalence` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:451:5
    |
449 | struct GraphStateEntanglement {
    |        ---------------------- fields in this struct
450 |     /// Graph adjacency matrix
451 |     adjacency: DMatrix<f64>,
    |     ^^^^^^^^^
452 |     /// Graph state
453 |     graph_state: DMatrix<Complex64>,
    |     ^^^^^^^^^^^
454 |     /// Local complementation equivalence
455 |     lc_equivalence: Vec<usize>,
    |     ^^^^^^^^^^^^^^
    |
    = note: `GraphStateEntanglement` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `gme_measure`, `biseparable`, and `k_separability` are never read
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:461:5
    |
459 | struct GenuineMultipartiteEntanglement {
    |        ------------------------------- fields in this struct
460 |     /// GME measure
461 |     gme_measure: f64,
    |     ^^^^^^^^^^^
462 |     /// Biseparability test
463 |     biseparable: bool,
    |     ^^^^^^^^^^^
464 |     /// k-separability
465 |     k_separability: usize,
    |     ^^^^^^^^^^^^^^
    |
    = note: `GenuineMultipartiteEntanglement` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: fields `optimization_level` and `target_arch` are never read
  --> src/quantum_mlir/mod.rs:31:5
   |
27 | pub struct QuantumCompiler {
   |            --------------- fields in this struct
...
31 |     optimization_level: OptimizationLevel,
   |     ^^^^^^^^^^^^^^^^^^
32 |     /// Target GPU architecture
33 |     target_arch: GpuArchitecture,
   |     ^^^^^^^^^^^

warning: methods `build_mlir_module`, `optimize_module`, `lower_to_gpu`, and `generate_ptx` are never used
   --> src/quantum_mlir/mod.rs:127:8
    |
 66 | impl QuantumCompiler {
    | -------------------- methods in this implementation
...
127 |     fn build_mlir_module(&self, operations: &[QuantumOp]) -> Result<mlir::Module> {
    |        ^^^^^^^^^^^^^^^^^
...
156 |     fn optimize_module(&self, module: mlir::Module) -> Result<mlir::Module> {
    |        ^^^^^^^^^^^^^^^
...
193 |     fn lower_to_gpu(&self, module: mlir::Module) -> Result<mlir::Module> {
    |        ^^^^^^^^^^^^
...
200 |     fn generate_ptx(&self, module: mlir::Module) -> Result<String> {
    |        ^^^^^^^^^^^^

warning: field `high_precision` is never read
   --> src/quantum_mlir/mod.rs:283:5
    |
279 | pub struct CompiledQuantumKernel {
    |            --------------------- field in this struct
...
283 |     high_precision: bool,
    |     ^^^^^^^^^^^^^^

warning: methods `size`, `as_ptr`, and `as_mut_ptr` are never used
   --> src/quantum_mlir/mod.rs:345:8
    |
344 | impl QuantumState {
    | ----------------- methods in this implementation
345 |     fn size(&self) -> usize {
    |        ^^^^
...
349 |     fn as_ptr(&self) -> *const u8 {
    |        ^^^^^^
...
353 |     fn as_mut_ptr(&mut self) -> *mut u8 {
    |        ^^^^^^^^^^

warning: field `namespace` is never read
  --> src/quantum_mlir/dialect.rs:21:5
   |
19 | pub struct QuantumDialect {
   |            -------------- field in this struct
20 |     /// Dialect namespace
21 |     namespace: &'static str,
   |     ^^^^^^^^^

warning: fields `name`, `qubit`, and `target` are never read
  --> src/quantum_mlir/ops.rs:24:5
   |
23 | pub struct Operation {
   |            --------- fields in this struct
24 |     name: &'static str,
   |     ^^^^
25 |     qubit: usize,
   |     ^^^^^
26 |     target: Option<usize>,
   |     ^^^^^^

warning: field `target_arch` is never read
   --> src/quantum_mlir/passes.rs:136:5
    |
135 | pub struct LowerQuantumToGpu {
    |            ----------------- field in this struct
136 |     target_arch: super::GpuArchitecture,
    |     ^^^^^^^^^^^

warning: field `cuda_context` is never read
  --> src/gpu/gpu_enabled.rs:14:5
   |
13 | struct GpuState {
   |        -------- field in this struct
14 |     cuda_context: Option<Arc<CudaCompatContext>>,
   |     ^^^^^^^^^^^^

warning: fields `in_features` and `out_features` are never read
   --> src/gpu/gpu_enabled.rs:355:5
    |
352 | pub struct GpuLinear {
    |            --------- fields in this struct
...
355 |     in_features: usize,
    |     ^^^^^^^^^^^
356 |     out_features: usize,
    |     ^^^^^^^^^^^^

warning: method `convert_f16_to_f32_gpu` is never used
    --> src/gpu/kernel_executor.rs:3198:8
     |
1975 | impl GpuKernelExecutor {
     | ---------------------- method in this implementation
...
3198 |     fn convert_f16_to_f32_gpu(&self, data: &[u16]) -> Result<Vec<f32>> {
     |        ^^^^^^^^^^^^^^^^^^^^^^

warning: fields `size_bytes` and `timestamp_ns` are never read
   --> src/gpu/memory_pool.rs:154:5
    |
153 | struct AllocationRecord {
    |        ---------------- fields in this struct
154 |     size_bytes: usize,
    |     ^^^^^^^^^^
155 |     timestamp_ns: u64,
    |     ^^^^^^^^^^^^
    |
    = note: `AllocationRecord` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: fields `allocated_at` and `last_used` are never read
  --> src/gpu/active_memory_pool.rs:90:5
   |
87 | struct BufferMetadata {
   |        -------------- fields in this struct
...
90 |     allocated_at: u64,
   |     ^^^^^^^^^^^^
91 |     last_used: u64,
   |     ^^^^^^^^^
   |
   = note: `BufferMetadata` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `config` is never read
  --> src/gpu/kernel_autotuner.rs:44:5
   |
43 | struct ConfigPerformance {
   |        ----------------- field in this struct
44 |     config: LaunchConfig,
   |     ^^^^^^
   |
   = note: `ConfigPerformance` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: fields `context` and `device` are never read
   --> src/gpu/production_runtime.rs:137:5
    |
136 | pub struct ProductionGpuRuntime {
    |            -------------------- fields in this struct
137 |     context: usize,  // Store as usize for Send/Sync
    |     ^^^^^^^
138 |     device: i32,
    |     ^^^^^^

warning: function `cuDeviceGetCount` is never used
  --> src/gpu/production_runtime.rs:16:8
   |
16 |     fn cuDeviceGetCount(count: *mut i32) -> i32;
   |        ^^^^^^^^^^^^^^^^

warning: function `cuCtxSetCurrent` is never used
  --> src/gpu/production_runtime.rs:19:8
   |
19 |     fn cuCtxSetCurrent(ctx: *mut c_void) -> i32;
   |        ^^^^^^^^^^^^^^^

warning: function `cuMemcpyDtoD_v2` is never used
  --> src/gpu/production_runtime.rs:26:8
   |
26 |     fn cuMemcpyDtoD_v2(dst: u64, src: u64, bytesize: usize) -> i32;
   |        ^^^^^^^^^^^^^^^

warning: function `cuStreamCreate` is never used
  --> src/gpu/production_runtime.rs:46:8
   |
46 |     fn cuStreamCreate(stream: *mut *mut c_void, flags: u32) -> i32;
   |        ^^^^^^^^^^^^^^

warning: function `cuStreamSynchronize` is never used
  --> src/gpu/production_runtime.rs:47:8
   |
47 |     fn cuStreamSynchronize(stream: *mut c_void) -> i32;
   |        ^^^^^^^^^^^^^^^^^^^

warning: fields `device` and `max_simplices` are never read
   --> src/phase6/tda.rs:113:5
    |
110 | pub struct TdaAdapter {
    |            ---------- fields in this struct
...
113 |     device: Arc<()>,
    |     ^^^^^^
...
117 |     max_simplices: usize,
    |     ^^^^^^^^^^^^^

warning: field `max_dimension` is never read
   --> src/phase6/tda.rs:557:5
    |
554 | struct VietorisRipsComplex {
    |        ------------------- field in this struct
...
557 |     max_dimension: usize,
    |     ^^^^^^^^^^^^^

warning: fields `spectral_radius`, `generative_model`, and `prediction_history` are never read
   --> src/phase6/predictive_neuro.rs:87:5
    |
 83 | pub struct PredictiveNeuromorphic {
    |            ---------------------- fields in this struct
...
 87 |     spectral_radius: f64,
    |     ^^^^^^^^^^^^^^^
...
101 |     generative_model: GenerativeModel,
    |     ^^^^^^^^^^^^^^^^
...
105 |     prediction_history: Vec<Array1<f64>>,
    |     ^^^^^^^^^^^^^^^^^^

warning: field `gnn` is never read
   --> src/phase6/meta_learning.rs:126:5
    |
121 | pub struct MetaLearningCoordinator {
    |            ----------------------- field in this struct
...
126 |     gnn: Arc<RwLock<E3EquivariantGNN>>,
    |     ^^^

warning: fields `active_inference` and `health_monitor` are never read
  --> src/phase6/integration.rs:28:5
   |
23 | pub struct Phase6Integration {
   |            ----------------- fields in this struct
...
28 |     active_inference: Arc<RwLock<HierarchicalModel>>,
   |     ^^^^^^^^^^^^^^^^
...
37 |     health_monitor: Arc<RwLock<HealthMonitor>>,
   |     ^^^^^^^^^^^^^^

warning: field `free_energy` is never read
   --> src/phase6/integration.rs:415:5
    |
413 | struct InferenceResult {
    |        --------------- field in this struct
414 |     state: Array1<f64>,
415 |     free_energy: f64,
    |     ^^^^^^^^^^^

warning: field `energy` is never read
   --> src/phase6/integration.rs:420:5
    |
418 | struct ThermoResult {
    |        ------------ field in this struct
419 |     state: Array1<f64>,
420 |     energy: f64,
    |     ^^^^^^

warning: field `max_dimension` is never read
  --> src/phase6/gpu_tda.rs:16:5
   |
13 | pub struct GpuTDA {
   |            ------ field in this struct
...
16 |     max_dimension: usize,
   |     ^^^^^^^^^^^^^

warning: fields `transfer_entropy` and `active_inference` are never read
  --> src/cma/mod.rs:56:5
   |
39 | pub struct CausalManifoldAnnealing {
   |            ----------------------- fields in this struct
...
56 |     transfer_entropy: Arc<crate::information_theory::transfer_entropy::TransferEntropy>,
   |     ^^^^^^^^^^^^^^^^
57 |     active_inference: Arc<crate::active_inference::ActiveInferenceController>,
   |     ^^^^^^^^^^^^^^^^

warning: field `ksg_neighbors` is never read
  --> src/cma/causal_discovery.rs:20:5
   |
18 | pub struct CausalManifoldDiscovery {
   |            ----------------------- field in this struct
19 |     fdr_threshold: f64,
20 |     ksg_neighbors: usize,
   |     ^^^^^^^^^^^^^

warning: multiple methods are never used
   --> src/cma/causal_discovery.rs:121:8
    |
 28 | impl CausalManifoldDiscovery {
    | ---------------------------- methods in this implementation
...
121 |     fn ksg_transfer_entropy(&self, source: &[f64], target: &[f64]) -> (f64, f64) {
    |        ^^^^^^^^^^^^^^^^^^^^
...
285 |     fn compute_distance(
    |        ^^^^^^^^^^^^^^^^
...
304 |     fn count_neighbors_marginal(
    |        ^^^^^^^^^^^^^^^^^^^^^^^^
...
328 |     fn count_neighbors_joint(
    |        ^^^^^^^^^^^^^^^^^^^^^
...
353 |     fn count_neighbors_marginal_past(
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
376 |     fn digamma(&self, x: f64) -> f64 {
    |        ^^^^^^^
...
385 |     fn bootstrap_p_value(&self, source: &[f64], target: &[f64], observed_te: f64) -> f64 {
    |        ^^^^^^^^^^^^^^^^^

warning: fields `initial_temp` and `final_temp` are never read
  --> src/cma/quantum_annealer.rs:19:5
   |
17 | pub struct GeometricQuantumAnnealer {
   |            ------------------------ fields in this struct
18 |     n_steps: usize,
19 |     initial_temp: f64,
   |     ^^^^^^^^^^^^
20 |     final_temp: f64,
   |     ^^^^^^^^^^

warning: field `dimension` is never read
   --> src/cma/quantum_annealer.rs:479:5
    |
477 | struct QuantumState {
    |        ------------ field in this struct
478 |     amplitudes: Vec<Complex64>,
479 |     dimension: usize,
    |     ^^^^^^^^^

warning: field `manifold_penalty` is never read
   --> src/cma/quantum_annealer.rs:486:5
    |
483 | struct QuantumHamiltonian {
    |        ------------------ field in this struct
...
486 |     manifold_penalty: f64,
    |     ^^^^^^^^^^^^^^^^

warning: field `device` is never read
  --> src/cma/neural/mod.rs:75:5
   |
73 | pub struct GeometricManifoldLearner {
   |            ------------------------ field in this struct
74 |     gnn: E3EquivariantGNN,
75 |     device: Device,
   |     ^^^^^^

warning: field `solution_dim` is never read
   --> src/cma/neural/mod.rs:155:5
    |
153 | pub struct DiffusionRefinement {
    |            ------------------- field in this struct
154 |     diffusion: ConsistencyDiffusion,
155 |     solution_dim: usize,
    |     ^^^^^^^^^^^^

warning: field `solution_dim` is never read
   --> src/cma/neural/mod.rs:206:5
    |
204 | pub struct NeuralQuantumState {
    |            ------------------ field in this struct
205 |     vmc: VariationalMonteCarlo,
206 |     solution_dim: usize,
    |     ^^^^^^^^^^^^

warning: fields `device`, `embed_dim`, and `num_heads` are never read
   --> src/cma/neural/mod.rs:254:5
    |
253 | pub struct MetaOptimizationTransformer {
    |            --------------------------- fields in this struct
254 |     device: Device,
    |     ^^^^^^
255 |     embed_dim: usize,
    |     ^^^^^^^^^
256 |     num_heads: usize,
    |     ^^^^^^^^^

warning: fields `device`, `node_dim`, `edge_dim`, `hidden_dim`, and `num_layers` are never read
  --> src/cma/neural/gnn_integration.rs:14:5
   |
13 | pub struct E3EquivariantGNN {
   |            ---------------- fields in this struct
14 |     device: Device,
   |     ^^^^^^
15 |     node_dim: usize,
   |     ^^^^^^^^
16 |     edge_dim: usize,
   |     ^^^^^^^^
17 |     hidden_dim: usize,
   |     ^^^^^^^^^^
18 |     num_layers: usize,
   |     ^^^^^^^^^^

warning: fields `solution_dim`, `hidden_dim`, `num_steps`, and `device` are never read
  --> src/cma/neural/diffusion.rs:13:5
   |
12 | pub struct ConsistencyDiffusion {
   |            -------------------- fields in this struct
13 |     solution_dim: usize,
   |     ^^^^^^^^^^^^
14 |     hidden_dim: usize,
   |     ^^^^^^^^^^
15 |     num_steps: usize,
   |     ^^^^^^^^^
16 |     device: Device,
   |     ^^^^^^

warning: field `normalized_shape` is never read
   --> src/cma/neural/neural_quantum.rs:138:5
    |
137 | pub struct LayerNorm {
    |            --------- field in this struct
138 |     normalized_shape: usize,
    |     ^^^^^^^^^^^^^^^^

warning: fields `device`, `hidden_dim`, and `num_layers` are never read
   --> src/cma/neural/neural_quantum.rs:161:5
    |
159 | pub struct NeuralQuantumState {
    |            ------------------ fields in this struct
160 |     network: ResNet,
161 |     device: Device,
    |     ^^^^^^
162 |     hidden_dim: usize,
    |     ^^^^^^^^^^
163 |     num_layers: usize,
    |     ^^^^^^^^^^

warning: fields `input_dim`, `hidden_dim`, `num_layers`, and `device` are never read
   --> src/cma/neural/neural_quantum.rs:370:5
    |
369 | pub struct ResNet {
    |            ------ fields in this struct
370 |     input_dim: usize,
    |     ^^^^^^^^^
371 |     hidden_dim: usize,
    |     ^^^^^^^^^^
372 |     num_layers: usize,
    |     ^^^^^^^^^^
373 |     device: Device,
    |     ^^^^^^

warning: fields `hidden_dim` and `device` are never read
   --> src/cma/neural/neural_quantum.rs:438:5
    |
437 | struct ResidualLayer {
    |        ------------- fields in this struct
438 |     hidden_dim: usize,
    |     ^^^^^^^^^^
439 |     device: Device,
    |     ^^^^^^

warning: field `num_iterations` is never read
   --> src/cma/neural/neural_quantum.rs:484:5
    |
481 | pub struct VariationalMonteCarlo {
    |            --------------------- field in this struct
...
484 |     num_iterations: usize,
    |     ^^^^^^^^^^^^^^

warning: fields `optimizer` and `device` are never read
   --> src/cma/neural/gnn_training.rs:665:5
    |
663 | pub struct GNNTrainer {
    |            ---------- fields in this struct
664 |     model: E3EquivariantGNN,
665 |     optimizer: Optimizer,
    |     ^^^^^^^^^
...
669 |     device: Device,
    |     ^^^^^^

warning: field `device` is never read
   --> src/cma/neural/gnn_training.rs:922:5
    |
920 | pub struct GpuBatchGNNTrainer {
    |            ------------------ field in this struct
921 |     trainers: Vec<GNNTrainer>,
922 |     device: Device,
    |     ^^^^^^

warning: fields `teacher` and `device` are never read
   --> src/cma/neural/gnn_transfer_learning.rs:686:5
    |
685 | pub struct KnowledgeDistiller {
    |            ------------------ fields in this struct
686 |     teacher: E3EquivariantGNN,
    |     ^^^^^^^
687 |     config: DistillationConfig,
688 |     device: Device,
    |     ^^^^^^

warning: method `distillation_loss` is never used
   --> src/cma/neural/gnn_transfer_learning.rs:730:8
    |
691 | impl KnowledgeDistiller {
    | ----------------------- method in this implementation
...
730 |     fn distillation_loss(
    |        ^^^^^^^^^^^^^^^^^

warning: field `augmenter` is never read
   --> src/cma/neural/gnn_training_pipeline.rs:614:5
    |
612 | pub struct GNNTrainingPipeline {
    |            ------------------- field in this struct
613 |     preprocessor: DataPreprocessor,
614 |     augmenter: Option<DataAugmenter>,
    |     ^^^^^^^^^

warning: methods `estimate_kl_divergence`, `non_conformity_score`, and `verify_proof_internal` are never used
   --> src/cma/guarantees/mod.rs:198:8
    |
 36 | impl PrecisionFramework {
    | ----------------------- methods in this implementation
...
198 |     fn estimate_kl_divergence(&self, solution: &super::Solution, ensemble: &super::Ensemble) -> f64 {
    |        ^^^^^^^^^^^^^^^^^^^^^^
...
244 |     fn non_conformity_score(&self, solution: &super::Solution, calibration: &CalibrationPoint) -> f64 {
    |        ^^^^^^^^^^^^^^^^^^^^
...
270 |     fn verify_proof_internal(&self, _commitment: &str, _proof: &str) -> bool {
    |        ^^^^^^^^^^^^^^^^^^^^^

warning: fields `empirical_risk`, `kl_divergence`, and `sample_size` are never read
   --> src/cma/guarantees/mod.rs:290:5
    |
289 | struct PacBayesBound {
    |        ------------- fields in this struct
290 |     empirical_risk: f64,
    |     ^^^^^^^^^^^^^^
291 |     kl_divergence: f64,
    |     ^^^^^^^^^^^^^
292 |     error_bound: f64,
293 |     sample_size: usize,
    |     ^^^^^^^^^^^
    |
    = note: `PacBayesBound` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `recent_scores` is never read
   --> src/cma/guarantees/conformal.rs:340:5
    |
337 | pub struct AdaptiveConformalPredictor {
    |            -------------------------- field in this struct
...
340 |     recent_scores: std::collections::VecDeque<f64>,
    |     ^^^^^^^^^^^^^

warning: field `security_parameter` is never read
  --> src/cma/guarantees/zkp.rs:17:5
   |
16 | pub struct ZKProofSystem {
   |            ------------- field in this struct
17 |     security_parameter: usize, // Bits of security (e.g., 256)
   |     ^^^^^^^^^^^^^^^^^^

warning: fields `rmsd_threshold`, `binding_affinity_cutoff`, and `folding_temperature` are never read
   --> src/cma/applications/mod.rs:103:5
    |
102 | pub struct BiomolecularAdapter {
    |            ------------------- fields in this struct
103 |     rmsd_threshold: f64,
    |     ^^^^^^^^^^^^^^
104 |     binding_affinity_cutoff: f64,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
105 |     folding_temperature: f64,
    |     ^^^^^^^^^^^^^^^^^^^

warning: fields `property_r2_threshold`, `synthesis_confidence_min`, and `stability_window_ev` are never read
   --> src/cma/applications/mod.rs:253:5
    |
252 | pub struct MaterialsAdapter {
    |            ---------------- fields in this struct
253 |     property_r2_threshold: f64,
    |     ^^^^^^^^^^^^^^^^^^^^^
254 |     synthesis_confidence_min: f64,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^
255 |     stability_window_ev: f64,
    |     ^^^^^^^^^^^^^^^^^^^

warning: fields `solver_pool` and `pool_size` are never read
  --> src/cma/gpu_integration.rs:46:5
   |
44 | pub struct GpuTspBridge {
   |            ------------ fields in this struct
45 |     /// Pre-allocated solvers for batch processing
46 |     solver_pool: Vec<Arc<parking_lot::Mutex<GpuTspSolver>>>,
   |     ^^^^^^^^^^^
47 |     /// Number of parallel solvers
48 |     pool_size: usize,
   |     ^^^^^^^^^

warning: fields `namespace` and `control_frequency` are never read
  --> src/applications/robotics/ros_bridge.rs:91:5
   |
89 | pub struct RosInterface {
   |            ------------ fields in this struct
90 |     /// Robot namespace
91 |     namespace: String,
   |     ^^^^^^^^^
92 |     /// Control frequency (Hz)
93 |     control_frequency: f64,
   |     ^^^^^^^^^^^^^^^^^

warning: field `config` is never read
  --> src/applications/scientific/mod.rs:40:5
   |
39 | pub struct ScientificDiscovery {
   |            ------------------- field in this struct
40 |     config: ScientificConfig,
   |     ^^^^^^

warning: field `n_candidates` is never read
  --> src/applications/scientific/experiment_design.rs:30:5
   |
28 | pub struct ExperimentDesigner {
   |            ------------------ field in this struct
29 |     /// Number of candidate experiments to evaluate
30 |     n_candidates: usize,
   |     ^^^^^^^^^^^^

warning: field `config` is never read
  --> src/applications/scientific/parameter_optimization.rs:27:5
   |
26 | pub struct ParameterOptimizer {
   |            ------------------ field in this struct
27 |     config: OptimizationConfig,
   |     ^^^^^^

warning: field `confidence_level` is never read
  --> src/applications/scientific/hypothesis_testing.rs:25:5
   |
24 | pub struct HypothesisTester {
   |            ---------------- field in this struct
25 |     confidence_level: f64,
   |     ^^^^^^^^^^^^^^^^

warning: field `device` is never read
  --> src/chemistry/gpu_docking.rs:11:5
   |
10 | pub struct GpuMolecularDocker {
   |            ------------------ field in this struct
11 |     device: Arc<CudaContext>,
   |     ^^^^^^

warning: field `refine_solution` is never read
  --> src/time_series/arima_gpu.rs:62:5
   |
46 | pub struct ArimaGpu {
   |            -------- field in this struct
...
62 |     refine_solution: bool,
   |     ^^^^^^^^^^^^^^^

warning: method `solve_via_qr` is never used
   --> src/time_series/arima_gpu.rs:464:8
    |
 65 | impl ArimaGpu {
    | ------------- method in this implementation
...
464 |     fn solve_via_qr(&self, a_flat: &[f64], b: &[f64], n: usize) -> Result<Vec<f64>> {
    |        ^^^^^^^^^^^^

warning: fields `last_hidden_states` and `last_cell_states` are never read
  --> src/time_series/lstm_forecaster.rs:81:5
   |
70 | pub struct LstmForecaster {
   |            -------------- fields in this struct
...
81 |     last_hidden_states: Option<Vec<Array1<f64>>>,
   |     ^^^^^^^^^^^^^^^^^^
82 |     last_cell_states: Option<Vec<Array1<f64>>>,
   |     ^^^^^^^^^^^^^^^^

warning: field `gpu_available` is never read
  --> src/time_series/kalman_filter.rs:72:5
   |
56 | pub struct KalmanFilter {
   |            ------------ field in this struct
...
72 |     gpu_available: bool,
   |     ^^^^^^^^^^^^^

warning: fields `ar_coefficients` and `state_buffer` are never read
   --> src/time_series/kalman_filter.rs:389:5
    |
385 | pub struct ArimaKalmanFusion {
    |            ----------------- fields in this struct
...
389 |     ar_coefficients: Vec<f64>,
    |     ^^^^^^^^^^^^^^^
390 |     /// State buffer for AR(p) model
391 |     state_buffer: Vec<f64>,
    |     ^^^^^^^^^^^^

warning: field `workspace` is never read
  --> src/time_series/optimizations.rs:30:5
   |
22 | pub struct OptimizedGruCell {
   |            ---------------- field in this struct
...
30 |     workspace: Vec<f64>,
   |     ^^^^^^^^^

warning: field `config` is never read
   --> src/time_series/optimizations.rs:139:5
    |
135 | struct CachedArimaModel {
    |        ---------------- field in this struct
...
139 |     config: ArimaConfig,
    |     ^^^^^^
    |
    = note: `CachedArimaModel` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: field `num_threads` is never read
   --> src/time_series/optimizations.rs:258:5
    |
254 | pub struct BatchForecaster {
    |            --------------- field in this struct
...
258 |     num_threads: usize,
    |     ^^^^^^^^^^^

warning: field `gpu_available` is never read
  --> src/time_series/arima_gpu_optimized.rs:34:5
   |
20 | pub struct ArimaGpuOptimized {
   |            ----------------- field in this struct
...
34 |     gpu_available: bool,
   |     ^^^^^^^^^^^^^

warning: field `gpu_available` is never read
  --> src/time_series/lstm_gpu_optimized.rs:31:5
   |
22 | pub struct LstmGpuOptimized {
   |            ---------------- field in this struct
...
31 |     gpu_available: bool,
   |     ^^^^^^^^^^^^^

warning: field `num_gates` is never read
  --> src/time_series/lstm_gpu_optimized.rs:45:5
   |
35 | struct GpuWeightSet {
   |        ------------ field in this struct
...
45 |     num_gates: usize,
   |     ^^^^^^^^^

warning: field `gpu_available` is never read
  --> src/time_series/uncertainty_gpu_optimized.rs:23:5
   |
17 | pub struct UncertaintyGpuOptimized {
   |            ----------------------- field in this struct
...
23 |     gpu_available: bool,
   |     ^^^^^^^^^^^^^

warning: field `gpu_pool` is never read
   --> src/finance/portfolio_optimizer.rs:103:5
    |
101 | pub struct PortfolioOptimizer {
    |            ------------------ field in this struct
102 |     /// GPU memory pool for covariance computation
103 |     gpu_pool: GpuMemoryPool,
    |     ^^^^^^^^

warning: method `remove_last` is never used
   --> src/api_server/rate_limit.rs:358:8
    |
325 | impl SlidingWindow {
    | ------------------ method in this implementation
...
358 |     fn remove_last(&mut self) {
    |        ^^^^^^^^^^^

warning: field `safety_mode` is never read
  --> src/assistant/autonomous_agent.rs:35:5
   |
33 | pub struct AutonomousAgent {
   |            --------------- field in this struct
34 |     /// Safety mode - controls execution permissions
35 |     safety_mode: SafetyMode,
   |     ^^^^^^^^^^^

warning: fields `wq`, `wk`, `wv`, and `wo` are never read
  --> src/assistant/local_llm/gpu_transformer.rs:22:5
   |
17 | pub struct GpuTransformerLayer {
   |            ------------------- fields in this struct
...
22 |     wq: CudaSlice<f32>,  // Query projection weights
   |     ^^
23 |     wk: CudaSlice<f32>,  // Key projection weights
   |     ^^
24 |     wv: CudaSlice<f32>,  // Value projection weights
   |     ^^
25 |     wo: CudaSlice<f32>,  // Output projection weights
   |     ^^

warning: fields `metrics`, `attention_analyzer`, `transfer_entropy`, and `n_heads` are never read
   --> src/assistant/local_llm/gpu_transformer.rs:416:5
    |
396 | pub struct GpuLLMInference {
    |            --------------- fields in this struct
...
416 |     metrics: Option<LLMMetrics>,
    |     ^^^^^^^
417 |     attention_analyzer: Option<AttentionAnalyzer>,
    |     ^^^^^^^^^^^^^^^^^^
418 |     transfer_entropy: Option<TransferEntropyLLM>,
    |     ^^^^^^^^^^^^^^^^
...
424 |     n_heads: usize,
    |     ^^^^^^^

warning: field `alignment` is never read
   --> src/assistant/local_llm/gguf_loader.rs:199:5
    |
185 | pub struct GgufLoader {
    |            ---------- field in this struct
...
199 |     alignment: u64,
    |     ^^^^^^^^^

warning: method `Quantum` should have a snake case name
  --> src/integration/cross_domain_bridge.rs:56:12
   |
56 |     pub fn Quantum(data: Vec<f64>) -> Self {
   |            ^^^^^^^ help: convert the identifier to snake case: `quantum`
   |
   = note: `#[warn(non_snake_case)]` on by default

warning: method `Neuromorphic` should have a snake case name
  --> src/integration/cross_domain_bridge.rs:67:12
   |
67 |     pub fn Neuromorphic(data: Vec<f64>) -> Self {
   |            ^^^^^^^^^^^^ help: convert the identifier to snake case: `neuromorphic`

warning: structure field `F` should have a snake case name
   --> src/orchestration/optimization/geometric_manifold.rs:220:5
    |
220 |     F: DMatrix<f64>,
    |     ^ help: convert the identifier to snake case (notice the capitalization): `f`

warning: structure field `F_diag` should have a snake case name
   --> src/orchestration/optimization/geometric_manifold.rs:222:5
    |
222 |     F_diag: DVector<f64>,
    |     ^^^^^^ help: convert the identifier to snake case (notice the capitalization): `f_diag`

warning: structure field `A` should have a snake case name
   --> src/orchestration/optimization/geometric_manifold.rs:224:5
    |
224 |     A: Option<DMatrix<f64>>,
    |     ^ help: convert the identifier to snake case: `a`

warning: structure field `G` should have a snake case name
   --> src/orchestration/optimization/geometric_manifold.rs:225:5
    |
225 |     G: Option<DMatrix<f64>>,
    |     ^ help: convert the identifier to snake case: `g`

warning: variable `F` should have a snake case name
   --> src/orchestration/optimization/geometric_manifold.rs:899:13
    |
899 |         let F = &self.natural_gradient.fisher.F;
    |             ^ help: convert the identifier to snake case (notice the capitalization): `f`

warning: variable `F_reg` should have a snake case name
   --> src/orchestration/optimization/geometric_manifold.rs:900:13
    |
900 |         let F_reg = F + DMatrix::identity(F.nrows(), F.ncols()) * self.natural_gradient.damping;
    |             ^^^^^ help: convert the identifier to snake case (notice the capitalization): `f_reg`

warning: variable `F_inv` should have a snake case name
   --> src/orchestration/optimization/geometric_manifold.rs:902:21
    |
902 |         if let Some(F_inv) = F_reg.try_inverse() {
    |                     ^^^^^ help: convert the identifier to snake case (notice the capitalization): `f_inv`

warning: variable `F` should have a snake case name
   --> src/orchestration/optimization/geometric_manifold.rs:989:21
    |
989 |             let mut F = DMatrix::zeros(x.len(), x.len());
    |                     ^ help: convert the identifier to snake case (notice the capitalization): `f`

warning: structure field `I` should have a snake case name
  --> src/orchestration/neuromorphic/unified_neuromorphic.rs:63:5
   |
63 |     I: f64,
   |     ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: structure field `F` should have a snake case name
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:114:5
    |
114 |     F: f64,
    |     ^ help: convert the identifier to snake case (notice the capitalization): `f`

warning: structure field `D` should have a snake case name
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:116:5
    |
116 |     D: f64,
    |     ^ help: convert the identifier to snake case: `d`

warning: structure field `tau_F` should have a snake case name
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:118:5
    |
118 |     tau_F: f64,
    |     ^^^^^ help: convert the identifier to snake case (notice the capitalization): `tau_f`

warning: structure field `tau_D` should have a snake case name
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:119:5
    |
119 |     tau_D: f64,
    |     ^^^^^ help: convert the identifier to snake case: `tau_d`

warning: structure field `A_plus` should have a snake case name
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:147:5
    |
147 |     A_plus: f64,     // LTP amplitude
    |     ^^^^^^ help: convert the identifier to snake case: `a_plus`

warning: structure field `A_minus` should have a snake case name
   --> src/orchestration/neuromorphic/unified_neuromorphic.rs:148:5
    |
148 |     A_minus: f64,    // LTD amplitude
    |     ^^^^^^^ help: convert the identifier to snake case: `a_minus`

warning: structure field `A` should have a snake case name
  --> src/orchestration/inference/hierarchical_active_inference.rs:40:5
   |
40 |     A: DMatrix<f64>,             // Observation model
   |     ^ help: convert the identifier to snake case: `a`

warning: structure field `B` should have a snake case name
  --> src/orchestration/inference/hierarchical_active_inference.rs:41:5
   |
41 |     B: DMatrix<f64>,             // Transition model
   |     ^ help: convert the identifier to snake case: `b`

warning: structure field `C` should have a snake case name
  --> src/orchestration/inference/hierarchical_active_inference.rs:42:5
   |
42 |     C: DVector<f64>,             // Observation bias
   |     ^ help: convert the identifier to snake case (notice the capitalization): `c`

warning: structure field `D` should have a snake case name
  --> src/orchestration/inference/hierarchical_active_inference.rs:43:5
   |
43 |     D: DVector<f64>,             // Prior over initial states
   |     ^ help: convert the identifier to snake case: `d`

warning: structure field `F` should have a snake case name
  --> src/orchestration/inference/hierarchical_active_inference.rs:69:5
   |
69 |     F: f64,
   |     ^ help: convert the identifier to snake case (notice the capitalization): `f`

warning: structure field `G` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:114:5
    |
114 |     G: Vec<f64>,
    |     ^ help: convert the identifier to snake case: `g`

warning: variable `grad_F` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:443:13
    |
443 |         let grad_F = self.compute_free_energy_gradient(level_idx, &bottom_up_error)?;
    |             ^^^^^^ help: convert the identifier to snake case (notice the capitalization): `grad_f`

warning: variable `total_F` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:520:17
    |
520 |         let mut total_F = 0.0;
    |                 ^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `total_f`

warning: variable `G` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:569:17
    |
569 |             let G = self.evaluate_expected_free_energy(policy)?;
    |                 ^ help: convert the identifier to snake case: `g`

warning: variable `min_G` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:574:13
    |
574 |         let min_G = self.action_selection.G.iter().fold(f64::INFINITY, |a, &b| a.min(b));
    |             ^^^^^ help: convert the identifier to snake case: `min_g`

warning: variable `exp_neg_G` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:575:13
    |
575 |         let exp_neg_G: Vec<f64> = self.action_selection.G.iter()
    |             ^^^^^^^^^ help: convert the identifier to snake case: `exp_neg_g`

warning: variable `G` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:626:17
    |
626 |         let mut G = 0.0;
    |                 ^ help: convert the identifier to snake case: `g`

warning: variable `A_clone` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:707:17
    |
707 |             let A_clone = self.levels[level_idx].A.clone();
    |                 ^^^^^^^ help: convert the identifier to snake case: `a_clone`

warning: variable `B_clone` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:708:17
    |
708 |             let B_clone = self.levels[level_idx].B.clone();
    |                 ^^^^^^^ help: convert the identifier to snake case: `b_clone`

warning: variable `D_clone` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:709:17
    |
709 |             let D_clone = self.levels[level_idx].D.clone();
    |                 ^^^^^^^ help: convert the identifier to snake case: `d_clone`

warning: variable `dA` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:714:21
    |
714 |                 let dA = prediction_error * mu_clone.transpose() * learning_rate;
    |                     ^^ help: convert the identifier to snake case: `d_a`

warning: variable `dB` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:722:21
    |
722 |                 let dB = transition_error * mu_clone.transpose() * learning_rate;
    |                     ^^ help: convert the identifier to snake case: `d_b`

warning: variable `B_to_normalize` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:726:25
    |
726 |                 let mut B_to_normalize = self.levels[level_idx].B.clone();
    |                         ^^^^^^^^^^^^^^ help: convert the identifier to snake case: `b_to_normalize`

warning: variable `B` should have a snake case name
   --> src/orchestration/inference/hierarchical_active_inference.rs:742:43
    |
742 |     fn normalize_transition_matrix(&self, B: &mut DMatrix<f64>) {
    |                                           ^ help: convert the identifier to snake case: `b`

warning: structure field `A` should have a snake case name
  --> src/orchestration/inference/joint_active_inference.rs:55:5
   |
55 |     A: DMatrix<f64>,
   |     ^ help: convert the identifier to snake case: `a`

warning: structure field `B` should have a snake case name
  --> src/orchestration/inference/joint_active_inference.rs:57:5
   |
57 |     B: DMatrix<f64>,
   |     ^ help: convert the identifier to snake case: `b`

warning: structure field `C` should have a snake case name
  --> src/orchestration/inference/joint_active_inference.rs:59:5
   |
59 |     C: DVector<f64>,
   |     ^ help: convert the identifier to snake case (notice the capitalization): `c`

warning: structure field `D` should have a snake case name
  --> src/orchestration/inference/joint_active_inference.rs:61:5
   |
61 |     D: DVector<f64>,
   |     ^ help: convert the identifier to snake case: `d`

warning: structure field `F` should have a snake case name
  --> src/orchestration/inference/joint_active_inference.rs:76:5
   |
76 |     F: f64,
   |     ^ help: convert the identifier to snake case (notice the capitalization): `f`

warning: structure field `G` should have a snake case name
  --> src/orchestration/inference/joint_active_inference.rs:78:5
   |
78 |     G: f64,
   |     ^ help: convert the identifier to snake case: `g`

warning: structure field `T` should have a snake case name
   --> src/orchestration/inference/joint_active_inference.rs:173:5
    |
173 |     T: DMatrix<f64>,
    |     ^ help: convert the identifier to snake case: `t`

warning: structure field `I` should have a snake case name
   --> src/orchestration/inference/joint_active_inference.rs:175:5
    |
175 |     I: DMatrix<f64>,
    |     ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: structure field `J` should have a snake case name
   --> src/orchestration/inference/joint_active_inference.rs:185:5
    |
185 |     J: DMatrix<f64>,
    |     ^ help: convert the identifier to snake case: `j`

warning: structure field `W` should have a snake case name
   --> src/orchestration/inference/joint_active_inference.rs:216:5
    |
216 |     W: DMatrix<f64>,
    |     ^ help: convert the identifier to snake case (notice the capitalization): `w`

warning: structure field `collective_F` should have a snake case name
   --> src/orchestration/inference/joint_active_inference.rs:349:5
    |
349 |     collective_F: f64,
    |     ^^^^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `collective_f`

warning: variable `E` should have a snake case name
   --> src/orchestration/causality/bidirectional_causality.rs:420:13
    |
420 |         let E = self.ccm_engine.embedding_dim;
    |             ^ help: convert the identifier to snake case: `e`

warning: variable `X_restricted` should have a snake case name
   --> src/orchestration/causality/bidirectional_causality.rs:786:17
    |
786 |         let mut X_restricted = DMatrix::zeros(n_samples, max_lag);
    |                 ^^^^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `x_restricted`

warning: variable `X_unrestricted` should have a snake case name
   --> src/orchestration/causality/bidirectional_causality.rs:797:17
    |
797 |         let mut X_unrestricted = DMatrix::zeros(n_samples, max_lag * 2);
    |                 ^^^^^^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `x_unrestricted`

warning: variable `X` should have a snake case name
   --> src/orchestration/causality/bidirectional_causality.rs:881:27
    |
881 |     fn compute_rss(&self, X: &DMatrix<f64>, y: &DVector<f64>) -> Result<f64, OrchestrationError> {
    |                           ^ help: convert the identifier to snake case (notice the capitalization): `x`

warning: variable `XtX` should have a snake case name
   --> src/orchestration/causality/bidirectional_causality.rs:883:13
    |
883 |         let XtX = X.transpose() * X;
    |             ^^^ help: convert the identifier to snake case: `xt_x`

warning: variable `Xty` should have a snake case name
   --> src/orchestration/causality/bidirectional_causality.rs:884:13
    |
884 |         let Xty = X.transpose() * y;
    |             ^^^ help: convert the identifier to snake case (notice the capitalization): `xty`

warning: variable `XtX_inv` should have a snake case name
   --> src/orchestration/causality/bidirectional_causality.rs:886:21
    |
886 |         if let Some(XtX_inv) = XtX.try_inverse() {
    |                     ^^^^^^^ help: convert the identifier to snake case: `xt_x_inv`

warning: variable `Z` should have a snake case name
    --> src/orchestration/causality/bidirectional_causality.rs:1070:17
     |
1070 |         let mut Z = DMatrix::zeros(n, k);
     |                 ^ help: convert the identifier to snake case (notice the capitalization): `z`

warning: variable `X` should have a snake case name
    --> src/orchestration/causality/bidirectional_causality.rs:1089:51
     |
1089 |     fn compute_residuals(&self, y: &DVector<f64>, X: &DMatrix<f64>) -> Result<DVector<f64>, OrchestrationError> {
     |                                                   ^ help: convert the identifier to snake case (notice the capitalization): `x`

warning: variable `XtX` should have a snake case name
    --> src/orchestration/causality/bidirectional_causality.rs:1090:13
     |
1090 |         let XtX = X.transpose() * X;
     |             ^^^ help: convert the identifier to snake case: `xt_x`

warning: variable `XtX_inv` should have a snake case name
    --> src/orchestration/causality/bidirectional_causality.rs:1091:21
     |
1091 |         if let Some(XtX_inv) = XtX.try_inverse() {
     |                     ^^^^^^^ help: convert the identifier to snake case: `xt_x_inv`

warning: variable `K_x` should have a snake case name
    --> src/orchestration/causality/bidirectional_causality.rs:1105:17
     |
1105 |         let mut K_x = DMatrix::zeros(n, n);
     |                 ^^^ help: convert the identifier to snake case (notice the capitalization): `k_x`

warning: variable `K_y` should have a snake case name
    --> src/orchestration/causality/bidirectional_causality.rs:1106:17
     |
1106 |         let mut K_y = DMatrix::zeros(n, n);
     |                 ^^^ help: convert the identifier to snake case (notice the capitalization): `k_y`

warning: variable `H` should have a snake case name
    --> src/orchestration/causality/bidirectional_causality.rs:1116:13
     |
1116 |         let H = DMatrix::identity(n, n) - DMatrix::from_element(n, n, 1.0 / n as f64);
     |             ^ help: convert the identifier to snake case: `h`

warning: variable `K_x_centered` should have a snake case name
    --> src/orchestration/causality/bidirectional_causality.rs:1117:13
     |
1117 |         let K_x_centered = &H * &K_x * &H;
     |             ^^^^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `k_x_centered`

warning: variable `K_y_centered` should have a snake case name
    --> src/orchestration/causality/bidirectional_causality.rs:1118:13
     |
1118 |         let K_y_centered = &H * &K_y * &H;
     |             ^^^^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `k_y_centered`

warning: structure field `W` should have a snake case name
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:222:5
    |
222 |     W: DMatrix<Complex64>,
    |     ^ help: convert the identifier to snake case (notice the capitalization): `w`

warning: structure field `W_opt` should have a snake case name
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:244:5
    |
244 |     W_opt: DMatrix<Complex64>,
    |     ^^^^^ help: convert the identifier to snake case (notice the capitalization): `w_opt`

warning: structure field `H` should have a snake case name
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:360:5
    |
360 |     H: DMatrix<Complex64>,
    |     ^ help: convert the identifier to snake case: `h`

warning: structure field `U` should have a snake case name
   --> src/orchestration/quantum/quantum_entanglement_measures.rs:366:5
    |
366 |     U: Vec<DMatrix<Complex64>>,
    |     ^ help: convert the identifier to snake case (notice the capitalization): `u`

warning: calls to `std::mem::drop` with a reference instead of an owned value does nothing
   --> src/cma/conformal_prediction.rs:326:13
    |
326 |             drop(weights);  // Explicitly drop mutable borrow
    |             ^^^^^-------^
    |                  |
    |                  argument has type `&mut Vec<f64>`
    |
    = note: `#[warn(dropping_references)]` on by default
help: use `let _ = ...` to ignore the expression or result
    |
326 -             drop(weights);  // Explicitly drop mutable borrow
326 +             let _ = weights;  // Explicitly drop mutable borrow
    |

warning: variable `X_flat` should have a snake case name
   --> src/time_series/arima_gpu_optimized.rs:102:17
    |
102 |         let mut X_flat: Vec<f32> = Vec::with_capacity(num_samples * p);
    |                 ^^^^^^ help: convert the identifier to snake case (notice the capitalization): `x_flat`

warning: variable `X_transpose` should have a snake case name
   --> src/time_series/arima_gpu_optimized.rs:115:17
    |
115 |         let mut X_transpose: Vec<f32> = vec![0.0; p * num_samples];
    |                 ^^^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `x_transpose`

warning: variable `XtX` should have a snake case name
   --> src/time_series/arima_gpu_optimized.rs:125:13
    |
125 |         let XtX = executor.tensor_core_matmul_wmma(
    |             ^^^ help: convert the identifier to snake case: `xt_x`

warning: variable `Xty` should have a snake case name
   --> src/time_series/arima_gpu_optimized.rs:136:13
    |
136 |         let Xty = executor.tensor_core_matmul_wmma(
    |             ^^^ help: convert the identifier to snake case (notice the capitalization): `xty`

warning: variable `A` should have a snake case name
   --> src/time_series/arima_gpu_optimized.rs:169:39
    |
169 |     fn solve_linear_system_cpu(&self, A: &[f32], b: &[f32], n: usize) -> Result<Vec<f32>> {
    |                                       ^ help: convert the identifier to snake case: `a`

warning: variable `A_copy` should have a snake case name
   --> src/time_series/arima_gpu_optimized.rs:170:17
    |
170 |         let mut A_copy = A.to_vec();
    |                 ^^^^^^ help: convert the identifier to snake case: `a_copy`

warning: `prism-ai` (lib) generated 649 warnings (run `cargo fix --lib -p prism-ai` to apply 67 suggestions)
[CUBLAS Interposer] Loaded real CUBLAS: /usr/local/cuda-12.8/lib64/libcublas.so.12
[CUBLAS Interposer] Loaded real CUBLAS: /usr/local/cuda-12.8/lib64/libcublas.so.12
[CUBLAS Interposer] Loaded real CUBLAS: /usr/local/cuda-12.8/lib64/libcublas.so.12
[CUBLAS Interposer] Loaded real CUBLAS: /usr/local/cuda-12.8/lib64/libcublas.so.12
[CUBLAS Interposer] Loaded real CUBLAS: /usr/local/cuda-12.8/lib64/libcublas.so.12
[CUBLAS Interposer] Loaded real CUBLAS: /usr/local/cuda-12.8/lib64/libcublas.so.12
   Compiling prism-ai v0.1.0 (/home/diddy/Desktop/PRISM-AI-DoD/03-Source-Code)
[CUBLAS Interposer] Loaded real CUBLAS: /usr/local/cuda-12.8/lib64/libcublas.so.12
    Finished `bench` profile [optimized] target(s) in 5.85s
     Running benches/performance_benchmarks.rs (target/release/deps/performance_benchmarks-e55c26ff756d0b1f)
[CUBLAS Interposer] Loaded real CUBLAS: /usr/local/cuda-12.8/lib64/libcublas.so.12
